++++++++++++Tag: Binary Search++++++++++++


===============Balanced Binary Tree===============
93: Balanced Binary Tree

"Difficulty Medium Accepted Rate 39%"
         


Example
Given binary tree A={3,9,20,#,#,15,7}, B={3,#,20,15,7}A)3B)3 
 / \\
920 20
/\/ \
 15 7157The binary tree A is a height-balanced binary tree, but B is not.

Tags
Binary Search
Divide and Conquer
Recursion
Related Problems

(divide-and-conquer),(recursion),(binary-search-tree),(binary-tree)Medium
 Validate Binary Search Tree
 21 %
// Version 1: with ResultType
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
class ResultType {
    public boolean isBalanced;
    public int maxDepth;
    public ResultType(boolean isBalanced, int maxDepth) {
        this.isBalanced = isBalanced;
        this.maxDepth = maxDepth;
    }
}

public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: True if this Binary tree is Balanced, or false.
     */
    public boolean isBalanced(TreeNode root) {
        return helper(root).isBalanced;
    }
    
    private ResultType helper(TreeNode root) {
        if (root == null) {
            return new ResultType(true, 0);
        }
        
        ResultType left = helper(root.left);
        ResultType right = helper(root.right);
        
        // subtree not balance
        if (!left.isBalanced || !right.isBalanced) {
            return new ResultType(false, -1);
        }
        
        // root not balance
        if (Math.abs(left.maxDepth - right.maxDepth) > 1) {
            return new ResultType(false, -1);
        }
        
        return new ResultType(true, Math.max(left.maxDepth, right.maxDepth) + 1);
    }
}

// Version 2: without ResultType
public class Solution {
    public boolean isBalanced(TreeNode root) {
        return maxDepth(root) != -1;
    }

    private int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        if (left == -1 || right == -1 || Math.abs(left-right) > 1) {
            return -1;
        }
        return Math.max(left, right) + 1;
    }
}

===============Count of Smaller Number===============
248: Count of Smaller Number

"Difficulty Medium Accepted Rate 19%"
         
Give you an integer array (index from 0 to n-1, where n is the size of this array, value from 0 to 10000) and an query list. For each query, give you an integer, return the number of element in the array that are smaller than the given integer.

Example
For array [1,2,7,8,5], and queries [1,8,5], return [0,4,2]Note
We suggest you finish problem Segment Tree Build and Segment Tree Query IIfirst.
Challenge
Could you use three ways to do it.Just loop
Sort and binary search
Build Segment Tree and Search.

Tags
Binary Search
LintCode Copyright
Segment Tree
Related Problems
3
(lintcode-copyright),(binary-tree),(segment-tree)Hard
 Count of Smaller Number before itself
 17 %
public class Solution {
   /**
     * @param A: An integer array
     * @return: The number of element in the array that 
     *          are smaller that the given integer
     */
    class SegmentTreeNode {
        public int start, end;
        public int count;
        public SegmentTreeNode left, right;
        public SegmentTreeNode(int start, int end, int count) {
              this.start = start;
              this.end = end;
              this.count = count;
              this.left = this.right = null;
        }
    }
    SegmentTreeNode root;
    public SegmentTreeNode build(int start, int end) {
        // write your code here
        if(start > end) {  // check core case
            return null;
        }
        
        SegmentTreeNode root = new SegmentTreeNode(start, end, 0);
        
        if(start != end) {
            int mid = (start + end) / 2;
            root.left = build(start, mid);
            root.right = build(mid+1, end);
        } else {
            root.count =  0;
        }
        return root;
    }
    public int querySegmentTree(SegmentTreeNode root, int start, int end) {
        // write your code here
        if(start == root.start && root.end == end) { // 相等 
            return root.count;
        }
        
        
        int mid = (root.start + root.end)/2;
        int leftcount = 0, rightcount = 0;
        // 左子区
        if(start <= mid) {
            if( mid < end) { // 分裂 
                leftcount =  querySegmentTree(root.left, start, mid);
            } else { // 包含 
                leftcount = querySegmentTree(root.left, start, end);
            }
        }
        // 右子区
        if(mid < end) { // 分裂 3
            if(start <= mid) {
                rightcount = querySegmentTree(root.right, mid+1, end);
            } else { //  包含 
                rightcount = querySegmentTree(root.right, start, end);
            } 
        }  
        // else 就是不相交
        return leftcount + rightcount;
    }
    public void modifySegmentTree(SegmentTreeNode root, int index, int value) {
        // write your code here
        if(root.start == index && root.end == index) { // 查找到
            root.count += value;
            return;
        }
        
        // 查询
        int mid = (root.start + root.end) / 2;
        if(root.start <= index && index <=mid) {
            modifySegmentTree(root.left, index, value);
        }
        
        if(mid < index && index <= root.end) {
            modifySegmentTree(root.right, index, value);
        }
        //更新
        root.count = root.left.count + root.right.count;
    }
    public ArrayList<Integer> countOfSmallerNumber(int[] A, int[] queries) {
        // write your code here
        root = build(0, 10000);
        ArrayList<Integer> ans = new ArrayList<Integer>();
        int res;
        for(int i = 0; i < A.length; i++) {
            modifySegmentTree(root, A[i], 1);
        }
        for(int i = 0; i < queries.length; i++) {
            res = 0;
            if(queries[i] > 0)
                res = querySegmentTree(root, 0, queries[i] - 1);
            ans.add(res);
        }
        return ans;
    }
}

===============Find Minimum in Rotated Sorted Array II===============
160: Find Minimum in Rotated Sorted Array II

"Difficulty Medium Accepted Rate 35%"
         
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

Example
Given [4,4,5,6,7,0,1,2] return 0

Tags
Binary Search
Divide and Conquer
Related Problems

(binary-search)Medium
 Find Minimum in Rotated Sorted Array
 33 %
public class Solution {
    public int findMin(int[] num) {
        int min = num[0];
        for (int i = 1; i < num.length; i++) {
            if (num[i] < min)
                min = num[i];
        }
        return min;
    }
}

===============Find Minimum in Rotated Sorted Array===============
159: Find Minimum in Rotated Sorted Array

"Difficulty Medium Accepted Rate 33%"
         
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

Example
Given [4, 5, 6, 7, 0, 1, 2] return 0Note
You may assume no duplicate exists in the array.
Tags
Binary Search
Related Problems

(binary-search),(divide-and-conquer)Medium
 Find Minimum in Rotated Sorted Array II
 35 %
public class Solution {
    /**
     * @param num: a rotated sorted array
     * @return: the minimum number in the array
     */
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        
        int start = 0, end = nums.length - 1;
        int target = nums[nums.length - 1];
        
        // find the first element <= target
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] <= target) {
                end = mid;
            } else {
                start = mid;
            }
        }
        if (nums[start] <= target) {
            return nums[start];
        } else {
            return nums[end];
        }
    }
}

===============Find Peak Element===============
75: Find Peak Element

"Difficulty Medium Accepted Rate 46%"
         
There is an integer array which has the following features:

Example
Given [1, 2, 1, 3, 4, 5, 7, 6]
Return index 1 (which is number 2) or 6 (which is number 7)Note
The array may contains multiple peeks, find any of them.
Challenge
Time complexity O(logN)
Tags
Binary Search
LintCode Copyright
Array
Google
Related Problems
class Solution {
    /**
     * @param A: An integers array.
     * @return: return any of peek positions.
     */
    public int findPeak(int[] A) {
        // write your code here
        int start = 1, end = A.length-2; // 1.答案在之间，2.不会出界 
        while(start + 1 <  end) {
            int mid = (start + end) / 2;
            if(A[mid] < A[mid - 1]) {
                end = mid;
            } else if(A[mid] < A[mid + 1]) {
                start = mid;
            } else {
                end = mid;
            }
        }
        if(A[start] < A[end]) {
            return end;
        } else { 
            return start;
        }
    }
}

===============First Bad Version===============
74: First Bad Version

"Difficulty Medium Accepted Rate 33%"
         
The code base version is an integer start from 1 to n. One day, someone committed a bad version in the code case, so it caused this version and the following versions are all failed in the unit tests. Find the first bad version.

Example
Given n = 5:
isBadVersion(3) -> false
isBadVersion(5) -> true
isBadVersion(4) -> trueHere we are 100% sure that the 4th version is the first bad version.Note
Please read the annotation in code area to get the correct way to call isBadVersion in different language. For example, Java is SVNRepo.isBadVersion(v)
Challenge
You should call isBadVersion as few as possible. 
Tags
Binary Search
LintCode Copyright
Facebook
Related Problems

(quick-sort),(sort)Medium
 Nuts & Bolts Problem 
 13 %
/**
 * public class GitRepo {
 *     public static boolean isBadVersion(int k);
 * }
 * you can use GitRepo.isBadVersion(k) to judge whether 
 * the kth code version is bad or not.
*/
class Solution {
    /**
     * @param n: An integers.
     * @return: An integer which is the first bad version.
     */
    public int findFirstBadVersion(int n) {
        int start = 1, end = n;
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            if (SVNRepo.isBadVersion(mid)) {
                end = mid;
            } else {
                start = mid;
            }
        }
            
        if (SVNRepo.isBadVersion(start)) {
            return start;
        }
        return end;
    }
}

===============First Position of Target===============
14: First Position of Target

"Difficulty Easy Accepted Rate 30%"
         
For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.

Example
If the array is [1, 2, 3, 3, 4, 5, 10], for given target 3, return 2.Challenge
If the count of numbers is bigger than 2^32, can your code work properly?
Tags
Binary Search
Array
Related Problems

(catalan-number),(dynamic-programming)Medium
 Unique Binary Search Trees 
 32 %
 
1
(binary-search),(mathematics),(facebook)Easy
 Sqrt(x)
 23 %
 
2
(binary-search-tree),(binary-tree)Medium
 Search Range in Binary Search Tree
 36 %
class Solution {
    /**
     * @param nums: The integer array.
     * @param target: Target to find.
     * @return: The first position of target. Position starts from 0.
     */
    public int binarySearch(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        
        int start = 0, end = nums.length - 1;
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] < target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        
        if (nums[start] == target) {
            return start;
        }
        
        if (nums[end] == target) {
            return end;
        }
        
        return -1;
    }
}

===============Longest Increasing Subsequence===============
76: Longest Increasing Subsequence

"Difficulty Medium Accepted Rate 25%"
         
Given a sequence of integers, find the longest increasing subsequence (LIS).

Example
For [5, 4, 1, 2, 3], the LIS  is [1, 2, 3], return 3
For [4, 2, 4, 5, 3, 7], the LIS is [4, 4, 5, 7], return 4Challenge
Time complexity O(n^2) or O(nlogn)
Clarification
What's the definition of longest increasing subsequence?
    * The longest increasing subsequence problem is to find a subsequence of a given sequence in which the subsequence's elements are in sorted order, lowest to highest, and in which the subsequence is as long as possible. This subsequence is not necessarily contiguous, or unique.  
    * https://en.wikipedia.org/wiki/Longest_common_subsequence_problem
Tags
Binary Search
LintCode Copyright
Dynamic Programming
public class Solution {
    /**
     * @param nums: The integer array
     * @return: The length of LIS (longest increasing subsequence)
     */
   
    
    public int longestIncreasingSubsequence(int[] nums) {
        int []f = new int[nums.length];
        int max = 0;
        for (int i = 0; i < nums.length; i++) {
            f[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[j] <= nums[i]) {
                    f[i] = f[i] > f[j] + 1 ? f[i] : f[j] + 1;
                }
            }
            if (f[i] > max) {
                max = f[i];
            }
        }
        return max;
    }
}

===============Search a 2D Matrix===============
28: Search a 2D Matrix

"Difficulty Easy Accepted Rate 27%"
         
Write an efficient algorithm that searches for a value in an m x n matrix.

Example
Consider the following matrix:
[
[1, 3, 5, 7],
[10, 11, 16, 20],
[23, 30, 34, 50]
]Given target = 3, return true.Challenge
O(log(n) + log(m)) time
Tags
Binary Search
Matrix
Related Problems

(binary-search),(sorted-array),(linkedin),(array),(facebook),(uber)Medium
 Search in Rotated Sorted Array
 28 %
 
2
(matrix),(sorted-matrix),(google)Medium
 Search a 2D Matrix II
 31 %
// Binary Search Twice
public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }
        if (matrix[0] == null || matrix[0].length == 0) {
            return false;
        }
        
        int row = matrix.length;
        int column = matrix[0].length;
        
        // find the row index, the last number <= target 
        int start = 0, end = row - 1;
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            if (matrix[mid][0] == target) {
                return true;
            } else if (matrix[mid][0] < target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        if (matrix[end][0] <= target) {
            row = end;
        } else if (matrix[start][0] <= target) {
            row = start;
        } else {
            return false;
        }
        
        // find the column index, the number equal to target
        start = 0;
        end = column - 1;
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            if (matrix[row][mid] == target) {
                return true;
            } else if (matrix[row][mid] < target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        if (matrix[row][start] == target) {
            return true;
        } else if (matrix[row][end] == target) {
            return true;
        }
        return false;
    }
}

// Binary Search Once
public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }
        if (matrix[0] == null || matrix[0].length == 0) {
            return false;
        }
        
        int row = matrix.length, column = matrix[0].length;
        int start = 0, end = row * column - 1;
        
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            int number = matrix[mid / column][mid % column];
            if (number == target) {
                return true;
            } else if (number < target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        
        if (matrix[start / column][start % column] == target) {
            return true;
        } else if (matrix[end / column][end % column] == target) {
            return true;
        }
        
        return false;
    }
}

===============Search for a Range===============
61: Search for a Range

"Difficulty Medium Accepted Rate 20%"
         
Given a sorted array of n integers, find the starting and ending position of a given target value.

Example
Given [5, 7, 7, 8, 8, 10] and target value 8,
return [3, 4].Challenge
O(log n) time.
Tags
Binary Search
Sorted Array
Array
Related Problems
public class Solution {
    public int[] searchRange(int[] A, int target) {
        if (A.length == 0) {
            return new int[]{-1, -1};
        }
        
        int start, end, mid;
        int[] bound = new int[2]; 
        
        // search for left bound
        start = 0; 
        end = A.length - 1;
        while (start + 1 < end) {
            mid = start + (end - start) / 2;
            if (A[mid] == target) {
                end = mid;
            } else if (A[mid] < target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        if (A[start] == target) {
            bound[0] = start;
        } else if (A[end] == target) {
            bound[0] = end;
        } else {
            bound[0] = bound[1] = -1;
            return bound;
        }
        
        // search for right bound
        start = 0;
        end = A.length - 1;
        while (start + 1 < end) {
            mid = start + (end - start) / 2;
            if (A[mid] == target) {
                start = mid;
            } else if (A[mid] < target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        if (A[end] == target) {
            bound[1] = end;
        } else if (A[start] == target) {
            bound[1] = start;
        } else {
            bound[0] = bound[1] = -1;
            return bound;
        }
        
        return bound;
    }
}

===============Search in Rotated Sorted Array II===============
63: Search in Rotated Sorted Array II

"Difficulty Medium Accepted Rate 40%"
         


Example
Tags
Binary Search
Sorted Array
Array
// it ends up the same as sequential search
// We used linear search for this question just to indicate that the 
// time complexity of this question is O(n) regardless of binary search is applied or not.
public class Solution {
    public boolean search(int[] A, int target) {
        for (int i = 0; i < A.length; i ++) {
            if (A[i] == target) {
                return true;
            }
        }
        return false;
    }
}

===============Search in Rotated Sorted Array===============
62: Search in Rotated Sorted Array

"Difficulty Medium Accepted Rate 28%"
         
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

Example
For [4, 5, 1, 2, 3] and target=1, return 2.
For [4, 5, 1, 2, 3] and target=0, return -1.Challenge
O(logN) time
Tags
Binary Search
Sorted Array
LinkedIn
Array
Facebook
Uber
Related Problems
1
(binary-search),(matrix)Easy
 Search a 2D Matrix 
 27 %
public class Solution {
    public int search(int[] A, int target) {
        if (A == null || A.length == 0) {
            return -1;
        }

        int start = 0;
        int end = A.length - 1;
        int mid;
        
        while (start + 1 < end) {
            mid = start + (end - start) / 2;
            if (A[mid] == target) {
                return mid;
            }
            if (A[start] < A[mid]) {
                // situation 1, red line
                if (A[start] <= target && target <= A[mid]) {
                    end = mid;
                } else {
                    start = mid;
                }
            } else {
                // situation 2, green line
                if (A[mid] <= target && target <= A[end]) {
                    start = mid;
                } else {
                    end = mid;
                }
            }
        } // while
        
        if (A[start] == target) {
            return start;
        }
        if (A[end] == target) {
            return end;
        }
        return -1;
    }
}

===============Search Insert Position===============
60: Search Insert Position

"Difficulty Easy Accepted Rate 28%"
         
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

Example
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0Challenge
O(log(n)) time
Tags
Binary Search
Sorted Array
Array
// version 1: find the first position >= target
public class Solution {
    public int searchInsert(int[] A, int target) {
        if (A == null || A.length == 0) {
            return 0;
        }
        int start = 0, end = A.length - 1;
        
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            if (A[mid] == target) {
                return mid;
            } else if (A[mid] < target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        
        if (A[start] >= target) {
            return start;
        } else if (A[end] >= target) {
            return end;
        } else {
            return end + 1;
        }
    }
}

// version 2: find the last position < target, return +1， 要特判一下target小于所有数组里面的元素

public class Solution {
    public int searchInsert(int[] A, int target) {
        if (A == null || A.length == 0) {
            return 0;
        }
        int start = 0;
        int end = A.length - 1;
        int mid;
        
        if (target < A[0]) {
            return 0;
        }
        // find the last number less than target
        while (start + 1 < end) {
            mid = start + (end - start) / 2;
            if (A[mid] == target) {
                return mid;
            } else if (A[mid] < target) {
                start = mid;
            } else {
                end = mid;
            }
        }
        
        if (A[end] == target) {
            return end;
        }
        if (A[end] < target) {
            return end + 1;
        }
        if (A[start] == target) {
            return start;
        }
        return start + 1;
    }
}

===============Wood Cut===============
183: Wood Cut

"Difficulty Medium Accepted Rate 20%"
         
Given n pieces of wood with length L[i] (integer array). Cut them into small pieces to guarantee you could have equal or more than k pieces with the same length. What is the longest length you can get from the n pieces of wood? Given L & k, return the maximum length of the small pieces.

Example
For L=[232, 124, 456], k=7, return 114.Note
You couldn't cut wood into float length.
Challenge
O(n log Len), where Len is the longest length of the wood.
Tags
Binary Search
public class Solution {
    /** 
     *@param L: Given n pieces of wood with length L[i]
     *@param k: An integer
     *return: The maximum length of the small pieces.
     */
    public int woodCut(int[] L, int k) {
        int max = 0;
        for (int i = 0; i < L.length; i++) {
            max = Math.max(max, L[i]);
        }
        
        // find the largest length that can cut more than k pieces of wood.
        int start = 1, end = max;
        while (start + 1 < end) {
            int mid = start + (end - start) / 2;
            if (count(L, mid) >= k) {
                start = mid;
            } else {
                end = mid;
            }
        }
        
        if (count(L, end) >= k) {
            return end;
        }
        if (count(L, start) >= k) {
            return start;
        }
        return 0;
    }
    
    private int count(int[] L, int length) {
        int sum = 0;
        for (int i = 0; i < L.length; i++) {
            sum += L[i] / length;
        }
        return sum;
    }
}++++++++++++Tag: Greedy++++++++++++


===============Best Time to Buy and Sell Stock II===============
150: Best Time to Buy and Sell Stock II

"Difficulty Medium Accepted Rate 49%"
         
Given an example [2,1,2,0,1], return 2

Example
Given an example [2,1,2,0,1], return 2

Tags
Greedy
Enumeration
Array
Related Problems
3
(dynamic-programming)Hard
 Best Time to Buy and Sell Stock IV
 22 %
 
2
(enumeration),(forward-backward-traversal),(array)Medium
 Best Time to Buy and Sell Stock III 
 26 %
 
3
(lintcode-copyright),(dynamic-programming),(subarray),(array)Hard
 Maximum Subarray III
 23 %
public class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            int diff = prices[i+1] - prices[i];
            if (diff > 0) {
                profit += diff;
            }
        }
        return profit;
    }
}

===============Best Time to Buy and Sell Stock===============
149: Best Time to Buy and Sell Stock

"Difficulty Medium Accepted Rate 41%"
         
Given an example [3,2,3,1,2], return 1

Example
Given an example [3,2,3,1,2], return 1

Tags
Greedy
Enumeration
Array
Facebook
Uber
Related Problems
3
(dynamic-programming)Hard
 Best Time to Buy and Sell Stock IV
 22 %
 
2
(linkedin),(dynamic-programming),(subarray)Medium
 Maximum Product Subarray 
 27 %
 
2
(enumeration),(forward-backward-traversal),(array)Medium
 Best Time to Buy and Sell Stock III 
 26 %
 
3
(lintcode-copyright),(dynamic-programming),(subarray),(array)Hard
 Maximum Subarray III
 23 %
public class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }

        int min = Integer.MAX_VALUE;  //just remember the smallest price
        int profit = 0;
        for (int i : prices) {
            min = i < min ? i : min;
            profit = (i - min) > profit ? i - min : profit;
        }

        return profit;
    }
}

===============Candy===============
412: Candy

"Difficulty Hard Accepted Rate 32%"
         
There are N children standing in a line. Each child is assigned a rating value.

Example
Given ratings = [1, 2], return 3.
Given ratings = [1, 1, 1], return 3.
Given ratings = [1, 2, 2], return 4. ([1,2,1]).

Tags
Greedy
Array
public class Solution {
    public int candy(int[] ratings) {
        if(ratings == null || ratings.length == 0) {
            return 0;
        }

        int[] count = new int[ratings.length];
        Arrays.fill(count, 1);
        int sum = 0;
        for(int i = 1; i < ratings.length; i++) {
            if(ratings[i] > ratings[i - 1]) {
                count[i] = count[i - 1] + 1;
            }
        }

        for(int i = ratings.length - 1; i >= 1; i--) {
            sum += count[i];
            if(ratings[i - 1] > ratings[i] && count[i - 1] <= count[i]) {  // second round has two conditions
                count[i-1] = count[i] + 1;
            }
        }
        sum += count[0];
        return sum;
    }
}

===============Coins in a Line===============
394: Coins in a Line

"Difficulty Medium Accepted Rate 41%"
         
There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.

Example
n = 1, return true.
n = 2, return true.
n = 3, return false.
n = 4, return true.
n = 5, return true.Challenge
O(n) time and O(1) memory
Tags
Greedy
Dynamic Programming
Array
Game Theory
Related Problems

(dynamic-programming),(array),(game-theory)Medium
 Coins in a Line II
 29 %
public class Solution {
    /**
     * @param n: an integer
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int n) {
        // write your code here
        int []dp = new int[n+1];
        
        return MemorySearch(n, dp);
        
    }
    boolean MemorySearch(int n, int []dp) { // 0 is empty, 1 is false, 2 is true
        if(dp[n] != 0) {
            if(dp[n] == 1)
                return false;
            else
                return true;
        }
        if(n <= 0) {
            dp[n] = 1;
        } else if(n == 1) {
            dp[n] = 2;
        } else if(n == 2) {
            dp[n] = 2;
        } else if(n == 3) {
            dp[n] = 1;
        } else {
            if((MemorySearch(n-2, dp) && MemorySearch(n-3, dp)) || 
                (MemorySearch(n-3, dp) && MemorySearch(n-4, dp) )) {
                dp[n] = 2;
            } else {
                dp[n] = 1;
            }
        }
        if(dp[n] == 2) 
            return true;
        return false;
    }
}

===============Delete Digits===============
182: Delete Digits

"Difficulty Medium Accepted Rate 17%"
         
Given string A representative a positive integer which has N digits, remove any k digits of the number, the remaining digits are arranged according to the original order to become a new positive integer.

Example
Given an integer A = "178542", k = 4
return a string "12"

Tags
Greedy
LintCode Copyright
Related Problems

(sort)Medium
 Largest Number 
 17 %
class Solution {
public:
    /**
     *@param A: A positive integer which has N digits, A is a string.
     *@param k: Remove k digits.
     *@return: A string
     */
    string remove(string A, int pos) {
        return A.substr(0, pos) + A.substr(pos + 1, A.length() - pos - 1);
    }
    
    string DeleteDigits(string A, int k) {
        if (A.length() == k) {
            return "";
        }
        
        for (int i = 0; i < k; i++) {
            for (int j = 0; j < A.length(); j++) {
                if (j == A.length() - 1 || A[j + 1] < A[j]) {
                    A = remove(A, j);
                    break;
                }
            }
        }
        
        int i = 0;
        while (i < A.length() - 1 && A[i] == &#39;0&#39;) {
            i++;
        }
        return A.substr(i, A.length() - i);
    }
};

===============Gas Station===============
187: Gas Station

"Difficulty Medium Accepted Rate 29%"
         
There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

Example
Given 4 gas stations with gas[i]=[1,1,3,1], and the cost[i]=[2,2,1,1]. The starting gas station's index is 2.Note
The solution is guaranteed to be unique.
Challenge
O(n) time and O(1) extra space
Tags
Greedy
public class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        if (gas == null || cost == null || gas.length == 0 || cost.length == 0) {
            return -1;
        }

        int sum = 0;
        int total = 0;
        int index = -1;

        for(int i = 0; i<gas.length; i++) {
            sum += gas[i] - cost[i];
            total += gas[i] - cost[i];
            if(sum < 0) {
                index = i;
                sum = 0;
            }
        }
        return total < 0 ? -1 : index + 1;
        // index should be updated here for cases ([5], [4]);
        // total < 0 is for case [2], [2]
    }
}

===============Jump Game II===============
117: Jump Game II

"Difficulty Medium Accepted Rate 34%"
         
Given an array of non-negative integers, you are initially positioned at the first index of the array.


Example
Given array A = [2,3,1,1,4]
The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)
Tags
Greedy
Array
Related Problems

(greedy),(dynamic-programming),(array)Medium
 Jump Game
 37 %
// version 1: Dynamic Programming
public class Solution {
    public int jump(int[] A) {
        int[] steps = new int[A.length];
        
        steps[0] = 0;
        for (int i = 1; i < A.length; i++) {
            steps[i] = Integer.MAX_VALUE;
            for (int j = 0; j < i; j++) {
                if (steps[j] != Integer.MAX_VALUE && j + A[j] >= i) {
                    steps[i] = steps[j] + 1;
                    break;
                }
            }
        }
        
        return steps[A.length - 1];
    }
}


// version 2: Greedy
public class Solution {
    public int jump(int[] A) {
        if (A == null || A.length == 0) {
            return -1;
        }
        int start = 0, end = 0, jumps = 0;
        while (end < A.length - 1) {
            jumps++;
            int farthest = end;
            for (int i = start; i <= end; i++) {
                if (A[i] + i > farthest) {
                    farthest = A[i] + i;
                }
            }
            start = end + 1;
            end = farthest;
        }
        return jumps;
    }
}

===============Jump Game===============
116: Jump Game

"Difficulty Medium Accepted Rate 37%"
         
Given an array of non-negative integers, you are initially positioned at the first index of the array.


Example
A = [2,3,1,1,4], return true.A = [3,2,1,0,4], return false.
Note
This problem have two method which is Greedy and Dynamic Programming. 
The time complexity of Greedy method is O(n).
The time complexity of Dynamic Programming method is O(n^2). 
We manually set the small data set to allow you pass the test in both ways. This is just to let you learn how to use this problem in dynamic programming ways. If you finish it in dynamic programming ways, you can try greedy method to make it accept again. 
Tags
Greedy
Dynamic Programming
Array
Related Problems

(greedy),(array)Medium
 Jump Game II
 34 %
// version 1: Dynamic Programming
public class Solution {
    public boolean canJump(int[] A) {
        boolean[] can = new boolean[A.length];
        can[0] = true;
        
        for (int i = 1; i < A.length; i++) {
            for (int j = 0; j < i; j++) {
                if (can[j] && j + A[j] >= i) {
                    can[i] = true;
                    break;
                }
            }
        }
        
        return can[A.length - 1];
    }
}


// version 2: Greedy
public class Solution {
    public boolean canJump(int[] A) {
        // think it as merging n intervals
        if (A == null || A.length == 0) {
            return false;
        }
        int farthest = A[0];
        for (int i = 1; i < A.length; i++) {
            if (i <= farthest && A[i] + i >= farthest) {
                farthest = A[i] + i;
            }
        }
        return farthest >= A.length - 1;
    }
}

===============Majority Number II===============
47: Majority Number II

"Difficulty Medium Accepted Rate 28%"
         
Given an array of integers, the majority number is the number that occurs more than 1/3 of the size of the array.

Example
Given [1, 2, 1, 2, 1, 3, 3], return 1.Note
There is only one majority number in the array.
Challenge
O(n) time and O(1) extra space.
Tags
Greedy
Enumeration
LintCode Copyright
Zenefits
Related Problems

(greedy),(lintcode-copyright)Medium
 Single Number III
 33 %
 
2
(greedy)Medium
 Single Number II
 38 %
 
1
(greedy)Easy
 Single Number
 57 %
 
2
(lintcode-copyright),(hash-table),(linked-list)Medium
 Majority Number III
 25 %
 
2
(greedy),(enumeration),(lintcode-copyright),(zenefits)Medium
 Majority Number II
 28 %
 
1
(greedy),(enumeration),(lintcode-copyright),(zenefits)Easy
 Majority Number
 40 %
public class Solution {
    /**
     * @param nums: A list of integers
     * @return: The majority number that occurs more than 1/3
     */
    public int majorityNumber(ArrayList<Integer> nums) {
        int candidate1 = 0, candidate2 = 0;
        int count1, count2;
        count1 = count2 = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (candidate1 == nums.get(i)) {
                count1 ++;
            } else if (candidate2 == nums.get(i)) {
                count2 ++;
            } else if (count1 == 0) {
                candidate1 = nums.get(i);
                count1 = 1;
            } else if (count2 == 0) {
                candidate2 = nums.get(i);
                count2 = 1;
            } else {
                count1--;
                count2--;
            }
        }
        count1 = count2 = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums.get(i) == candidate1) {
                count1++;
            } else if (nums.get(i) == candidate2) {
                count2++;
            }
        }    
        return count1 > count2 ? candidate1 : candidate2;
    }
}

===============Majority Number===============
46: Majority Number

"Difficulty Easy Accepted Rate 40%"
         
Given an array of integers, the majority number is the number that occurs more than half of the size of the array. Find it.

Example
Given [1, 1, 1, 1, 2, 2, 2], return 1Challenge
O(n) time and O(1) extra space
Tags
Greedy
Enumeration
LintCode Copyright
Zenefits
Related Problems

(greedy),(lintcode-copyright)Medium
 Single Number III
 33 %
 
2
(greedy)Medium
 Single Number II
 38 %
 
1
(greedy)Easy
 Single Number
 57 %
 
2
(lintcode-copyright),(hash-table),(linked-list)Medium
 Majority Number III
 25 %
 
2
(greedy),(enumeration),(lintcode-copyright),(zenefits)Medium
 Majority Number II
 28 %
 
2
(enumeration)Medium
 Digit Counts
 30 %
public class Solution {
    /**
     * @param nums: a list of integers
     * @return: find a  majority number
     */
    public int majorityNumber(ArrayList<Integer> nums) {
        int count = 0, candidate = -1;
        for (int i = 0; i < nums.size(); i++) {
            if (count == 0) {
                candidate = nums.get(i);
                count = 1;
            } else if (candidate == nums.get(i)) {
                count++;
            } else {
                count--;
            }
        }
        return candidate;
    }
}

===============Maximum Gap===============
400: Maximum Gap

"Difficulty Hard Accepted Rate 23%"
         
Given an unsorted array, find the maximum difference between the successive elements in its sorted form.

Example
Given [1, 9, 2, 5], the sorted form of it is [1, 2, 5, 9], the maximum gap is between 5 and 9 = 4. Note
You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.
Challenge
Sort is easy but will cost O(nlogn) time. Try to solve it in linear time and space.
Tags
Greedy
Sort

struct Block {
  int max, min;
};

class Solution {
public:
    int maximumGap(vector<int>& nums) {
        int n = nums.size();
      
        if (nums.size() < 2) {
            return 0;
        }
        int min = nums[0];
        int max = nums[0];
        for (int i = 1; i < nums.size(); i++) {
           min = min < nums[i] ? min : nums[i];
           max = max > nums[i] ? max : nums[i];
        }
        if (max == min) {
          return 0;
        }
        int block_size = (max - min - 1) / n + 1;
        cout << block_size << endl;
        vector<Block> blocks(n);
        for (int i = 0; i < n; i++) {
          blocks[i].max = blocks[i].min = -1;
        }
        for (int i = 0; i < n; i++) {
          int block_id = (nums[i] - min) / block_size;
          if (blocks[block_id].max == -1) {
            blocks[block_id].min = blocks[block_id].max = nums[i];
          } else {
            blocks[block_id].min = blocks[block_id].min < nums[i] ? blocks[block_id].min : nums[i];
            blocks[block_id].max = blocks[block_id].max > nums[i] ? blocks[block_id].max : nums[i];
          }
        }
      
        int maxGap = -1;
        int lastNumber = blocks[0].max;
        for (int i = 1; i < n; i++) {
          if (blocks[i].min == -1) {
            continue;
          }
          maxGap = maxGap > blocks[i].min - lastNumber ? maxGap : blocks[i].min - lastNumber;
          lastNumber = blocks[i].max;
        }
        return maxGap;
    }
};

===============Maximum Subarray II===============
42: Maximum Subarray II

"Difficulty Medium Accepted Rate 23%"
         
Given an array of integers, find two non-overlapping subarrays which have the largest sum.
The number in each subarray should be contiguous.
Return the largest sum.

Example
For given [1, 3, -1, 2, -1, 2], the two subarrays are [1, 3] and [2, -1, 2] or [1, 3, -1, 2] and [2], they both have the largest sum 7.Note
The subarray should contain at least one number
Challenge
Can you do it in time complexity O(n) ?
Tags
Greedy
Enumeration
Forward-Backward Traversal
LintCode Copyright
Subarray
Array
Related Problems

(linkedin),(dynamic-programming),(subarray)Medium
 Maximum Product Subarray 
 27 %
 
2
(enumeration),(forward-backward-traversal),(array)Medium
 Best Time to Buy and Sell Stock III 
 26 %
 
3
(lintcode-copyright),(dynamic-programming),(subarray),(array)Hard
 Maximum Subarray III
 23 %
public class Solution {
    /**
     * @param nums: A list of integers
     * @return: An integer denotes the sum of max two non-overlapping subarrays
     */
    public int maxTwoSubArrays(ArrayList<Integer> nums) {
        // write your code
        int size = nums.size();
        int[] left = new int[size];
        int[] right = new int[size];
        int sum = 0;
        int minSum = 0;
        int max = Integer.MIN_VALUE;
        for(int i = 0; i < size; i++){
            sum += nums.get(i);
            max = Math.max(max, sum - minSum);
            minSum = Math.min(sum, minSum);
            left[i] = max;
        }
        sum = 0;
        minSum = 0;
        max = Integer.MIN_VALUE;
        for(int i = size - 1; i >= 0; i--){
            sum += nums.get(i);
            max = Math.max(max, sum - minSum);
            minSum = Math.min(sum, minSum);
            right[i] = max;
        }
        max = Integer.MIN_VALUE;
        for(int i = 0; i < size - 1; i++){
            max = Math.max(max, left[i] + right[i + 1]);
        }
        return max;
    }
}

===============Maximum Subarray===============
41: Maximum Subarray

"Difficulty Easy Accepted Rate 37%"
         
Given an array of integers, find a contiguous subarray which has the largest sum.

Example
Given the array [−2,2,−3,4,−1,2,1,−5,3], the contiguous subarray [4,−1,2,1] has the largest sum = 6.Note
The subarray should contain at least one number.
Challenge
Can you do it in time complexity O(n)?
Tags
Greedy
Enumeration
LintCode Copyright
LinkedIn
Subarray
Array
Related Problems

(subarray),(array)Medium
 Continuous Subarray Sum
 22 %
 
2
(enumeration),(forward-backward-traversal),(array)Medium
 Best Time to Buy and Sell Stock III 
 26 %
 
3
(lintcode-copyright),(dynamic-programming),(subarray),(array)Hard
 Maximum Subarray III
 23 %
// Version 1: Greedy

public class Solution {
    public int maxSubArray(int[] A) {
        if (A == null || A.length == 0){
            return 0;
        }
        
        int max = Integer.MIN_VALUE, sum = 0;
        for (int i = 0; i < A.length; i++) {
            sum += A[i];
            max = Math.max(max, sum);
            sum = Math.max(sum, 0);
        }

        return max;
    }
}

// Version 2: Prefix Sum (DP)

public class Solution {
    public int maxSubArray(int[] A) {
        if (A == null || A.length == 0){
            return 0;
        }
        
        int max = Integer.MIN_VALUE, sum = 0, minSum = 0;
        for (int i = 0; i < A.length; i++) {
            sum += A[i];
            max = Math.max(max, sum - minSum);
            minSum = Math.min(minSum, sum);
        }

        return max;
    }
}



public class Solution {
    /**
     * @param nums: a list of integers
     * @return: A integer indicate the sum of minimum subarray
     */
    public int maxSubArray(ArrayList<Integer> nums) {
        // write your code
        if(nums.size()==0)  
            return 0;  
        int n = nums.size();
        int []global = new int[n];
        int []local = new int[n];
        global[0] = nums.get(0);
        local[0] = nums.get(0);
        for(int i=1;i<n;i++)  
        {  
            local[i] = Math.max(nums.get(i),local[i-1]+nums.get(i));  
            global[i] = Math.max(local[i],global[i-1]);  
        }  
        return global[n-1];  
    }
}

===============Minimum Subarray===============
44: Minimum Subarray

"Difficulty Easy Accepted Rate 37%"
         
Given an array of integers, find the subarray with smallest sum.

Example
For [1, -1, -2, 1], return -3Note
The subarray should contain at least one integer.
Tags
Greedy
LintCode Copyright
Subarray
Array
Related Problems

(linkedin),(dynamic-programming),(subarray)Medium
 Maximum Product Subarray 
 27 %
public class Solution {
    /**
     * @param nums: a list of integers
     * @return: A integer indicate the sum of minimum subarray
     */
    public int minSubArray(ArrayList<Integer> nums) {
        if (nums == null)
            return 0;
        int len = nums.size();
        int min = Integer.MAX_VALUE, currSum = 0;
        int []localmin  = new int[len];
        int []globalmin = new int[len];
        for (int i = 0; i < len; i++) {
            if( i ==0 )
                globalmin[i] = localmin[i] = nums.get(i);
            else {
                localmin[i] = Math.min(localmin[i - 1] + nums.get(i), nums.get(i));
                globalmin[i] = Math.min(globalmin[i - 1], localmin[i]);
            }
            
        }
        return globalmin[len-1];
    }
}

===============Single Number II===============
83: Single Number II

"Difficulty Medium Accepted Rate 38%"
         
Given 3*n + 1 numbers, every numbers occurs triple times except one, find it.

Example
Given [1,1,2,3,3,3,2,2,4,1] return 4Challenge
One-pass, constant extra space.
Tags
Greedy
Related Problems

(greedy),(lintcode-copyright)Medium
 Single Number III
 33 %
 
1
(greedy)Easy
 Single Number
 57 %
 
2
(lintcode-copyright),(hash-table),(linked-list)Medium
 Majority Number III
 25 %
 
2
(greedy),(enumeration),(lintcode-copyright),(zenefits)Medium
 Majority Number II
 28 %
 
1
(greedy),(enumeration),(lintcode-copyright),(zenefits)Easy
 Majority Number
 40 %
public class Solution {
    public int singleNumber(int[] A) {
        if (A == null || A.length == 0) {
            return -1;
        }
        int result=0;
        int[] bits=new int[32];
        for (int i = 0; i < 32; i++) {
            for(int j = 0; j < A.length; j++) {
                bits[i] += A[j] >> i & 1;
                bits[i] %= 3;
            }

            result |= (bits[i] << i);
        }
        return result;
    }
}

===============Single Number III===============
84: Single Number III

"Difficulty Medium Accepted Rate 33%"
         
Given 2*n + 2 numbers, every numbers occurs twice except two, find them.

Example
Given [1,2,2,3,4,4,5,3] return 1 and 5Challenge
O(n) time, O(1) extra space.
Tags
Greedy
LintCode Copyright
Related Problems

(greedy)Medium
 Single Number II
 38 %
 
1
(greedy)Easy
 Single Number
 57 %
 
2
(lintcode-copyright),(hash-table),(linked-list)Medium
 Majority Number III
 25 %
 
2
(greedy),(enumeration),(lintcode-copyright),(zenefits)Medium
 Majority Number II
 28 %
 
1
(greedy),(enumeration),(lintcode-copyright),(zenefits)Easy
 Majority Number
 40 %
public class Solution {
    /**
     * @param A : An integer array
     * @return : Two integers
     */
    public List<Integer> singleNumberIII(int[] A) {
        int xor = 0;
        for (int i = 0; i < A.length; i++) {
            xor ^= A[i];
        }
        
        int lastBit = xor - (xor & (xor - 1));
        int group0 = 0, group1 = 0;
        for (int i = 0; i < A.length; i++) {
            if ((lastBit & A[i]) == 0) {
                group0 ^= A[i];
            } else {
                group1 ^= A[i];
            }
        }
        
        ArrayList<Integer> result = new ArrayList<Integer>();
        result.add(group0);
        result.add(group1);
        return result;
    }
}

===============Single Number===============
82: Single Number

"Difficulty Easy Accepted Rate 57%"
         
Given 2*n + 1 numbers, every numbers occurs twice except one, find it.

Example
Given [1,2,2,1,3,4,3], return 4Challenge
One-pass, constant extra space.
Tags
Greedy
Related Problems

(greedy),(lintcode-copyright)Medium
 Single Number III
 33 %
 
2
(greedy)Medium
 Single Number II
 38 %
 
2
(lintcode-copyright),(hash-table),(linked-list)Medium
 Majority Number III
 25 %
 
2
(greedy),(enumeration),(lintcode-copyright),(zenefits)Medium
 Majority Number II
 28 %
 
1
(greedy),(enumeration),(lintcode-copyright),(zenefits)Easy
 Majority Number
 40 %
public class Solution {
    public int singleNumber(int[] A) {
        if(A == null || A.length == 0) {
            return -1;
        }
        int rst = 0;
        for (int i = 0; i < A.length; i++) {
            rst ^= A[i];
        }
        return rst;
    }
}

===============Wildcard Matching===============
192: Wildcard Matching

"Difficulty Hard Accepted Rate 27%"
         
Implement wildcard pattern matching with support for '?' and '*'.

Example
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false
Tags
Greedy
String
Backtracking
Dynamic Programming
Google
Related Problems
3
(string),(backtracking),(dynamic-programming),(facebook),(google)Hard
 Regular Expression Matching
 23 %
// For detailed explanation, see http://discuss.leetcode.com/questions/222/wildcard-matching

// Time: O(|s||p|*log|s|), Space: O(|s|)
// Time can also optimize to O(|s||p|)

public class Solution {

public boolean isMatch(String s, String p) {
    // without this optimization, it will fail for large data set
    int plenNoStar = 0;
    for (char c : p.toCharArray())
        if (c != &#39;*&#39;) plenNoStar++;
    if (plenNoStar > s.length()) return false;

    s = " " + s;
    p = " " + p;
    int slen = s.length();
    int plen = p.length();

    boolean[] dp = new boolean[slen];
    TreeSet<Integer> firstTrueSet = new TreeSet<Integer>();
    firstTrueSet.add(0);
    dp[0] = true;

    boolean allStar = true;
    for (int pi = 1; pi < plen; pi++) {
        if (p.charAt(pi) != &#39;*&#39;)
            allStar = false;
        for (int si = slen - 1; si >= 0; si--) {
            if (si == 0) {
                dp[si] = allStar ? true : false;
            } else if (p.charAt(pi) != &#39;*&#39;) {
                if (s.charAt(si) == p.charAt(pi) || p.charAt(pi) == &#39;?&#39;) dp[si] = dp[si-1];
                else dp[si] = false;
            } else {
                int firstTruePos = firstTrueSet.isEmpty() ? Integer.MAX_VALUE : firstTrueSet.first();
                if (si >= firstTruePos) dp[si] = true;
                else dp[si] = false;
            }
            if (dp[si]) firstTrueSet.add(si);
            else firstTrueSet.remove(si);
        }
    }
    return dp[slen - 1];
}
}++++++++++++Tag: Enumeration++++++++++++
Best Time to Buy and Sell Stock II++


===============Best Time to Buy and Sell Stock III===============
151: Best Time to Buy and Sell Stock III

"Difficulty Medium Accepted Rate 26%"
         
Say you have an array for which the ith element is the price of a given stock on day i.

Example
Given an example [4,4,6,1,1,4,2,5], return 6.Note
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
Tags
Enumeration
Forward-Backward Traversal
Array
Related Problems
3
(dynamic-programming)Hard
 Best Time to Buy and Sell Stock IV
 22 %
 
2
(enumeration),(forward-backward-traversal),(array)Medium
 Best Time to Buy and Sell Stock III 
 26 %
 
2
(greedy),(enumeration),(array)Medium
 Best Time to Buy and Sell Stock II 
 49 %
 
2
(greedy),(enumeration),(array),(facebook),(uber)Medium
 Best Time to Buy and Sell Stock
 41 %
 
2
(greedy),(enumeration),(forward-backward-traversal),(lintcode-copyright),(subarray),(array)Medium
 Maximum Subarray Difference
 23 %
 
3
(lintcode-copyright),(dynamic-programming),(subarray),(array)Hard
 Maximum Subarray III
 23 %
 
2
(greedy),(enumeration),(forward-backward-traversal),(lintcode-copyright),(subarray),(array)Medium
 Maximum Subarray II
 23 %
 
1
(greedy),(enumeration),(lintcode-copyright),(linkedin),(subarray),(array)Easy
 Maximum Subarray
 37 %
public class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length <= 1) {
            return 0;
        }

        int[] left = new int[prices.length];
        int[] right = new int[prices.length];

        // DP from left to right;
        left[0] = 0;
        int min = prices[0];
        for (int i = 1; i < prices.length; i++) {
            min = Math.min(prices[i], min);
            left[i] = Math.max(left[i - 1], prices[i] - min);
        }

        //DP from right to left;
        right[prices.length - 1] = 0;
        int max = prices[prices.length - 1];
        for (int i = prices.length - 2; i >= 0; i--) {
            max = Math.max(prices[i], max);
            right[i] = Math.max(right[i + 1], max - prices[i]);
        }

        int profit = 0;
        for (int i = 0; i < prices.length; i++){
            profit = Math.max(left[i] + right[i], profit);  
        }

        return profit;
    }
}Best Time to Buy and Sell Stock++


===============Longest Common Prefix===============
78: Longest Common Prefix

"Difficulty Medium Accepted Rate 27%"
         
Given k strings, find the longest common prefix (LCP).

Example
For strings "ABCD", "ABEF" and "ACEF", the LCP is "A"
For strings "ABCDEFG", "ABCEFG" and "ABCEFA", the LCP is "ABC"

Tags
Enumeration
Basic Implementation
String
LintCode Copyright

public class Solution {
    
    // 1. Method 1, start from the first one, compare prefix with next string, until end;
    // 2. Method 2, start from the first char, compare it with all string, and then the second char
    // I am using method 1 here
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        String prefix = strs[0];
        for(int i = 1; i < strs.length; i++) {
            int j = 0;
            while( j < strs[i].length() && j < prefix.length() && strs[i].charAt(j) == prefix.charAt(j)) {
                j++;
            }
            if( j == 0) {
                return "";
	}
            prefix = prefix.substring(0, j);
        }
        return prefix;
    }

}

===============Longest Increasing Continuous Subsequence===============
397: Longest Increasing Continuous Subsequence

"Difficulty Easy Accepted Rate 27%"
         
Give an integer array，find the longest increasing continuous subsequence in this array.

Example
For [5, 4, 2, 1, 3], the LICSis [5, 4, 2, 1], return 4.
For [5, 1, 2, 3, 4], the LICSis [1, 2, 3, 4], return 4.Note
O(n) time and O(1) extra space. 
Tags
Enumeration
Dynamic Programming
Array
Related Problems
// version 1: enumeration
public class Solution {
    public int longestIncreasingContinuousSubsequence(int[] A) {
        if (A == null || A.length == 0) {
            return 0;
        }
        
        int n = A.length;
        int answer = 1;
        
        // from left to right
        int length = 1; // just A[0] itself
        for (int i = 1; i < n; i++) {
            if (A[i] > A[i - 1]) {
                length++;
            } else {
                length = 1;
            }
            answer = Math.max(answer, length);
        }
        
        // from right to left
        length = 1;
        for (int i = n - 2; i >= 0; i--) {
            if (A[i] > A[i + 1]) {
                length++;
            } else {
                length = 1;
            }
            answer = Math.max(answer, length);
        }
        
        return answer;
    }
}

// version 2: Memorization Search, can not get accepted, just show you how to write a memorization search code
public class Solution {
    private int[] flag;
    private int[] dp;
    private int[] A;
    private int n;
    
    public static int VISITED = 1;
    /**
     * @param A an array of Integer
     * @return  an integer
     */
    public int longestIncreasingContinuousSubsequence(int[] A) {
        if (A == null) {
            return 0;
        }
        
        // initialize
        n = A.length;
        flag = new int[n];
        dp = new int[n];
        this.A = A;

        // memorization search
        int ans = 0;
        for (int i = 0; i < n; i++) {
            dp[i] = dfs(i);
            ans = Math.max(ans, dp[i]);
        }
        
        return ans;
    }
    
    int dfs(int index)   {
        if (flag[index] == VISITED) {
            return dp[index];
        }
        
        int ans = 1;
        if (index - 1 >= 0 && A[index] < A[index - 1]) {
            ans = dfs(index - 1) + 1;
        } 
        if (index + 1 < n && A[index] < A[index + 1]) {
            ans = Math.max(ans,  dfs(index + 1) + 1);
        }
        flag[index] = VISITED;
        dp[index] = ans;
        return ans;
    }
}Majority Number II++
Majority Number++
Maximum Subarray Difference++
Maximum Subarray II++
Maximum Subarray++


===============Submatrix Sum===============
405: Submatrix Sum

"Difficulty Medium Accepted Rate 20%"
         
Given an integer matrix, find a submatrix where the sum of numbers is zero. Your code should return the coordinate of the left-up and right-down number.

Example
Given matrix
[
[1 ,5 ,7],
[3 ,7 ,-8],
[4 ,-8 ,9],
]return [(1,1), (2,2)]Challenge
O(n3) time.
Tags
Enumeration
Matrix
Related Problems

(subarray),(sort)Medium
 Subarray Sum Closest
 16 %
 
1
(subarray),(hash-table)Easy
 Subarray Sum
 26 %
public class Solution {
    /**
     * @param matrix an integer matrix
     * @return the coordinate of the left-up and right-down number
     */
    public int[][] submatrixSum(int[][] matrix) {
        int[][] result = new int[2][2];
        int M = matrix.length;
        if (M == 0) return result;
        int N = matrix[0].length;
        if (N == 0) return result;
        // pre-compute: sum[i][j] = sum of submatrix [(0, 0), (i, j)]
        int[][] sum = new int[M+1][N+1];
        for (int j=0; j<=N; ++j) sum[0][j] = 0;
        for (int i=1; i<=M; ++i) sum[i][0] = 0;
        for (int i=0; i<M; ++i) {
            for (int j=0; j<N; ++j)
                sum[i+1][j+1] = matrix[i][j] + sum[i+1][j] + sum[i][j+1] - sum[i][j];
        }
        for (int l=0; l<M; ++l) {
            for (int h=l+1; h<=M; ++h) {
                Map<Integer, Integer> map = new HashMap<Integer, Integer>();
                for (int j=0; j<=N; ++j) {
                    int diff = sum[h][j] - sum[l][j];
                    if (map.containsKey(diff)) {
                        int k = map.get(diff);
                        result[0][0] = l;   result[0][1] = k;
                        result[1][0] = h-1; result[1][1] = j-1;
                        return result;
                    } else {
                        map.put(diff, j);
                    }
                }
            }
        }
        return result;
    }
}++++++++++++Tag: Basic Implementation++++++++++++
Fizz Buzz++


===============Insert Interval===============
30: Insert Interval

"Difficulty Easy Accepted Rate 21%"
         
Given a non-overlapping interval list which is sorted by start point.

Example
Insert [2, 5] into [[1,2], [5,9]], we get [[1,9]].
Insert [3, 4] into [[1,2], [5,9]], we get [[1,2], [3,4], [5,9]].

Tags
Basic Implementation
LinkedIn
Google
Related Problems
1
(linkedin),(sort),(array),(google)Easy
 Merge Intervals
 19 %
public class Solution {
    public ArrayList<Interval> insert(ArrayList<Interval> intervals, Interval newInterval) {
        if (newInterval == null || intervals == null) {
            return intervals;
        }

        ArrayList<Interval> results = new ArrayList<Interval>();
        int insertPos = 0;

        for (Interval interval : intervals) {
            if (interval.end < newInterval.start) {
                results.add(interval);
                insertPos++;
            } else if (interval.start > newInterval.end) {
                results.add(interval);
            } else {
                newInterval.start = Math.min(interval.start, newInterval.start);
                newInterval.end = Math.max(interval.end, newInterval.end);
            }
        }

        results.add(insertPos, newInterval);

        return results;
    }
}Longest Common Prefix++


===============Rotate List===============
170: Rotate List

"Difficulty Medium Accepted Rate 25%"
         
Given a list, rotate the list to the right by k places, where k is non-negative.

Example
Given 1->2->3->4->5 and k = 2, return 4->5->1->2->3.

Tags
Basic Implementation
Linked List
Related Problems
3
(linked-list),(facebook)Hard
 Reverse Nodes in k-Group
 27 %
 
1
(string)Easy
 Rotate String
 21 %
public class Solution {
    private int getLength(ListNode head) {
        int length = 0;
        while (head != null) {
            length ++;
            head = head.next;
        }
        return length;
    }
    
    public ListNode rotateRight(ListNode head, int n) {
        if (head == null) {
            return null;
        }
        
        int length = getLength(head);
        n = n % length;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        head = dummy;
        
        ListNode tail = dummy;
        for (int i = 0; i < n; i++) {
            head = head.next;
        }
        
        while (head.next != null) {
            tail = tail.next;
            head = head.next;
        }
        
        head.next = dummy.next;
        dummy.next = tail.next;
        tail.next = null;
        return dummy.next;
    }
}++++++++++++Tag: String++++++++++++


===============Add Binary===============
408: Add Binary

"Difficulty Easy Accepted Rate 22%"
         
Given two binary strings, return their sum (also a binary string).

Example
a = 11
b = 1
Return 100

Tags
String
Binary
Facebook
Related Problems

(high-precision)Medium
 Divide Two Integers 
 14 %
 
1
(array),(google)Easy
 Plus One
 30 %
public class Solution {
    public String addBinary(String a, String b) {
        if(a.length() < b.length()){
            String tmp = a;
            a = b;
            b = tmp;
        }
        
        int pa = a.length()-1;
        int pb = b.length()-1;
        int carries = 0;
        String rst = "";
        
        while(pb >= 0){
            int sum = (int)(a.charAt(pa) - &#39;0&#39;) + (int)(b.charAt(pb) - &#39;0&#39;) + carries;
            rst = String.valueOf(sum % 2) + rst;
            carries = sum / 2;
            pa --;
            pb --;
        }
        
        while(pa >= 0){
            int sum = (int)(a.charAt(pa) - &#39;0&#39;) + carries;
            rst = String.valueOf(sum % 2) + rst;
            carries = sum / 2;
            pa --;
        }       
        
        if (carries == 1)
            rst = "1" + rst;
        return rst;
    }
}

===============Anagrams===============
171: Anagrams

"Difficulty Medium Accepted Rate 21%"
         
Given an array of strings, return all groups of strings that are anagrams.

Example
Given ["lint", "intl", "inlt", "code"], return ["lint", "inlt", "intl"].
Given ["ab", "ba", "cd", "dc", "e"], return ["ab", "ba", "cd", "dc"].Note
All inputs will be in lower-case
Tags
String
Hash Table
Facebook
Uber
Related Problems
1
(string),(cracking-the-coding-interview)Easy
 Two Strings Are Anagrams
 28 %
public class Solution {
    private int getHash(int[] count) {
        int hash = 0;
        int a = 378551;
        int b = 63689;
        for (int num : count) {
            hash = hash * a + num;
            a = a * b;
        }
        return hash;
    }
    
    public ArrayList<String> anagrams(String[] strs) {
        ArrayList<String> result = new ArrayList<String>();
        HashMap<Integer, ArrayList<String>> map = new HashMap<Integer, ArrayList<String>>();

        for (String str : strs) {
            int[] count = new int[26];
            for (int i = 0; i < str.length(); i++) {
                count[str.charAt(i) - &#39;a&#39;]++;
            }

            int hash = getHash(count);
            if (!map.containsKey(hash)) {
                map.put(hash, new ArrayList<String>());
            }

            map.get(hash).add(str);
        }

        for (ArrayList<String> tmp : map.values()) {
            if (tmp.size() > 1) {
                result.addAll(tmp);
            }
        }

        return result;
    }
}

===============Binary Representation===============
180: Binary Representation

"Difficulty Hard Accepted Rate 17%"
         
Given a (decimal - e.g. 3.72) number that is passed in as a string, return the binary representation that is passed in as a string. If the fractional part of the number can not be represented accurately in binary with at most 32 characters, return ERROR.

Example
For n = "3.72", return "ERROR".
For n = "3.5", return "11.1".

Tags
String
Cracking The Coding Interview
Bit Manipulation
Related Problems

(cracking-the-coding-interview),(bit-manipulation)Medium
 Update Bits
 19 %
public class Solution {
    /**
     *@param n: Given a decimal number that is passed in as a string
     *@return: A string
     */
     
    private String parseInteger(String str) {
        int n = Integer.parseInt(str);
        if (str.equals("") || str.equals("0")) {
            return "0";
        }
        String binary = "";
        while (n != 0) {
            binary = Integer.toString(n % 2) + binary;
            n = n / 2;
        }
        return binary;
    }
    
    private String parseFloat(String str) {
        double d = Double.parseDouble("0." + str);
        String binary = "";
        HashSet<Double> set = new HashSet<Double>();
        while (d > 0) {
            if (binary.length() > 32 || set.contains(d)) {
                return "ERROR";
            }
            set.add(d);
            d = d * 2;
            if (d >= 1) {
                binary = binary + "1";
                d = d - 1;
            } else {
                binary = binary + "0";
            }
        }
        return binary;
    }
    
    public String binaryRepresentation(String n) {
        if (n.indexOf(&#39;.&#39;) == -1) {
            return parseInteger(n);
        }
        String[] params = n.split("\\.");
        String flt = parseFloat(params[1]);
        if (flt == "ERROR") {
            return flt;
        }
        if (flt.equals("0") || flt.equals("")) {
            return parseInteger(params[0]);
        }
        return parseInteger(params[0]) + "." + flt;
    }
}Compare Strings++


===============Count and Say===============
420: Count and Say

"Difficulty Easy Accepted Rate 26%"
         
The count-and-say sequence is the sequence of integers beginning as follows:

Example
Given n = 5, return "111221".Note
The sequence of integers will be represented as a string.
Tags
String
Facebook
public class Solution {
    public String countAndSay(int n) {
        String oldString = "1";
        while (--n > 0) {
            StringBuilder sb = new StringBuilder();
            char [] oldChars = oldString.toCharArray();

            for (int i = 0; i < oldChars.length; i++) {
                int count = 1;
                while ((i+1) < oldChars.length && oldChars[i] == oldChars[i+1]) {
                    count++;
                    i++;
                }
                sb.append(String.valueOf(count) + String.valueOf(oldChars[i]));
            }
            oldString = sb.toString();
        }

        return oldString;
    }
}

===============Distinct Subsequences===============
118: Distinct Subsequences

"Difficulty Medium Accepted Rate 30%"
         
Given a string S and a string T, count the number of distinct subsequences of T in S.

Example
Given S = "rabbbit", T = "rabbit", return 3.Challenge
Do it in O(n2) time and O(n) memory. 
O(n2) memory is also acceptable if you do not know how to optimize memory.
Tags
String
Dynamic Programming
Related Problems

(longest-common-subsequence),(dynamic-programming)Medium
 Interleaving String
 25 %
public class Solution {
    public int numDistinct(String S, String T) {
        if (S == null || T == null) {
            return 0;
        }

        int[][] nums = new int[S.length() + 1][T.length() + 1];

        for (int i = 0; i <= S.length(); i++) {
            nums[i][0] = 1;
        }
        for (int i = 1; i <= S.length(); i++) {
            for (int j = 1; j <= T.length(); j++) {
                nums[i][j] = nums[i - 1][j];
                if (S.charAt(i - 1) == T.charAt(j - 1)) {
                    nums[i][j] += nums[i - 1][j - 1];
                }
            }
        }
        return nums[S.length()][T.length()];
    }
}

===============Edit Distance===============
119: Edit Distance

"Difficulty Medium Accepted Rate 28%"
         
Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)

Example
Given word1 = "mart" and word2 = "karma", return 3.

Tags
String
Dynamic Programming
Related Problems

(lintcode-copyright),(longest-common-subsequence),(dynamic-programming)Medium
 Longest Common Subsequence
 37 %
public class Solution {
    public int minDistance(String word1, String word2) {
        int n = word1.length();
        int m = word2.length();
        
        int[][] dp = new int[n+1][m+1];
        for(int i=0; i< m+1; i++){
            dp[0][i] = i; 
        }
        for(int i=0; i<n+1; i++){
            dp[i][0] = i;
        }
        
        
        for(int i = 1; i<n+1; i++){
            for(int j=1; j<m+1; j++){
                if(word1.charAt(i-1) == word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = 1 + Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]));
                }
            }
        }
        return dp[n][m];
    }
}

===============Generate Parentheses===============
427: Generate Parentheses

"Difficulty Medium Accepted Rate 30%"
         
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

Example
Given n = 3, a solution set is:
"((()))", "(()())", "(())()", "()(())", "()()()"

Tags
String
Backtracking
Recursion
Zenefits
Google
Related Problems
1
(stack),(google)Easy
 Valid Parentheses
 26 %
 
2
(dynamic-programming),(depth-first-search)Medium
 Unique Binary Search Trees II 
 30 %
 
2
(catalan-number),(dynamic-programming)Medium
 Unique Binary Search Trees 
 32 %
public class Solution {
    public ArrayList<String> generateParenthesis(int n) {
        ArrayList<String> result = new ArrayList<String>();
        if (n <= 0) {
            return result;
        }
        helper(result, "", n, n);
        return result;
    }
    
	public void helper(ArrayList<String> result,
	                   String paren, // current paren
	                   int left,     // how many left paren we need to add
	                   int right) {  // how many right paren we need to add
		if (left == 0 && right == 0) {
			result.add(paren);
			return;
		}

        if (left > 0) {
		    helper(result, paren + "(", left - 1, right);
        }
        
        if (right > 0 && left < right) {
		    helper(result, paren + ")", left, right - 1);
        }
	}
}

===============Integer to Roman===============
418: Integer to Roman

"Difficulty Medium Accepted Rate 39%"
         
Given an integer, convert it to a roman numeral.

Example
4 -> IV
12 -> XII
21 -> XXI
99 -> XCIX
more examples at: http://literacy.kent.edu/Minigrants/Cinci/romanchart.htmClarification
What is Roman Numeral?https://en.wikipedia.org/wiki/Roman_numerals
https://zh.wikipedia.org/wiki/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97
http://baike.baidu.com/view/42061.htm

Tags
String
Related Problems

(string),(uber)Medium
 Roman to Integer 
 39 %
public class Solution {
	public String intToRoman(int num) {
		if(num <= 0) {
			return "";
		}
	    int[] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
	    String[] symbols = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
	    StringBuilder res = new StringBuilder();
	    int digit=0;
	    while (num > 0) {
	        int times = num / nums[digit];
	        num -= nums[digit] * times;
	        for ( ; times > 0; times--) {
	            res.append(symbols[digit]);
	        }
	        digit++;
	    }
	    return res.toString();
	}
}

===============Length of Last Word===============
422: Length of Last Word

"Difficulty Easy Accepted Rate 34%"
         
Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

Example
Given s = "Hello World", return 5.Note
A word is defined as a character sequence consists of non-space characters only.
Tags
String
Related Problems
1
(enumeration),(string),(lintcode-copyright)Easy
 Longest Words
 36 %
public class Solution {
    public int lengthOfLastWord(String s) {
        int length = 0;
        char[] chars = s.toCharArray();
        for (int i = s.length() - 1; i >= 0; i--) {
            if (length == 0) {
                if (chars[i] == &#39; &#39;) {
                    continue;
                } else {
                    length++;
                }
            } else {
                if (chars[i] == &#39; &#39;) {
                    break;
                } else {
                    length++;
                }
            }
        }

        return length;
    }
}

===============Letter Combinations of a Phone Number===============
425: Letter Combinations of a Phone Number

"Difficulty Medium Accepted Rate 22%"
         
Given a digit string, return all possible letter combinations that the number could represent.

Example
Given "23"
Return ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]Note
Although the above answer is in lexicographical order, your answer could be in any order you want.
Tags
String
Backtracking
Recursion
Facebook
Uber
public class Solution {
    public ArrayList<String> letterCombinations(String digits) {
        ArrayList<String> result = new ArrayList<String>();

        if (digits == null || digits.equals("")) {
            return result;
        }

        Map<Character, char[]> map = new HashMap<Character, char[]>();
        map.put(&#39;0&#39;, new char[] {});
        map.put(&#39;1&#39;, new char[] {});
        map.put(&#39;2&#39;, new char[] { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; });
        map.put(&#39;3&#39;, new char[] { &#39;d&#39;, &#39;e&#39;, &#39;f&#39; });
        map.put(&#39;4&#39;, new char[] { &#39;g&#39;, &#39;h&#39;, &#39;i&#39; });
        map.put(&#39;5&#39;, new char[] { &#39;j&#39;, &#39;k&#39;, &#39;l&#39; });
        map.put(&#39;6&#39;, new char[] { &#39;m&#39;, &#39;n&#39;, &#39;o&#39; });
        map.put(&#39;7&#39;, new char[] { &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39; });
        map.put(&#39;8&#39;, new char[] { &#39;t&#39;, &#39;u&#39;, &#39;v&#39;});
        map.put(&#39;9&#39;, new char[] { &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39; });

        StringBuilder sb = new StringBuilder();
        helper(map, digits, sb, result);

        return result;
    }

    private void helper(Map<Character, char[]> map, String digits, 
        StringBuilder sb, ArrayList<String> result) {
        if (sb.length() == digits.length()) {
            result.add(sb.toString());
            return;
        }

        for (char c : map.get(digits.charAt(sb.length()))) {
            sb.append(c);
            helper(map, digits, sb, result);
            sb.deleteCharAt(sb.length() - 1);
        }
    }
}Longest Common Prefix++


===============Longest Palindromic Substring===============
200: Longest Palindromic Substring

"Difficulty Medium Accepted Rate 23%"
         
Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.

Example
Given the string = "abcdzdcab", return "cdzdc".Challenge
O(n2) time is acceptable. Can you do it in O(n) time.
Tags
String
Related Problems
1
(string),(two-pointers),(facebook),(zenefits),(uber)Easy
 Valid Palindrome
 21 %
 
2
(string)Medium
 Longest Palindromic Substring
 23 %
 
2
(dynamic-programming)Medium
 Palindrome Partitioning II
 21 %
public class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }
        
        int length = s.length();    
        int max = 0;
        String result = "";
        for(int i = 1; i <= 2 * length - 1; i++){
            int count = 1;
            while(i - count >= 0 && i + count <= 2 * length  && get(s, i - count) == get(s, i + count)){
                count++;
            }
            count--; // there will be one extra count for the outbound #
            if(count > max) {
                result = s.substring((i - count) / 2, (i + count) / 2);
                max = count;
            }
        }
        
        return result;
    }
    
    private char get(String s, int i) {
        if(i % 2 == 0)
            return &#39;#&#39;;
        else 
            return s.charAt(i / 2);
    }
}

===============Longest Substring Without Repeating Characters===============
384: Longest Substring Without Repeating Characters

"Difficulty Medium Accepted Rate 26%"
         
Given a string, find the length of the longest substring without repeating characters. 

Example
For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. 
For "bbbbb" the longest substring is "b", with the length of 1.Challenge
O(n) time
Tags
String
Two Pointers
Hash Table
Related Problems
public class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        
        HashSet<Character> set = new HashSet<Character>();
        
        int leftBound = 0, max = 0;
        for (int i = 0; i < s.length(); i++) {
            if (set.contains(s.charAt(i))) {
                while (leftBound < i && s.charAt(leftBound) != s.charAt(i)) {
                    set.remove(s.charAt(leftBound));
                    leftBound ++;
                }
                leftBound ++;
            } else {
                set.add(s.charAt(i));
                max = Math.max(max, i - leftBound + 1);
            }
        }
        
        return max;
    }
}

public class Solution {
    /**
     * @param s: a string
     * @return: an integer 
     */
     //方法一：
    public int lengthOfLongestSubstring(String s) {
        int[] map = new int[256]; // map from character&#39;s ASCII to its last occured index
        Arrays.fill(map, -1);
        
        int slow = 0;
        int fast = 0;
        int ans = 0;
        for (fast = 0; fast < s.length(); fast++) {
            int ch = s.charAt(fast);
            while (map[ch]!=-1 && slow < fast) {
                int temp = s.charAt(slow);
                map[temp] = -1;
                slow ++;
            }
            map[ch] = 0;
            ans = Math.max(ans, fast-slow + 1);
        }
        
        return ans;
    }
    // 方法二：
    // public int lengthOfLongestSubstring(String s) {
    //     int[] map = new int[256]; // map from character&#39;s ASCII to its last occured index
    //     int ans = 0;
    //     int slow = 0;

    //     Arrays.fill(map, -1);
        
    //     for (int fast = 0; fast < s.length(); fast++) {
    //         int ch = s.charAt(fast);
    //         if (map[ch] >= slow) {
    //             ans = Math.max(ans, fast - slow);
    //             slow = map[ch] + 1;
    //         }
    //         map[ch] = fast;
    //     }
        
    //     return Math.max(ans, s.length() - slow);
    // }

    

}Longest Words++


===============Regular Expression Matching===============
154: Regular Expression Matching

"Difficulty Hard Accepted Rate 23%"
         
Implement regular expression matching with support for '.' and '*'.

Example
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true

Tags
String
Backtracking
Dynamic Programming
Facebook
Google
Related Problems
3
(greedy),(string),(backtracking),(dynamic-programming),(google)Hard
 Wildcard Matching
 27 %
public class Solution {
    public boolean isMatch(String s, String p) {
        //Java note: s.substring(n) will be "" if n == s.length(), but if n > s.length(), index oob error
        
        int i = 0, j = 0;
        //you don&#39;t have to construct a state machine for this problem
 
        if (s.length() == 0) {
            return checkEmpty(p);
        }
 
        if (p.length() == 0) {
            return false;
        }
 
        char c1 = s.charAt(0);
        char d1 = p.charAt(0), d2 = &#39;0&#39;; //any init value except &#39;*&#39;for d2 will do
 
        if (p.length()>1){
            d2 = p.charAt(1);
        }
 
        if (d2 == &#39;*&#39;) {
            if (compare(c1, d1)) {
                //fork here: 1. consume the character, and use the same pattern again.
                //2. keep the character, and skip &#39;d1*&#39; pattern
                 
                //Here is also an opportunity to use DP, but the idea is the same
                return isMatch(s.substring(1), p) || isMatch(s, p.substring(2));
            }
            else {
                return isMatch(s, p.substring(2));
            }
        }
        else {
            if (compare(c1, d1)) {
                return isMatch(s.substring(1), p.substring(1));
            }
            else {
                return false;
            }
        }
    }
    
    public boolean compare(char c1, char d1){
        return d1 == &#39;.&#39; || c1 == d1;
    }
 
    public boolean checkEmpty(String p) {
        if (p.length()%2 != 0) {
            return false;  
        }
 
        for (int i = 1; i < p.length(); i+=2) {
            if (p.charAt(i) != &#39;*&#39;) {
                return false;
            }
        }
        return true;
    }
}

===============Restore IP Addresses===============
426: Restore IP Addresses

"Difficulty Medium Accepted Rate 19%"
         
Given a string containing only digits, restore it by returning all possible valid IP address combinations.

Example
Given "25525511135", return
[
"255.255.11.135",
"255.255.111.35"
]Order does not matter.

Tags
String
Backtracking
Recursion
Related Problems

(recursion),(facebook),(uber)Medium
 Subsets
 22 %
public class Solution {
    public ArrayList<String> restoreIpAddresses(String s) {
        ArrayList<String> result = new ArrayList<String>();
        ArrayList<String> list = new ArrayList<String>();
        
        if(s.length() <4 || s.length() > 12)
            return result;
        
        helper(result, list, s , 0);
        return result;
    }
    
    public void helper(ArrayList<String> result, ArrayList<String> list, String s, int start){
        if(list.size() == 4){
            if(start != s.length())
                return;
            
            StringBuffer sb = new StringBuffer();
            for(String tmp: list){
                sb.append(tmp);
                sb.append(".");
            }
            sb.deleteCharAt(sb.length()-1);
            result.add(sb.toString());
            return;
        }
        
        for(int i=start; i<s.length() && i<= start+3; i++){
            String tmp = s.substring(start, i+1);
            if(isvalid(tmp)){
                list.add(tmp);
                helper(result, list, s, i+1);
                list.remove(list.size()-1);
            }
        }
    }
    
    private boolean isvalid(String s){
        if(s.charAt(0) == &#39;0&#39;)
            return s.equals("0"); // to eliminate cases like "00", "10"
        int digit = Integer.valueOf(s);
        return digit >= 0 && digit <= 255;
    }
}

===============Reverse Words in a String===============
53: Reverse Words in a String

"Difficulty Easy Accepted Rate 23%"
         


Example
ClarificationWhat constitutes a word?
A sequence of non-space characters constitutes a word.
Could the input string contain leading or trailing spaces?
Yes. However, your reversed string should not contain leading or trailing spaces.
How about multiple spaces between two words?
Reduce them to a single space in the reversed string.

Tags
String
Related Problems

(linked-list)Medium
 Reverse Linked List II
 28 %
 
1
(linked-list),(facebook),(uber)Easy
 Reverse Linked List
 40 %
public class Solution {
    public String reverseWords(String s) {
        if (s == null || s.length() == 0) {
            return "";
        }

        String[] array = s.split(" ");
        StringBuilder sb = new StringBuilder();

        for (int i = array.length - 1; i >= 0; --i) {
            if (!array[i].equals("")) {
                sb.append(array[i]).append(" ");
            }
        }

        //remove the last " "
        return sb.length() == 0 ? "" : sb.substring(0, sb.length() - 1);
    }
}

===============Roman to Integer===============
419: Roman to Integer

"Difficulty Medium Accepted Rate 39%"
         
Given a roman numeral, convert it to an integer.

Example
IV -> 4
XII -> 12
XXI -> 21
XCIX -> 99Clarification
What is Roman Numeral?https://en.wikipedia.org/wiki/Roman_numerals
https://zh.wikipedia.org/wiki/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97
http://baike.baidu.com/view/42061.htm

Tags
String
Uber
Related Problems

(string)Medium
 Integer to Roman
 39 %
public class Solution {
 	public int romanToInt(String s) {
	    if (s == null || s.length()==0) {
 return 0;
	    }
	    Map<Character, Integer> m = new HashMap<Character, Integer>();
	    m.put(&#39;I&#39;, 1);
	    m.put(&#39;V&#39;, 5);
	    m.put(&#39;X&#39;, 10);
	    m.put(&#39;L&#39;, 50);
	    m.put(&#39;C&#39;, 100);
	    m.put(&#39;D&#39;, 500);
	    m.put(&#39;M&#39;, 1000);

	    int length = s.length();
	    int result = m.get(s.charAt(length - 1));
	    for (int i = length - 2; i >= 0; i--) {
	        if (m.get(s.charAt(i + 1)) <= m.get(s.charAt(i))) {
	            result += m.get(s.charAt(i));
	        } else {
	            result -= m.get(s.charAt(i));
	        }
	    }
	    return result;
	}
}

===============Rotate String===============
8: Rotate String

"Difficulty Easy Accepted Rate 21%"
         
Given a string and an offset, rotate string by offset. (rotate from left to right)

Example
Given "abcdefg".
offset=0 => "abcdefg"
offset=1 => "gabcdef"
offset=2 => "fgabcde"
offset=3 => "efgabcd"
Challenge
Rotate in-place with O(1) extra memory.
Tags
String
Related Problems

(basic-implementation),(linked-list)Medium
 Rotate List
 25 %
 
2
(cracking-the-coding-interview),(matrix)Medium
 Rotate Image 
 34 %
 
1
(sorted-array),(array)Easy
 Recover Rotated Sorted Array
 26 %
public class Solution {
    /*
     * param A: A string
     * param offset: Rotate string with offset.
     * return: Rotated string.
     */
    public char[] rotateString(char[] A, int offset) {
        if (A == null || A.length == 0) {
            return A;
        }
        
        offset = offset % A.length;
        reverse(A, 0, A.length - offset - 1);
        reverse(A, A.length - offset, A.length - 1);
        reverse(A, 0, A.length - 1);
        return A;
    }
    
    private void reverse(char[] A, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            char temp = A[i];
            A[i] = A[j];
            A[j] = temp;
        }
    }
};

===============Scramble String===============
430: Scramble String

"Difficulty Hard Accepted Rate 29%"
         
Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

Example
Challenge
O(n3) time
Tags
String
Dynamic Programming
public class Solution {
    /*
       Second method: comes up with DP naturally
       f[n][i][j] means isScramble(s1[i: i+n], s2[j: j+n])
       f[n][i][j] = f[k][i][j] && f[n - k][i+k][j+k]
                   || f[k][i][j+n-k] && f[n-k][i+k][j]
  
   */
    
     public boolean isScramble(String s1, String s2) {
        if( s1.length() != s2.length() ){
            return false;
        }
        
        if( s1.length() == 0 || s1.equals(s2)) {
            return true;
        }
        
        int n = s1.length();
        boolean[][][] rst = new boolean[n][n][n];
        for(int i=0; i< n; i++){
            for(int j=0;j<n; j++){
                rst[0][i][j] = s1.charAt(i) == s2.charAt(j);
            }
        }
        
        for(int len = 2; len <= n; len++){
            for(int i = n - len; i>= 0; i--) {
                for(int j = n - len;  j>=0; j--){
                    boolean r = false;
                    for(int k = 1; k < len && r == false; k++){
                        r = (rst[k-1][i][j] && rst[len-k-1][i+k][j+k]) || (rst[k-1][i][j+len-k] && rst[len-k-1][i+k][j]);
                    }
                    rst[len-1][i][j] = r;
                }
            }
        }
        
        return rst[n-1][0][0];
     }
 }
    
 
public class Solution {
    /**
     * @param s1 A string
     * @param s2 Another string
     * @return whether s2 is a scrambled string of s1
     */
    public boolean isScramble(String s1, String s2) {
        // Write your code here
        if (s1.length() != s2.length()) {
            return false;
        }
        
        if (s1.length() == 0 || s1.equals(s2)) {
            return true;
        }
        
        if (!isValid(s1, s2)) {
            return false;
        }// Base Cases
        
        
        for (int i = 1; i < s1.length(); i++) {
            String s11 = s1.substring(0, i);
            String s12 = s1.substring(i, s1.length());
            String s21 = s2.substring(0, i);
            String s22 = s2.substring(i, s2.length());
            String s23 = s2.substring(0, s2.length() - i);
            String s24 = s2.substring(s2.length() - i, s2.length());
            
            if (isScramble(s11, s21) && isScramble(s12, s22)) return true;
            if (isScramble(s11, s24) && isScramble(s12, s23)) return true;// cut 
            
        }
        return false;
    }
    
    
    private boolean isValid(String s1, String s2) {
        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        if (!(new String(arr1)).equals(new String(arr2))) {
            return false;
        }
        return true;
    }
}


public class Solution {
    /**
     * @param s1 A string
     * @param s2 Another string
     * @return whether s2 is a scrambled string of s1
     */
     
     private boolean checkScramble(String s1,int start1, String s2, int start2, int k, int [][][]visit) {
		if(visit[start1][start2][k] == 1)
            return true;
        if(visit[start1][start2][k] ==-1)
            return false;
        
        
        if (s1.length() != s2.length()) {
            visit[start1][start2][k] = -1;
            return false;
        }
        
        if (s1.length() == 0 || s1.equals(s2)) {
            visit[start1][start2][k] = 1;
            return true;
        }
        
        if (!isValid(s1, s2)) {
            visit[start1][start2][k] = -1;
            return false;
        }// Base Cases
        
        
        for (int i = 1; i < s1.length(); i++) {
            String s11 = s1.substring(0, i);
            String s12 = s1.substring(i, s1.length());
            
            String s21 = s2.substring(0, i);
            String s22 = s2.substring(i, s2.length());
            
            String s23 = s2.substring(0, s2.length() - i);
            String s24 = s2.substring(s2.length() - i, s2.length());
            
            if (checkScramble(s11,start1, s21, start2, i, visit) && checkScramble(s12, start1+i, s22, start2+i,k-i, visit))  {
                visit[start1][start2][k] = 1;
                return true;
            }
            
            if (checkScramble(s11,start1, s24, start2+k-i, i, visit) && checkScramble(s12,start1+i, s23,start2, k-i, visit))
            {
                visit[start1][start2][k] = 1;
                return true;
            }
        }
        visit[start1][start2][k] = -1;
        return false;
    }
    public boolean isScramble(String s1, String s2) {
        int len = s1.length();
        int [][][] visit = new int[len][len][len + 1];
        return checkScramble(s1,0,s2,0, len, visit);
    }
    
    
    private boolean isValid(String s1, String s2) {
        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        if (!(new String(arr1)).equals(new String(arr2))) {
            return false;
        }
        return true;
    }
}

===============Simplify Path===============
421: Simplify Path

"Difficulty Medium Accepted Rate 21%"
         
Given an absolute path for a file (Unix-style), simplify it.

Example
"/home/", => "/home"
"/a/./b/../../c/", => "/c"Challenge
Did you consider the case where path = "/../"?
In this case, you should return "/".
Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".
In this case, you should ignore redundant slashes and return "/home/foo".
Tags
String
Stack
public class Solution {
    public String simplifyPath(String path) {
        String result = "/";
        String[] stubs = path.split("/+");
        ArrayList<String> paths = new ArrayList<String>();
        for (String s : stubs){
            if(s.equals("..")){
                if(paths.size() > 0){
                    paths.remove(paths.size() - 1);
                }
            }
            else if (!s.equals(".") && !s.equals("")){
                paths.add(s);
            }
        }
        for (String s : paths){
            result += s + "/";
        }
        if (result.length() > 1)
            result = result.substring(0, result.length() - 1);
        return result;
    }
}

===============Sort Letters by Case===============
49: Sort Letters by Case

"Difficulty Medium Accepted Rate 37%"
         
Given a string which contains only letters. Sort it by lower case first and upper case second.

Example
For "abAcD", a reasonable answer is "acbAD"Note
It's NOT necessary to keep the original order of lower-case letters and upper case letters.
Challenge
Do it in one-pass and in-place.
Tags
String
Two Pointers
LintCode Copyright
Sort
public class Solution {
    /** 
     *@param chars: The letter array you should sort by Case
     *@return: void
     */
    public void sortLetters(char[] chars) {
        int i = 0, j = chars.length - 1;
		char tmp ;
		while ( i <= j) {
			while (i <= j && Character.isLowerCase(chars[i]) ) i++;
			while (i <= j && Character.isUpperCase(chars[j]) ) j--;
			if (i <= j) {
				tmp = chars[i];
				chars[i] = chars[j];
				chars[j] = tmp;
				i++; j--;
			}
		}
        //write your code here
		return ;
    }
}

===============Space Replacement===============
212: Space Replacement

"Difficulty Easy Accepted Rate 16%"
         
Write a method to replace all spaces in a string with %20. The string is given in a characters array, you can assume it has enough space for replacement and you are given the true length of the string.

Example
Given "Mr John Smith", length = 13.
The string after replacement should be "Mr%20John%20Smith".Note
If you are using Java or Python，please use characters array instead of string.
Challenge
Do it in-place.
Tags
String
Cracking The Coding Interview
Related Problems
1
(sorted-array),(array),(facebook)Easy
 Merge Sorted Array
 32 %
class Solution {
public:
    int replaceBlank(char string[], int length) {
        if(0==length) return 0;
        int num = 0;
        for(int i=0;i<length;i++){
            if(string[i] == &#39; &#39;) num++;
        }
        
        int newLen = length + num*2;
        string[newLen] = 0;
        int j = 1;
        for(int i=length-1;i>=0;i--){
            if(string[i] != &#39; &#39;){
                string[newLen - j] = string[i];
                j++;
            }
            else{
                string[newLen - j] = &#39;0&#39;;
                j++;
                string[newLen - j] = &#39;2&#39;;
                j++;
                string[newLen - j] = &#39;%&#39;;
                j++; 
            }
        }
        return newLen;
    }
};String to Integer II++
strStr++


===============Two Strings Are Anagrams===============
158: Two Strings Are Anagrams

"Difficulty Easy Accepted Rate 28%"
         
Write a method anagram(s,t) to decide if two strings are anagrams or not.

Example
Given s="abcd", t="dcab", return true.Challenge
O(n) time, O(1) extra space
Tags
String
Cracking The Coding Interview
Related Problems

(string),(hash-table),(facebook),(uber)Medium
 Anagrams
 21 %
 
1
(basic-implementation),(string),(lintcode-copyright)Easy
 Compare Strings
 26 %
public class Solution {
    /**
     * @param s: The first string
     * @param b: The second string
     * @return true or false
     */
    public boolean anagram(String s, String t) {
        if (s.length() != t.length()) {
           return false;
        }
        
        int[] count = new int[256];
        for (int i = 0; i < s.length(); i++) {
            count[(int) s.charAt(i)]++;
        }
        for (int i = 0; i < t.length(); i++) {
            count[(int) t.charAt(i)]--;
            if (count[(int) t.charAt(i)] < 0) {
                return false;
            }
        }
        return true;
    }
};

===============Valid Number===============
417: Valid Number

"Difficulty Hard Accepted Rate 27%"
         
Validate if a given string is numeric.

Example
"0" => true
" 0.1 " => true
"abc" => false
"1 a" => false
"2e10" => true

Tags
String
LinkedIn
// Non-regex version

public class Solution {
    public boolean isNumber(String s) {
        int len = s.length();
        int i = 0, e = len - 1;
        while (i <= e && Character.isWhitespace(s.charAt(i))) i++;
        if (i > len - 1) return false;
        while (e >= i && Character.isWhitespace(s.charAt(e))) e--;
        // skip leading +/-
        if (s.charAt(i) == &#39;+&#39; || s.charAt(i) == &#39;-&#39;) i++;
        boolean num = false; // is a digit
        boolean dot = false; // is a &#39;.&#39;
        boolean exp = false; // is a &#39;e&#39;
        while (i <= e) {
            char c = s.charAt(i);
            if (Character.isDigit(c)) {
                num = true;
            }
            else if (c == &#39;.&#39;) {
                if(exp || dot) return false;
                dot = true;
            }
            else if (c == &#39;e&#39;) {
                if(exp || num == false) return false;
                exp = true;
                num = false;
            }
            else if (c == &#39;+&#39; || c == &#39;-&#39;) {
                if (s.charAt(i - 1) != &#39;e&#39;) return false;
            }
            else {
                return false;
            }
            i++;
        }
        return num;
    }
}

===============Valid Palindrome===============
415: Valid Palindrome

"Difficulty Easy Accepted Rate 21%"
         
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

Example
"A man, a plan, a canal: Panama" is a palindrome.
"race a car" is not a palindrome.Note
Have you consider that the string might be empty? This is a good question to ask during an interview.
For the purpose of this problem, we define empty string as valid palindrome.
Challenge
O(n) time without extra memory.
Tags
String
Two Pointers
Facebook
Zenefits
Uber
Related Problems

(linked-list)Medium
 Palindrome Linked List
 26 %
 
2
(string)Medium
 Longest Palindromic Substring
 23 %
public class Solution {
    public boolean isPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return true;
        }

        int front = 0;
        int end = s.length() - 1;
        while (front < end) {
            while (front < s.length() && !isvalid(s.charAt(front))){ // nead to check range of a/b
                front++;
            }

            if (front == s.length()) { // for emtpy string “.,,,”     
                return true; 
            }           

            while (end >= 0 && ! isvalid(s.charAt(end))) { // same here, need to check border of a,b
                end--;
            }

            if (Character.toLowerCase(s.charAt(front)) != Character.toLowerCase(s.charAt(end))) {
                break;
            } else {
                front++;
                end--;
            }
        }

        return end <= front; 
    }

    private boolean isvalid (char c) {
        return Character.isLetter(c) || Character.isDigit(c);
    }
}Wildcard Matching++


===============Word Break===============
107: Word Break

"Difficulty Medium Accepted Rate 12%"
         
Given a string s and a dictionary of words dict, determine if s can be break into a space-separated sequence of one or more dictionary words.

Example
Given s = "lintcode", dict = ["lint", "code"].
Return true because "lintcode" can be break as "lint code".

Tags
String
Dynamic Programming
public class Solution {
    private int getMaxLength(Set<String> dict) {
        int maxLength = 0;
        for (String word : dict) {
            maxLength = Math.max(maxLength, word.length());
        }
        return maxLength;
    }

    public boolean wordBreak(String s, Set<String> dict) {
        if (s == null || s.length() == 0) {
            return true;
        }

        int maxLength = getMaxLength(dict);
        boolean[] canSegment = new boolean[s.length() + 1];

        canSegment[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            canSegment[i] = false;
            for (int lastWordLength = 1;
                     lastWordLength <= maxLength && lastWordLength <= i;
                     lastWordLength++) {
                if (!canSegment[i - lastWordLength]) {
                    continue;
                }
                String word = s.substring(i - lastWordLength, i);
                if (dict.contains(word)) {
                    canSegment[i] = true;
                    break;
                }
            }
        }

        return canSegment[s.length()];
    }
}++++++++++++Tag: Two Pointers++++++++++++


===============3Sum Closest===============
59: 3Sum Closest

"Difficulty Medium Accepted Rate 29%"
         
Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. 

Example
For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).Note
You may assume that each input would have exactly one solution.
Challenge
O(n^2) time, O(1) extra space
Tags
Two Pointers
Sort
Array
Related Problems

(two-pointers),(sort),(array),(facebook)Medium
 3Sum
 18 %
 
2
(two-pointers),(sort),(hash-table),(array),(airbnb),(facebook)Medium
 Two Sum
 27 %
public class Solution {
	public int threeSumClosest(int[] num, int target) {
		// Note: The Solution object is instantiated only once and is reused by
		// each test case.
		if (num == null || num.length < 3) {
			return Integer.MAX_VALUE;
		}
		Arrays.sort(num);
		int closet = Integer.MAX_VALUE / 2; // otherwise it will overflow for opeartion (closet-target)&#39;
		for (int i = 0; i < num.length - 2; i++) {
			int left = i + 1;
			int right = num.length - 1;
			while (left < right) {
				int sum = num[i] + num[left] + num[right];
				if (sum == target) {
					return sum;
				} else if (sum < target) {
					left++;
				} else {
					right--;
				}
				closet = Math.abs(sum - target) < Math.abs(closet - target) ? sum : closet;
			}
		}
		return closet;
	}
}

===============3Sum===============
57: 3Sum

"Difficulty Medium Accepted Rate 18%"
         
Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Example
For example, given array S = {-1 0 1 2 -1 -4}, A solution set is:
(-1, 0, 1)
(-1, -1, 2)
Note
Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)
The solution set must not contain duplicate triplets.
Tags
Two Pointers
Sort
Array
Facebook
Related Problems

(two-pointers),(sort),(array)Medium
 3Sum Closest
 29 %
 
2
(two-pointers),(sort),(hash-table),(array)Medium
 4Sum
 18 %
 
2
(two-pointers),(sort),(hash-table),(array),(airbnb),(facebook)Medium
 Two Sum
 27 %

public class Solution {

	public ArrayList<ArrayList<Integer>> threeSum(int[] num) {
		
		ArrayList<ArrayList<Integer>> rst = new ArrayList<ArrayList<Integer>>();
		if(num == null || num.length < 3) {
			return rst;
		}
		Arrays.sort(num);
		for (int i = 0; i < num.length - 2; i++) {
			if (i != 0 && num[i] == num[i - 1]) {
				continue; // to skip duplicate numbers; e.g [0,0,0,0]
			}

			int left = i + 1;
			int right = num.length - 1;
			while (left < right) {
				int sum = num[left] + num[right] + num[i];
				if (sum == 0) {
					ArrayList<Integer> tmp = new ArrayList<Integer>();
					tmp.add(num[i]);
					tmp.add(num[left]);
					tmp.add(num[right]);
					rst.add(tmp);
					left++;
					right--;
					while (left < right && num[left] == num[left - 1]) { // to skip duplicates
						left++;
					}
					while (left < right && num[right] == num[right + 1]) { // to skip duplicates
						right--;
					}
				} else if (sum < 0) {
					left++;
				} else {
					right--;
				}
			}
		}
		return rst;
	}
}

===============4Sum===============
58: 4Sum

"Difficulty Medium Accepted Rate 18%"
         
Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target?

Example
Given array S = {1 0 -1 0 -2 2}, and target = 0. A solution set is:
(-1, 0, 0, 1)
(-2, -1, 1, 2)
(-2, 0, 0, 2)
Note
Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a≤ b ≤ c ≤ d)
The solution set must not contain duplicate quadruplets.
Tags
Two Pointers
Sort
Hash Table
Array
Related Problems

(two-pointers),(sort),(array),(facebook)Medium
 3Sum
 18 %
 
2
(two-pointers),(sort),(hash-table),(array),(airbnb),(facebook)Medium
 Two Sum
 27 %
public class Solution {
	public ArrayList<ArrayList<Integer>> fourSum(int[] num, int target) {
		ArrayList<ArrayList<Integer>> rst = new ArrayList<ArrayList<Integer>>();
		Arrays.sort(num);

		for (int i = 0; i < num.length - 3; i++) {
			if (i != 0 && num[i] == num[i - 1]) {
				continue;
			}

			for (int j = i + 1; j < num.length - 2; j++) {
				if (j != i + 1 && num[j] == num[j - 1])
					continue;

				int left = j + 1;
				int right = num.length - 1;
				while (left < right) {
					int sum = num[i] + num[j] + num[left] + num[right];
					if (sum < target) {
						left++;
					} else if (sum > target) {
						right--;
					} else {
						ArrayList<Integer> tmp = new ArrayList<Integer>();
						tmp.add(num[i]);
						tmp.add(num[j]);
						tmp.add(num[left]);
						tmp.add(num[right]);
						rst.add(tmp);
						left++;
						right--;
						while (left < right && num[left] == num[left - 1]) {
							left++;
						}
						while (left < right && num[right] == num[right + 1]) {
							right--;
						}
					}
				}
			}
		}

		return rst;
	}
}

===============Container With Most Water===============
383: Container With Most Water

"Difficulty Medium Accepted Rate 38%"
         
Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Example
Given [1,3,2], the max area of the container is 2.Note
You may not slant the container.
Tags
Two Pointers
Array
Related Problems

(two-pointers),(forward-backward-traversal),(array)Medium
 Trapping Rain Water
 33 %
public class Solution {
    /**
     * @param heights: an array of integers
     * @return: an integer
     */
    int computeArea(int left, int right,  int[] heights) {
        return (right-left)*Math.min(heights[left], heights[right]);
    }
    
    public int maxArea(int[] heights) {
        // write your code here
        int left = 0, ans=  0 ; 
        int right = heights.length - 1;
        while(left <= right) {
            ans = Math.max(ans,computeArea(left, right, heights));
            if(heights[left]<=heights[right])
                left++;
            else
                right--;
        }
        return ans;
    }
}

--------------------------------------


public class Solution {
    // for any i, the maxium area will be the farthest j that has a[j] > a[i];
    public int maxArea(int[] height) {
        if(height == null || height.length < 2) {
            return 0;
        }
        int max = 0;
        int left = 0;
        int right = height.length -1;
        while(left < right) {
            max = Math.max( max, (right - left) * Math.min(height[left], height[right]));
            if(height[left] < height[right]){
                left++;
            } else {
                right--;
            }
        }
        return max;
        
    }
}

===============Linked List Cycle II===============
103: Linked List Cycle II

"Difficulty Hard Accepted Rate 36%"
         
Given a linked list, return the node where the cycle begins. 

Example
Given -21->10->4->5, tail connects to node index 1，return 10Challenge
Follow up:
Can you solve it without using extra space?
Tags
Two Pointers
Linked List
Related Problems

(linked-list)Medium
 Intersection of Two Linked Lists
 37 %
/**
 * Definition for ListNode.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int val) {
 *         this.val = val;
 *         this.next = null;
 *     }
 * }
 */ 
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next==null) {
            return null;
        }

        ListNode fast, slow;
        fast = head.next;
        slow = head;
        while (fast != slow) {
            if(fast==null || fast.next==null)
                return null;
            fast = fast.next.next;
            slow = slow.next;
        } 
        
        while (head != slow.next) {
            head = head.next;
            slow = slow.next;
        }
        return head;
    }
}

===============Linked List Cycle===============
102: Linked List Cycle

"Difficulty Medium Accepted Rate 46%"
         
Given -21->10->4->5, tail connects to node index 1, return true

Example
Given -21->10->4->5, tail connects to node index 1, return trueChallenge
Follow up:Can you solve it without using extra space?
Tags
Two Pointers
Linked List
Related Problems

(linked-list)Medium
 Intersection of Two Linked Lists
 37 %
public class Solution {
    public Boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }

        ListNode fast, slow;
        fast = head.next;
        slow = head;
        while (fast != slow) {
            if(fast==null || fast.next==null)
                return false;
            fast = fast.next.next;
            slow = slow.next;
        } 
        return true;
    }
}Longest Substring Without Repeating Characters++


===============Minimum Size Subarray Sum===============
406: Minimum Size Subarray Sum

"Difficulty Medium Accepted Rate 24%"
         
Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn't one, return -1 instead.

Example
Given the array [2,3,1,2,4,3] and s = 7, the subarray [4,3] has the minimal length under the problem constraint.Challenge
If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).
Tags
Two Pointers
Array
Facebook
Related Problems

(subarray),(sort)Medium
 Subarray Sum Closest
 16 %
 
1
(subarray),(hash-table)Easy
 Subarray Sum
 26 %
public class Solution {
    /**
     * @param nums: an array of integers
     * @param s: an integer
     * @return: an integer representing the minimum size of subarray
     */
    public int minimumSize(int[] nums, int s) {
        // write your code here
        int j = 0, i = 0;
        int sum =0;
        int ans = Integer.MAX_VALUE;
        for(i = 0; i < nums.length; i++) {
            while(j < nums.length && sum < s ) {
                sum += nums[j];
                j ++;
            }
            if(sum >=s)
                ans = Math.min(ans, j - i  );
            sum -= nums[i];
        }
        if(ans == Integer.MAX_VALUE)
            ans = -1;
        return ans;
    }
}

===============Partition Array===============
31: Partition Array

"Difficulty Medium Accepted Rate 26%"
         
Given an array nums of integers and an int k, partition the array (i.e move the elements in "nums") such that:

Example
If nums = [3,2,2,1] and k=2, a valid answer is 1.Note
You should do really partition in array nums instead of just counting the numbers of integers smaller than k.
If all elements in nums are smaller than k, then return nums.length
Challenge
Can you partition the array in-place and in O(n)?
Tags
Two Pointers
Sort
Array
Related Problems
1
(two-pointers),(array)Easy
 Partition Array by Odd and Even
 37 %
 
2
(two-pointers)Medium
 Interleaving Positive and Negative Numbers
 20 %
 
1
(two-pointers),(linked-list)Easy
 Partition List
 28 %
class Solution {
public:
    int partitionArray(vector<int> &nums, int k) {
        int i = 0, j = nums.size() - 1;
        while (i <= j) {
            while (i <= j && nums[i] < k) i++;
            while (i <= j && nums[j] >= k) j--;
            if (i <= j) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
                j--;
            }
        }
        return i;
    }
};

===============Partition List===============
96: Partition List

"Difficulty Easy Accepted Rate 28%"
         


Example
Tags
Two Pointers
Linked List
Related Problems

(two-pointers),(sort),(array)Medium
 Partition Array
 26 %
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode partition(ListNode head, int x) {
        if (head == null) {
            return null;
        }
        
        ListNode leftDummy = new ListNode(0);
        ListNode rightDummy = new ListNode(0);
        ListNode left = leftDummy, right = rightDummy;
        
        while (head != null) {
            if (head.val < x) {
                left.next = head;
                left = head;
            } else {
                right.next = head;
                right = head;
            }
            head = head.next;
        }
        
        right.next = null;
        left.next = rightDummy.next;
        return leftDummy.next;
    }
}

===============Remove Duplicates from Sorted Array II===============
101: Remove Duplicates from Sorted Array II

"Difficulty Easy Accepted Rate 30%"
         


Example
Tags
Two Pointers
Array
Facebook
Related Problems
1
(two-pointers),(array)Easy
 Remove Element
 31 %
 
1
(two-pointers),(array),(facebook)Easy
 Remove Duplicates from Sorted Array
 31 %
public class Solution {
    /**
     * @param A: a array of integers
     * @return : return an integer
     */
    public int removeDuplicates(int[] nums) {
        // write your code here
        if(nums == null)
            return 0;
        int cur = 0;
        int i ,j;
        for(i = 0; i < nums.length;){
            int now = nums[i];
            for( j = i; j < nums.length; j++){
                if(nums[j] != now)
                    break;
                if(j-i < 2)
                    nums[cur++] = now; 
            }
            i = j;
        }
        return cur;
    }
}

===============Remove Duplicates from Sorted Array===============
100: Remove Duplicates from Sorted Array

"Difficulty Easy Accepted Rate 31%"
         
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

Example
Given input array A = [1,1,2],
Your function should return length = 2, and A is now [1,2].

Tags
Two Pointers
Array
Facebook
Related Problems
1
(two-pointers),(array)Easy
 Remove Element
 31 %
 
1
(two-pointers),(array),(facebook)Easy
 Remove Duplicates from Sorted Array II
 30 %
public class Solution {
    public int removeDuplicates(int[] A) {
        if (A == null || A.length == 0) {
            return 0;
        }
        
        int size = 0;
        for (int i = 0; i < A.length; i++) {
            if (A[i] != A[size]) {
                A[++size] = A[i];
            }
        }
        return size + 1;
    }
}

===============Remove Element===============
172: Remove Element

"Difficulty Easy Accepted Rate 31%"
         
Given an array and a value, remove all occurrences of that value in place and return the new length.

Example
Given an array [0,4,4,0,0,2,4,4], value=4
return 4 and front four elements of the array is [0,0,0,2]

Tags
Two Pointers
Array
Related Problems
1
(two-pointers),(array),(facebook)Easy
 Remove Duplicates from Sorted Array II
 30 %
 
1
(two-pointers),(array),(facebook)Easy
 Remove Duplicates from Sorted Array
 31 %
public class Solution {
    public int removeElement(int[] A, int elem) {
        int i = 0;
        int pointer = A.length - 1;
        while(i <= pointer){
            if(A[i] == elem){
                A[i] = A[pointer];
                pointer--;
            } else {
                i++;
            }
        }
        return pointer + 1;
    }
}

===============Remove Nth Node From End of List===============
174: Remove Nth Node From End of List

"Difficulty Easy Accepted Rate 28%"
         
Given a linked list, remove the nth node from the end of list and return its head.

Example
Given linked list: 1->2->3->4->5->null, and n = 2.After removing the second node from the end, the linked list becomes 1->2->3->5->null.Note
The minimum number of nodes in list is n.
Challenge
O(n) time
Tags
Two Pointers
Linked List
Related Problems
1
(cracking-the-coding-interview),(linked-list)Easy
 Delete Node in the Middle of Singly Linked List
 37 %
public class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if (n <= 0) {
            return null;
        }
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        
        ListNode preDelete = dummy;
        for (int i = 0; i < n; i++) {
            if (head == null) {
                return null;
            }
            head = head.next;
        }
        while (head != null) {
            head = head.next;
            preDelete = preDelete.next;
        }
        preDelete.next = preDelete.next.next;
        return dummy.next;
    }
}

===============Sort Colors II===============
143: Sort Colors II

"Difficulty Medium Accepted Rate 32%"
         
Given an array of n objects with k different colors (numbered from 1 to k), sort them so that objects of the same color are adjacent, with the colors in the order 1, 2, ... k.

Example
Given colors=[3, 2, 2, 1, 4], k=4, your code should sort colors in-place to [1, 2, 2, 3, 4].Note
You are not suppose to use the library's sort function for this problem.
Challenge
A rather straight forward solution is a two-pass algorithm using counting sort. That will cost O(k) extra memory. Can you do it without using extra memory?
Tags
Two Pointers
Sort
Related Problems

(two-pointers),(sort),(array),(facebook)Medium
 Sort Colors
 32 %
    public void sortColors2(int[] colors, int k) {
        int count = 0;
        int start = 0;
        int end = colors.length-1;
        while (count < k) {
            int min = Integer.MAX_VALUE;
            int max = Integer.MIN_VALUE;
            
            for (int i = start; i < end; i++) {
                min = Math.min(min, colors[i]);
                max = Math.max(max, colors[i]);
            }
            int left = start;
            int right = end;
            int cur = left;
            while(cur <= right) {
                if (colors[cur] == min) {
                    swap(left, cur, colors);
                    cur++;
                    left++;
                } else if (colors[cur] > min && colors[cur] < max) {
                    cur++;
                } else {
                    int tmp = colors[cur];
                    swap(cur, right, colors);
                    right--;
                }
            }
            count += 2;
            start = left;
            end = right;
        }
    }
    
    void swap(int left, int right, int[] colors) {
        int tmp = colors[left];
        colors[left] = colors[right];
        colors[right] = tmp;
    }

===============Sort Colors===============
148: Sort Colors

"Difficulty Medium Accepted Rate 32%"
         
Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Example
Given [1, 0, 1, 2], return [0, 1, 1, 2].Note
You are not suppose to use the library's sort function for this problem. 
Challenge
A rather straight forward solution is a two-pass algorithm using counting sort.
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.
Could you come up with an one-pass algorithm using only constant space?
Tags
Two Pointers
Sort
Array
Facebook
Related Problems

(two-pointers),(sort)Medium
 Sort Colors II
 32 %
 
1
(sorted-array),(array)Easy
 Recover Rotated Sorted Array
 26 %
public class Solution {
    public void sortColors(int[] a) {
        if(a == null || a.length <= 1)
            return;
        
        int pl = 0;
        int pr = a.length - 1;
        int i = 0;
        while(i <= pr){
            if(a[i] == 0){
                swap(a, pl, i);
                pl++;
                i++;
            }else if(a[i] == 1){
                i++;
            }else{
                swap(a, pr, i);
                pr--;
            }
        }
    }
    
    private void swap(int[] a, int i, int j){
        int tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }
}Sort Letters by Case++


===============The Smallest Difference===============
387: The Smallest Difference

"Difficulty Medium Accepted Rate 36%"
         
Given two array of integers(the first array is array A, the second array is array B), now we are going to find a element in array A which is A[i], and another element in array B which is B[j], so that the difference between A[i] and B[j] (|A[i] - B[j]|) is as small as possible, return their smallest difference. 

Example
For example, given array A = [3,6,7,4], B = [2,8,9,3],return 0Challenge
O(n log n) time
Tags
Two Pointers
LintCode Copyright
Sort
Array
public class Solution {
    /**
     * @param A, B: Two integer arrays.
     * @return: Their smallest difference.
     */
    public int smallestDifference(int[] A, int[] B) {
        // write your code here
        Arrays.sort(A);
        Arrays.sort(B);
        
        int idA = 0, idB = 0; 
        int ans = Integer.MAX_VALUE;
        for(idA = 0; idA < A.length && idB < B.length; idA++) {
            while(idB + 1 < B.length) {
                if(B[idB + 1] > A[idA]) {
                    break;
                }
                idB++;
            }
            if(idB < B.length) {
                ans = Math.min(ans, Math.abs(B[idB]- A[idA]));
            }
            if(idB + 1 < B.length) {
                ans = Math.min(ans, Math.abs(B[idB + 1]- A[idA]));
            }
        }
        
        return ans;
    }
}

===============Trapping Rain Water===============
363: Trapping Rain Water

"Difficulty Medium Accepted Rate 33%"
         
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

Example
Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.Challenge
O(n) time and O(1) memory
O(n) time and O(n) memory is also acceptable.
Tags
Two Pointers
Forward-Backward Traversal
Array
Related Problems

(two-pointers),(array)Medium
 Container With Most Water
 38 %
public class Solution {
    /**
     * @param heights: an array of integers
     * @return: a integer
     */
    public int trapRainWater(int[] heights) {
        if (heights.length == 0) {
            return 0;
        }
        
        int[] maxHeights = new int[heights.length + 1];
        maxHeights[0] = 0;
        for (int i = 0; i < heights.length; i++) {
            maxHeights[i + 1] = Math.max(maxHeights[i], heights[i]);
        }
        
        int max = 0, area = 0;
        for (int i = heights.length - 1; i >= 0; i--) {
            area += Math.min(max, maxHeights[i]) > heights[i]
                    ? Math.min(max, maxHeights[i]) - heights[i]
                    : 0;
            max = Math.max(max, heights[i]);
        }
        
        return area;
    }
}


Version2:
public class Solution {
    public int trap(int[] A) {
        int sum = 0;
        int max = -1;
        int maxIndex = -1;
        int prev;

        // find the highest bar
        for (int i = 0; i < A.length; i++) {
            if (max < A[i]) {
                max = A[i];
                maxIndex = i;
            }
        }

        // process all bars left to the highest bar
        prev = 0;
        for (int i = 0; i < maxIndex; i++) {
            if (A[i] > prev) {
                sum += (A[i] - prev) * (maxIndex - i);
                prev = A[i];
            }
            sum -= A[i];
        }

        // process all bars right to the highest bar
        prev = 0;
        for (int i = A.length - 1; i > maxIndex; i--) {
            if (A[i] > prev) {
                sum += (A[i] - prev) * (i - maxIndex);
                prev = A[i];
            }
            sum -= A[i];
        }

        return sum;
    }
}

===============Two Sum===============
56: Two Sum

"Difficulty Medium Accepted Rate 27%"
         
Given an array of integers, find two numbers such that they add up to a specific target number.

Example
numbers=[2, 7, 11, 15], target=9
return [1, 2]Note
You may assume that each input would have exactly one solution
Challenge
Either of the following solutions are acceptable:O(n) Space, O(nlogn) Time
O(n) Space, O(n) Time

Tags
Two Pointers
Sort
Hash Table
Array
Airbnb
Facebook
Related Problems

(two-pointers),(sort),(array)Medium
 3Sum Closest
 29 %
 
2
(two-pointers),(sort),(hash-table),(array)Medium
 4Sum
 18 %
 
2
(two-pointers),(sort),(array),(facebook)Medium
 3Sum
 18 %
public class Solution {
	    public int[] twoSum_hashmap(int[] numbers, int target) {
	    	if(numbers == null || numbers.length < 2) {
	    		return null;
	    	}
	        HashMap<Integer, Integer> hs = new HashMap<Integer, Integer>();
	        for(int i=0; i<numbers.length; i++){
	            hs.put(numbers[i], i+1);
	        }       
	        
	        int[] a = new int[2];
	        
	        for(int i=0; i<numbers.length ; i++){
	            if ( hs.containsKey( target - numbers[i] )){
	                int index1 = i+1;
	                int index2 = hs.get(target - numbers[i]);
	                if (index1 == index2){
	                    continue;
	                }
	                a[0] = index1;
	                a[1] = index2;
	                return a;
	            }
	        }
	        return a;
	    }
// Can’t use the sort method here, since the question asks for indexes.
    public int[] twoSum_pointer(int[] numbers, int target) {
	    	if(numbers == null || numbers.length < 2) {
	    		return null;
	    	}
	        Arrays.sort(numbers);
	        int left = 0;
	        int right = numbers.length - 1;
	        int[] rst = new int[2];
	        
	        while( left < right){
	            int sum = numbers[left] +  numbers[right];
	            if( sum == target){
	                rst[0] = left + 1;
	                rst[1] = right + 1;
	                break;
	            }else if( sum < target){
	                left++;
	            }else{
	                right--;
	            }
	        }
	        return rst;
	    }

}Valid Palindrome++
++++++++++++Tag: Forward-Backward Traversal++++++++++++
Best Time to Buy and Sell Stock III++
Maximum Subarray Difference++
Maximum Subarray II++
Trapping Rain Water++
++++++++++++Tag: Sorted Array++++++++++++


===============Median of two Sorted Arrays===============
65: Median of two Sorted Arrays

"Difficulty Hard Accepted Rate 21%"
         
There are two sorted arrays A and B of size m and n respectively. Find the median of the two sorted arrays.

Example
Given A=[1,2,3,4,5,6] and B=[2,3,4,5], the median is 3.5.
Given A=[1,2,3] and B=[4,5], the median is 3.Challenge
The overall run time complexity should be O(log (m+n)).
Tags
Sorted Array
Divide and Conquer
Array
Zenefits
Uber
Google
Related Problems
3
(lintcode-copyright),(heap),(priority-queue),(google)Hard
 Data Stream Median
 24 %
 
1
(lintcode-copyright),(quick-sort),(array)Easy
 Median
 21 %
public class Solution {
    public double findMedianSortedArrays(int A[], int B[]) {
        int len = A.length + B.length;
        if (len % 2 == 1) {
            return findKth(A, 0, B, 0, len / 2 + 1);
        }
        return (
            findKth(A, 0, B, 0, len / 2) + findKth(A, 0, B, 0, len / 2 + 1)
        ) / 2.0;
    }

    // find kth number of two sorted array
    public static int findKth(int[] A, int A_start,
                              int[] B, int B_start,
                              int k){		
		if (A_start >= A.length) {
			return B[B_start + k - 1];
		}
		if (B_start >= B.length) {
			return A[A_start + k - 1];
		}

		if (k == 1) {
			return Math.min(A[A_start], B[B_start]);
		}
		
		int A_key = A_start + k / 2 - 1 < A.length
		            ? A[A_start + k / 2 - 1]
		            : Integer.MAX_VALUE;
		int B_key = B_start + k / 2 - 1 < B.length
		            ? B[B_start + k / 2 - 1]
		            : Integer.MAX_VALUE; 
		
		if (A_key < B_key) {
			return findKth(A, A_start + k / 2, B, B_start, k - k / 2);
		} else {
			return findKth(A, A_start, B, B_start + k / 2, k - k / 2);
		}
	}
}

===============Merge Sorted Array II===============
6: Merge Sorted Array II

"Difficulty Easy Accepted Rate 35%"
         
Merge two given sorted integer array A and B into a new sorted integer array.

Example
A=[1,2,3,4]
B=[2,4,5,6]
return [1,2,2,3,4,4,5,6]Challenge
How can you optimize your algorithm if one array is very large and the other is very small?
Tags
Sorted Array
Array
Related Problems
1
(linkedin),(linked-list)Easy
 Merge Two Sorted Lists
 37 %
 
2
(linked-list),(divide-and-conquer),(heap),(priority-queue),(uber),(google),(twitter),(linkedin),(airbnb),(facebook)Medium
 Merge k Sorted Lists 
 26 %
 
1
(sorted-array),(array),(facebook)Easy
 Merge Sorted Array
 32 %
class Solution {
    /**
     * @param A and B: sorted integer array A and B.
     * @return: A new sorted integer array
     */
    public ArrayList<Integer> mergeSortedArray(ArrayList<Integer> A, ArrayList<Integer> B) {
        int len = B.size();
        for (int i = 0; i < len; ++i) 
            A.add(B.get(i));
        Collections.sort(A);
        return A;
    }
}

===============Merge Sorted Array===============
64: Merge Sorted Array

"Difficulty Easy Accepted Rate 32%"
         
Given two sorted integer arrays A and B, merge B into A as one sorted array.

Example
A = [1, 2, 3, empty, empty], B = [4, 5]
After merge, A will be filled as [1, 2, 3, 4, 5]Note
You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B. The number of elements initialized in A and B are m and n respectively.
Tags
Sorted Array
Array
Facebook
Related Problems
1
(string),(cracking-the-coding-interview)Easy
 Space Replacement
 16 %
 
1
(sorted-array),(array)Easy
 Merge Sorted Array II
 35 %
class Solution {
    /**
     * @param A: sorted integer array A which has m elements, 
     *           but size of A is m+n
     * @param B: sorted integer array B which has n elements
     * @return: void
     */
    public void mergeSortedArray(int[] A, int m, int[] B, int n) {
        int i = m-1, j = n-1, index = m + n - 1;
        while (i >= 0 && j >= 0) {
            if (A[i] > B[j]) {
                A[index--] = A[i--];
            } else {
                A[index--] = B[j--];
            }
        }
        while (i >= 0) {
            A[index--] = A[i--];
        }
        while (j >= 0) {
            A[index--] = B[j--];
        }
    }
}

===============Recover Rotated Sorted Array===============
39: Recover Rotated Sorted Array

"Difficulty Easy Accepted Rate 26%"
         
Given a rotated sorted array, recover it to sorted array in-place.

Example
[4, 5, 1, 2, 3] -> [1, 2, 3, 4, 5]Challenge
In-place, O(1) extra space and O(n) time.
Clarification
What is rotated array?For example, the orginal array is [1,2,3,4], The rotated array of it can be [1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]

Tags
Sorted Array
Array
Related Problems

(two-pointers),(sort),(array),(facebook)Medium
 Sort Colors
 32 %
 
1
(string)Easy
 Rotate String
 21 %
import java.util.ArrayList;


public class Solution {
    /**
     * @param nums: The rotated sorted array
     * @return: The recovered sorted array
     */
    private void reverse(ArrayList<Integer> nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int temp = nums.get(i);
            nums.set(i, nums.get(j));
            nums.set(j, temp);
        }
    }

    public void recoverRotatedSortedArray(ArrayList<Integer> nums) {
        for (int index = 0; index < nums.size() - 1; index++) {
            if (nums.get(index) > nums.get(index + 1)) {
                reverse(nums, 0, index);
                reverse(nums, index + 1, nums.size() - 1);
                reverse(nums, 0, nums.size() - 1);
                return;
            }
        }
    }
}Search for a Range++
Search in Rotated Sorted Array II++
Search in Rotated Sorted Array++
Search Insert Position++
++++++++++++Tag: Cracking The Coding Interview++++++++++++


===============Add Two Numbers===============
167: Add Two Numbers

"Difficulty Easy Accepted Rate 20%"
         
You have two numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1's digit is at the head of the list. Write a function that adds the two numbers and returns the sum as a linked list.

Example
Given 7->1->6 + 5->9->2. That is, 617 + 295.
Return 2->1->9. That is 912.
Given 3->1->5 and 5->9->2, return 8->0->8.

Tags
Cracking The Coding Interview
Linked List
High Precision
Related Problems
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1 == null && l2 == null) {
            return null;
        }
            
        ListNode head = new ListNode(0);
        ListNode point = head;
        int carry = 0;
        while(l1 != null && l2!=null){
            int sum = carry + l1.val + l2.val;
            point.next = new ListNode(sum % 10);
            carry = sum / 10;
            l1 = l1.next;
            l2 = l2.next;
            point = point.next;
        }
        
        while(l1 != null) {
            int sum =  carry + l1.val;
            point.next = new ListNode(sum % 10);
            carry = sum /10;
            l1 = l1.next;
            point = point.next;
        }
        
        while(l2 != null) {
            int sum =  carry + l2.val;
            point.next = new ListNode(sum % 10);
            carry = sum /10;
            l2 = l2.next;
            point = point.next;
        }
        
        if (carry != 0) {
            point.next = new ListNode(carry);
        }
        return head.next;
    }
}Binary Representation++


===============Rotate Image===============
161: Rotate Image

"Difficulty Medium Accepted Rate 34%"
         
You are given an n x n 2D matrix representing an image.
Rotate the image by 90 degrees (clockwise).

Example
Given a matrix
[
[1,2],
[3,4]
]rotate it by 90 degrees (clockwise), return
[
[3,1],
[4,2]
]
Challenge
Do it in-place.
Tags
Cracking The Coding Interview
Matrix
Related Problems
1
(lintcode-copyright),(matrix)Easy
 Matrix Zigzag Traversal
 23 %
 
2
(cracking-the-coding-interview),(matrix)Medium
 Set Matrix Zeroes
 32 %
 
1
(string)Easy
 Rotate String
 21 %
public class Solution {
    public void rotate(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }

        int length = matrix.length;

        for (int i = 0; i < length / 2; i++) {
            for (int j = 0; j < (length + 1) / 2; j++){
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[length - j - 1][i];
                matrix[length -j - 1][i] = matrix[length - i - 1][length - j - 1];
                matrix[length - i - 1][length - j - 1] = matrix[j][length - i - 1];
                matrix[j][length - i - 1] = tmp;
            }
        }   
    }
}

===============Set Matrix Zeroes===============
162: Set Matrix Zeroes

"Difficulty Medium Accepted Rate 32%"
         
Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.

Example
Given a matrix
[
[1,2],
[0,3]
],return
[
[0,2],
[0,0]
]Challenge
Did you use extra space?
A straight forward solution using O(mn) space is probably a bad idea.
A simple improvement uses O(m + n) space, but still not the best solution.
Could you devise a constant space solution?
Tags
Cracking The Coding Interview
Matrix
Related Problems

(cracking-the-coding-interview),(matrix)Medium
 Rotate Image 
 34 %
public class Solution {
     // using O(m+n) is easy, to enable O(1), we have to use the space within the matrix   
    public void setZeroes(int[][] matrix) {
        if(matrix == null || matrix.length == 0)
            return;
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        boolean empty_row0 = false;
        boolean empty_col0 = false;
        for(int i = 0; i < cols; i++){
            if(matrix[0][i] == 0){
                empty_row0 = true;
                break;
            }
        }
        
        for(int i = 0; i < rows; i++){
            if(matrix[i][0] == 0){
                empty_col0 = true;
                break;
            }
        }
        
        for(int i = 1; i < rows; i++) {
            for(int j =1; j<cols; j++){
                if(matrix[i][j] == 0){
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }
        
        for(int i = 1; i<rows; i++) {
            for (int j=1; j< cols; j++) {
                if(matrix[0][j] == 0 || matrix[i][0] == 0)
                    matrix[i][j] = 0;
            }
        }
      
        if(empty_row0){
            for(int i = 0; i < cols; i++){
                matrix[0][i] = 0;
            }           
        }
        
        if(empty_col0){
            for(int i = 0; i < rows; i++){
                matrix[i][0] = 0;
            }           
        }

    }
}Space Replacement++
Two Strings Are Anagrams++
Unique Characters++


===============Update Bits===============
179: Update Bits

"Difficulty Medium Accepted Rate 19%"
         
Given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to set all bits between i and j in N equal to M (e g , M becomes a substring of N located at i and starting at j)

Example
Given N=(10000000000)2, M=(10101)2, i=2, j=6
return N=(10001010100)2Note
In the function, the numbers N and M will given in decimal, you should also return a decimal number.
Challenge
Minimum number of operations?
Clarification
You can assume that the bits j through i have enough space to fit all of M. That is, if M=10011， you can assume that there are at least 5 bits between j and i. You would not, for example, have j=3 and i=2, because M could not fully fit between bit 3 and bit 2.
Tags
Cracking The Coding Interview
Bit Manipulation
Related Problems
3
(string),(cracking-the-coding-interview),(bit-manipulation)Hard
 Binary Representation
 17 %
class Solution {
public:
    /**
     *@param n, m: Two integer
     *@param i, j: Two bit positions
     *return: An integer
     */
    int updateBits(int n, int m, int i, int j) {
        int mask;
        if (j < 31) {
            mask = ~((1 << (j + 1)) - (1 << i));
        } else {
            mask = (1 << i) - 1;
        }
        return (m << i) + (mask & n);
    }
};++++++++++++Tag: CareerCup++++++++++++
++++++++++++Tag: LintCode Copyright++++++++++++


===============Backpack===============
92: Backpack

"Difficulty Medium Accepted Rate 20%"
         
Given n items with size Ai, an integer m denotes the size of a backpack. How full you can fill this backpack? 

Example
If we have 4 items with size [2, 3, 5, 7], the backpack size is 11, we can select [2, 3, 5], so that the max size we can fill this backpack is 10. If the backpack size is 12. we can select [2, 3, 7] so that we can fulfill the backpack.
You function should return the max size we can fill in the given backpack.Note
You can not divide any item into small pieces.
Challenge
O(n x m) time and O(m) memory.
O(n x m) memory is also acceptable if you do not know how to optimize memory.
Tags
LintCode Copyright
Dynamic Programming
Backpack
Related Problems

(lintcode-copyright),(dynamic-programming),(backpack)Medium
 Backpack II
 34 %
public class Solution {
    /**
     * @param m: An integer m denotes the size of a backpack
     * @param A: Given n items with size A[i]
     * @return: The maximum size
     */
    public int backPack(int m, int[] A) {
        boolean f[][] = new boolean[A.length + 1][m + 1];
        for (int i = 0; i <= A.length; i++) {
            for (int j = 0; j <= m; j++) {
                f[i][j] = false;
            }
        }
        f[0][0] = true;
        for (int i = 0; i < A.length; i++) {
            for (int j = 0; j <= m; j++) {
                f[i + 1][j] = f[i][j];
                if (j >= A[i] && f[i][j - A[i]]) {
                    f[i + 1][j] = true;
                }
            } // for j
        } // for i
        
        for (int i = m; i >= 0; i--) {
            if (f[A.length][i]) {
                return i;
            }
        }
        return 0;
    }
}

===============Binary Search Tree Iterator===============
86: Binary Search Tree Iterator

"Difficulty Hard Accepted Rate 30%"
         
Design an iterator over a binary search tree with the following rules:

Example
For the following binary search tree, in-order traversal by using iterator is [1, 6, 10, 11, 12]
 10
 /\
111
 \ \
6 12
Challenge
Extra memory usage O(h), h is the height of the tree.
Super Star: Extra memory usage O(1)
Tags
Binary Tree
Binary Search Tree
LintCode Copyright
Non Recursion
Google
LinkedIn
Facebook
Related Problems
public class BSTIterator {
    private Stack<TreeNode> stack = new Stack<>();
    private TreeNode curt;
    
    // @param root: The root of binary tree.
    public BSTIterator(TreeNode root) {
        curt = root;
    }

    //@return: True if there has next node, or false
    public boolean hasNext() {
        return (curt != null || !stack.isEmpty());
    }
    
    //@return: return next node
    public TreeNode next() {
        while (curt != null) {
            stack.push(curt);
            curt = curt.left;
        }
        
        curt = stack.pop();
        TreeNode node = curt;
        curt = curt.right;
        
        return node;
    }
}

===============Building Outline===============
131: Building Outline

"Difficulty Super Accepted Rate 11%"
         
Given N buildings in a x-axis，each building is a rectangle and can be represented by a triple (start, end, height)，where start is the start position on x-axis, end is the end position on x-axis and height is the height of the building. Buildings may overlap if you see them from far away，find the outline of them。

Example
Given 3 buildings：
[
[1, 3, 3],
[2, 4, 4],
[5, 6, 1]
]The outlines are：
[
[1, 2, 3],
[2, 4, 4],
[5, 6, 1]
]
Note
Please merge the adjacent outlines if they have the same height and make sure different outlines cant overlap on x-axis.
Tags
LintCode Copyright
Heap
Google
Related Problems

public class Solution {

	class HashHeap {
		ArrayList<Integer> heap;
		String mode;
		int size_t;
		HashMap<Integer, Node> hash;

		class Node {
			public Integer id;
			public Integer num;

			Node(Node now) {
				id = now.id;
				num = now.num;
			}

			Node(Integer first, Integer second) {

				this.id = first;
				this.num = second;
			}
		}

		public HashHeap(String mod) {
			// TODO Auto-generated constructor stub
			heap = new ArrayList<Integer>();
			mode = mod;
			hash = new HashMap<Integer, Node>();
			size_t = 0;
		}

		public int peek() {
			return heap.get(0);
		}

		public int size() {
			return size_t;
		}

		public Boolean isEmpty() {
			return (heap.size() == 0);
		}

		int parent(int id) {
			if (id == 0) {
				return -1;
			}
			return (id - 1) / 2;
		}

		int lson(int id) {
			return id * 2 + 1;
		}

		int rson(int id) {
			return id * 2 + 2;
		}

		boolean comparesmall(int a, int b) {
			if (a <= b) {
				if (mode == "min")
					return true;
				else
					return false;
			} else {
				if (mode == "min")
					return false;
				else
					return true;
			}

		}

		void swap(int idA, int idB) {
			int valA = heap.get(idA);
			int valB = heap.get(idB);

			int numA = hash.get(valA).num;
			int numB = hash.get(valB).num;
			
			hash.put(valB, new Node(idA, numB));
			hash.put(valA, new Node(idB, numA));
			heap.set(idA, valB);
			heap.set(idB, valA);
		}

		public Integer poll() {
			size_t--;
			Integer now = heap.get(0);
			Node hashnow = hash.get(now);
			if (hashnow.num == 1) {
				swap(0, heap.size() - 1);
				hash.remove(now);
				heap.remove(heap.size() - 1);
				if (heap.size() > 0) {
					siftdown(0);
				}
			} else {
				hash.put(now, new Node(0, hashnow.num - 1));
			}
			return now;
		}

		public void add(int now) {
			size_t++;
			if (hash.containsKey(now)) {
				Node hashnow = hash.get(now);
				hash.put(now, new Node(hashnow.id, hashnow.num + 1));

			} else {
				heap.add(now);
				hash.put(now, new Node(heap.size() - 1, 1));
			}

			siftup(heap.size() - 1);
		}

		public void delete(int now) {
			size_t--;
			Node hashnow = hash.get(now);
			int id = hashnow.id;
			int num = hashnow.num;
			if (hashnow.num == 1) {

				swap(id, heap.size() - 1);
				hash.remove(now);
				heap.remove(heap.size() - 1);
				if (heap.size() > id) {
					siftup(id);
					siftdown(id);
				}
			} else {
				hash.put(now, new Node(id, num - 1));
			}
		}

		http://www.lintcode.com/en/problem/sliding-window-median/
	}
		}

		void siftdown(int id) {
			while (lson(id) < heap.size()) {
				int leftId = lson(id);
				int rightId = rson(id);
				int son;
				if (rightId >= heap.size()
						|| (comparesmall(heap.get(leftId), heap.get(rightId)) == true)) {
					son = leftId;
				} else {
					son = rightId;
				}
				if (comparesmall(heap.get(id), heap.get(son)) == true) {
					break;
				} else {
					swap(id, son);
				}
				id = son;
			}
		}
	}

	class Edge {
		int pos;
		int height;
		boolean isStart;

		public Edge(int pos, int height, boolean isStart) {
			this.pos = pos;
			this.height = height;
			this.isStart = isStart;
		}

	}

	class EdgeComparator implements Comparator<Edge> {
		@Override
		public int compare(Edge arg1, Edge arg2) {
			Edge l1 = (Edge) arg1;
			Edge l2 = (Edge) arg2;
			if (l1.pos != l2.pos)
				return compareInteger(l1.pos, l2.pos);
			if (l1.isStart && l2.isStart) {
				return compareInteger(l2.height, l1.height);
			}
			if (!l1.isStart && !l2.isStart) {
				return compareInteger(l1.height, l2.height);
			}
			return l1.isStart ? -1 : 1;
		}

		int compareInteger(int a, int b) {
			return a <= b ? -1 : 1;
		}
	}

	ArrayList<ArrayList<Integer>> output(ArrayList<ArrayList<Integer>> res) {
		ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();
		if (res.size() > 0) {
			int pre = res.get(0).get(0);
			int height = res.get(0).get(1);
			for (int i = 1; i < res.size(); i++) {
				ArrayList<Integer> now = new ArrayList<Integer>();
				int id = res.get(i).get(0);
				if (height > 0) {
					now.add(pre);
					now.add(id);
					now.add(height);
					ans.add(now);
				}
				pre = id;
				height = res.get(i).get(1);
			}
		}
		return ans;
	}

	public ArrayList<ArrayList<Integer>> buildingOutline(int[][] buildings) {
		// write your code here
		ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();

		if (buildings == null || buildings.length == 0
				|| buildings[0].length == 0) {
			return res;
		}
		ArrayList<Edge> edges = new ArrayList<Edge>();
		for (int[] building : buildings) {
			Edge startEdge = new Edge(building[0], building[2], true);
			edges.add(startEdge);
			Edge endEdge = new Edge(building[1], building[2], false);
			edges.add(endEdge);
		}
		Collections.sort(edges, new EdgeComparator());

		HashHeap heap = new HashHeap("max");

		ArrayList<Integer> now = null;
		for (Edge edge : edges) {
			if (edge.isStart) {
				if (heap.isEmpty() || edge.height > heap.peek()) {
					now = new ArrayList<Integer>(Arrays.asList(edge.pos,
							edge.height));
					res.add(now);
				}
				heap.add(edge.height);
			} else {
				heap.delete(edge.height);
				if (heap.isEmpty() || edge.height > heap.peek()) {
					if (heap.isEmpty()) {
						now = new ArrayList<Integer>(Arrays.asList(edge.pos, 0));
					} else {
						now = new ArrayList<Integer>(Arrays.asList(edge.pos,
								heap.peek()));
					}
					res.add(now);
				}
			}
		}
		return output(res);
	}

}Compare Strings++


===============Convert Expression to Reverse Polish Notation===============
370: Convert Expression to Reverse Polish Notation

"Difficulty Hard Accepted Rate 24%"
         
Given an expression string array, return the Reverse Polish notation of this expression. (remove the parentheses)

Example
For the expression [3 - 4 + 5] (which denote by ["3", "-", "4", "+", "5"]), return [3 4 - 5 +] (which denote by ["3", "4", "-", "5", "+"])

Tags
LintCode Copyright
Stack
Related Problems

(linkedin),(stack)Medium
 Evaluate Reverse Polish Notation 
 25 %
 
3
(lintcode-copyright),(stack)Hard
 Expression Evaluation
 21 %
class TreeNode {
	public int val;
	public String s;
	public TreeNode left, right;

	public TreeNode(int val, String ss) {
		this.val = val;
		this.s = ss;
		this.left = this.right = null;
	}

}


public class Solution {
    /**
     * @param expression: A string array
     * @return: The Reverse Polish notation of this expression
     */

    int get(String a, Integer base) {
		if (a.equals("+") || a.equals("-"))
			return 1 + base;
		if (a.equals("*") || a.equals("/"))
			return 2 + base;

		return Integer.MAX_VALUE;
	}

	void dfs(TreeNode root, ArrayList<String> as) {
		if(root==null)
			return;
		if (root.left != null)
			dfs(root.left, as);
		
		if (root.right != null)
			dfs(root.right, as);
		as.add(root.s);
	}

	public ArrayList<String> convertToRPN(String[] expression) {
		// write your code here
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode root = null;
		int val = 0;
		Integer base = 0;
		for (int i = 0; i <= expression.length; i++) {
			if(i != expression.length)
			{
				
				if (expression[i].equals("(")) {
					base += 10;
					continue;
				}
				if (expression[i].equals(")")) {
					base -= 10;
					continue;
				}
				val = get(expression[i], base);

			}
			TreeNode right = i == expression.length ? new TreeNode(
					Integer.MIN_VALUE, "") : new TreeNode(val,
					expression[i]);
			while (!stack.isEmpty()) {
				if (right.val <= stack.peek().val) {
					TreeNode nodeNow = stack.pop();

					if (stack.isEmpty()) {
						right.left = nodeNow;

					} else {
						TreeNode left = stack.peek();
						if (left.val < right.val) {
							right.left = nodeNow;
						} else {
							left.right = nodeNow;
						}
					}
				} else {
					break;
				}
			}
			stack.push(right);
		}

		ArrayList<String> reversepolish = new ArrayList<String>();
		dfs(stack.peek().left, reversepolish);
		
		
		return reversepolish;
	}

}

===============Count of Smaller Number before itself===============
249: Count of Smaller Number before itself

"Difficulty Hard Accepted Rate 17%"
         
Give you an integer array (index from 0 to n-1, where n is the size of this array, value from 0 to 10000) . For each element Ai in the array, count the number of element before this element Ai is smaller than it and return count number array.

Example
For array [1,2,7,8,5], return [0,1,2,3,2]Note
We suggest you finish problem Segment Tree Build, Segment Tree Query II and Count of Smaller Number before itself Ifirst.
Tags
LintCode Copyright
Binary Tree
Segment Tree
Related Problems

(binary-search),(lintcode-copyright),(segment-tree)Medium
 Count of Smaller Number
 19 %
public class Solution {
   /**
     * @param A: An integer array
     * @return: Count the number of element before this element &#39;ai&#39; is 
     *          smaller than it and return count number array
     */ 
    class SegmentTreeNode {
        public int start, end;
        public int count;
        public SegmentTreeNode left, right;
        public SegmentTreeNode(int start, int end, int count) {
              this.start = start;
              this.end = end;
              this.count = count;
              this.left = this.right = null;
        }
    }
    SegmentTreeNode root;
    public SegmentTreeNode build(int start, int end) {
        // write your code here
        if(start > end) {  // check core case
            return null;
        }
        
        SegmentTreeNode root = new SegmentTreeNode(start, end, 0);
        
        if(start != end) {
            int mid = (start + end) / 2;
            root.left = build(start, mid);
            root.right = build(mid+1, end);
        } else {
            root.count =  0;
        }
        return root;
    }
    public int querySegmentTree(SegmentTreeNode root, int start, int end) {
        // write your code here
        if(start == root.start && root.end == end) { // 相等 
            return root.count;
        }
        
        
        int mid = (root.start + root.end)/2;
        int leftcount = 0, rightcount = 0;
        // 左子区
        if(start <= mid) {
            if( mid < end) { // 分裂 
                leftcount =  querySegmentTree(root.left, start, mid);
            } else { // 包含 
                leftcount = querySegmentTree(root.left, start, end);
            }
        }
        // 右子区
        if(mid < end) { // 分裂 3
            if(start <= mid) {
                rightcount = querySegmentTree(root.right, mid+1, end);
            } else { //  包含 
                rightcount = querySegmentTree(root.right, start, end);
            } 
        }  
        // else 就是不相交
        return leftcount + rightcount;
    }
    public void modifySegmentTree(SegmentTreeNode root, int index, int value) {
        // write your code here
        if(root.start == index && root.end == index) { // 查找到
            root.count += value;
            return;
        }
        
        // 查询
        int mid = (root.start + root.end) / 2;
        if(root.start <= index && index <=mid) {
            modifySegmentTree(root.left, index, value);
        }
        
        if(mid < index && index <= root.end) {
            modifySegmentTree(root.right, index, value);
        }
        //更新
        root.count = root.left.count + root.right.count;
    }
    public ArrayList<Integer> countOfSmallerNumberII(int[] A) {
        // write your code here
        root = build(0, 10000);
        ArrayList<Integer> ans = new ArrayList<Integer>();
        int res;
        for(int i = 0; i < A.length; i++) {
            res = 0;
            if(A[i] > 0) {
                res = querySegmentTree(root, 0, A[i]-1);
            }
            modifySegmentTree(root, A[i], 1);
            ans.add(res);
        }
        return ans;
    }
}Count of Smaller Number++
Delete Digits++


===============Expression Evaluation===============
368: Expression Evaluation

"Difficulty Hard Accepted Rate 21%"
         
Given an expression string array, return the final result of this expression

Example
For the expression 2*6-(23+7)/(1+2),
input is
[
"2", "*", "6", "-", "(",
"23", "+", "7", ")", "/",
(", "1", "+", "2", ")"
],return 2Note
The expression contains only integer, +, -, *, /, (, ). 
Tags
LintCode Copyright
Stack
Related Problems
3
(lintcode-copyright),(stack),(binary-tree)Hard
 Expression Tree Build
 19 %
 
3
(lintcode-copyright),(stack)Hard
 Convert Expression to Reverse Polish Notation
 24 %
class TreeNode {
	public int val;
	public String s;
	public TreeNode left, right;

	public TreeNode(int val, String ss) {
		this.val = val;
		this.s = ss;
		this.left = this.right = null;
	}

}

public class Solution {

	int get(String a, Integer base) {
		if (a.equals("+") || a.equals("-"))
			return 1 + base;
		if (a.equals("*") || a.equals("/"))
			return 2 + base;

		return Integer.MAX_VALUE;
	}

	void dfs(TreeNode root, ArrayList<String> as) {
		if(root==null)
			return;
		if (root.left != null)
			dfs(root.left, as);
		
		if (root.right != null)
			dfs(root.right, as);
		as.add(root.s);
	}

	public int evaluateExpression(String[] expression) {
		// write your code here
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode root = null;
		int val = 0;
		Integer base = 0;
		for (int i = 0; i <= expression.length; i++) {
			if(i != expression.length)
			{
				
				if (expression[i].equals("(")) {
					base += 10;
					continue;
				}
				if (expression[i].equals(")")) {
					base -= 10;
					continue;
				}
				val = get(expression[i], base);

			}
			TreeNode right = i == expression.length ? new TreeNode(
					Integer.MIN_VALUE, "") : new TreeNode(val,
					expression[i]);
			while (!stack.isEmpty()) {
				if (right.val <= stack.peek().val) {
					TreeNode nodeNow = stack.pop();

					if (stack.isEmpty()) {
						right.left = nodeNow;

					} else {
						TreeNode left = stack.peek();
						if (left.val < right.val) {
							right.left = nodeNow;
						} else {
							left.right = nodeNow;
						}
					}
				} else {
					break;
				}
			}
			stack.push(right);
		}

		ArrayList<String> reversepolish = new ArrayList<String>();
		dfs(stack.peek().left, reversepolish);
		String[] str = new String[reversepolish.size()];
		reversepolish.toArray(str);
		//System.out.println(as);
		
		return evalreversepolish(str);
	}

	int evalreversepolish(String[] tokens) {
		int returnValue = 0;
		String operators = "+-*/";

		Stack<String> stack = new Stack<String>();

		for (String ss : tokens) {
			if (!operators.contains(ss)) {
				stack.push(ss);
			} else {
				int a = Integer.valueOf(stack.pop());
				int b = Integer.valueOf(stack.pop());
				if (ss.equals("+")) {
					stack.push(String.valueOf(a + b));
				} else if (ss.equals("-")) {
					stack.push(String.valueOf(b - a));
				} else if (ss.equals("*")) {
					stack.push(String.valueOf(a * b));
				} else if (ss.equals("/")) {
					stack.push(String.valueOf(b / a));
				}
			}
		}
		if(stack.isEmpty())
			returnValue = 0;
		else 
			returnValue = Integer.valueOf(stack.pop());

		return returnValue;
	}
};

===============Expression Tree Build===============
367: Expression Tree Build

"Difficulty Hard Accepted Rate 19%"
         
The structure of Expression Tree is a binary tree to evaluate certain expressions.
All leaves of the Expression Tree have an number string value. All non-leaves of the Expression Tree have an operator string value.

Example
For the expression (2*6-(23+7)/(1+2)) (which can be represented by ["2" "*" "6" "-" "(" "23" "+" "7" ")" "/" "(" "1" "+" "2" ")"]). 
The expression tree will be like
 [ - ]
 /\
[ * ][ / ]
/ \ / \
[ 2 ][ 6 ][ + ][ + ]
 /\ /\
 [ 23 ][ 7 ] [ 1 ] [ 2 ] .After building the tree, you just need to return root node [-]. Clarification
See wiki:
Expression Tree
Tags
LintCode Copyright
Stack
Binary Tree
Related Problems
3
(lintcode-copyright),(stack)Hard
 Expression Evaluation
 21 %
/**
 * Definition of ExpressionTreeNode:
 * public class ExpressionTreeNode {
 *     public String symbol;
 *     public ExpressionTreeNode left, right;
 *     public ExpressionTreeNode(rooting symbol) {
 *         this.symbol = symbol;
 *         this.left = this.right = null;
 *     }
 * }
 */
class TreeNode {
	public int val;
	public String s;
	public ExpressionTreeNode root; 

	public TreeNode(int val, String ss) {
		this.val = val;
		this.root = new ExpressionTreeNode(ss);
	}

}

public class Solution {

	int get(String a, Integer base) {
		if (a.equals("+") || a.equals("-"))
			return 1 + base;
		if (a.equals("*") || a.equals("/"))
			return 2 + base;

		return Integer.MAX_VALUE;
	}



	public ExpressionTreeNode build(String[] expression) {
		// write your code here
		Stack<TreeNode> stack = new Stack<TreeNode>();
		TreeNode root = null;
		int val = 0;
		Integer base = 0;
		for (int i = 0; i <= expression.length; i++) {
			if(i != expression.length)
			{
				
				if (expression[i].equals("(")) {
					base += 10;
					continue;
				}
				if (expression[i].equals(")")) {
					base -= 10;
					continue;
				}
				val = get(expression[i], base);

			}
			TreeNode right = i == expression.length ? new TreeNode(
					Integer.MIN_VALUE, "") : new TreeNode(val,
					expression[i]);
			while (!stack.isEmpty()) {
				if (right.val <= stack.peek().val) {
					TreeNode nodeNow = stack.pop();

					if (stack.isEmpty()) {
						right.root.left = nodeNow.root;

					} else {
						TreeNode left = stack.peek();
						if (left.val < right.val) {
							right.root.left = nodeNow.root;
						} else {
							left.root.right = nodeNow.root;
						}
					}
				} else {
					break;
				}
			}
			stack.push(right);
		}

	
		
		return stack.peek().root.left;
	}


};Find Peak Element++
First Bad Version++


===============Heapify===============
130: Heapify

"Difficulty Medium Accepted Rate 32%"
         
Given an integer array, heapify it into a min-heap array.For a heap array A, A[0] is the root of heap, and for each A[i], A[i * 2 + 1] is the left child of A[i] and A[i * 2 + 2] is the right child of A[i].

Example
Given [3,2,1,4,5], return [1,2,3,4,5] or any legal heap array.Challenge
O(n) time complexity
Clarification
What is heap?Heap is a data structure, which usually have three methods: push, pop and top. where "push" add a new element the heap, "pop" delete the minimum/maximum element in the heap, "top" return the minimum/maximum element.What is heapify?
Convert an unordered integer array into a heap array. If it is min-heap, for each element A[i], we will get A[i * 2 + 1] >= A[i] and A[i * 2 + 2] >= A[i].What if there is a lot of solutions?
Return any of them.

Tags
LintCode Copyright
Heap
public class Solution {
    /**
     * @param A: Given an integer array
     * @return: void
     */
    private void siftdown(int[] A, int k) {
        while (k < A.length) {
            int smallest = k;
            if (k * 2 + 1 < A.length && A[k * 2 + 1] < A[smallest]) {
                smallest = k * 2 + 1;
            }
            if (k * 2 + 2 < A.length && A[k * 2 + 2] < A[smallest]) {
                smallest = k * 2 + 2;
            }
            if (smallest == k) {
                break;
            }
            int temp = A[smallest];
            A[smallest] = A[k];
            A[k] = temp;
            
            k = smallest;
        }
    }
    
    public void heapify(int[] A) {
        for (int i = A.length / 2; i >= 0; i--) {
            siftdown(A, i);
        } // for
    }
}

===============Implement Queue by Two Stacks===============
40: Implement Queue by Two Stacks

"Difficulty Medium Accepted Rate 38%"
         
As the title described, you should only use two stacks to implement a queue's actions.

Example
push(1)
pop() // return 1
push(2)
push(3)
top() // return 2
pop() // return 2
Challenge
implement it by two stacks, do not use any other data structure and push, pop and top should be O(1) by AVERAGE.
Tags
LintCode Copyright
Stack
Queue
Related Problems

(stack),(zenefits),(uber),(google)Medium
 Min Stack
 30 %
public class MyQueue {
    private Stack<Integer> stack1;
    private Stack<Integer> stack2;
    
    public Queue() {
       stack1 = new Stack<Integer>();
       stack2 = new Stack<Integer>();
    }
    
    private void stack2ToStack1() {
		while (! stack2.empty()) {
			stack1.push(stack2.peek());
			stack2.pop();
		}
	}
	
    public void push(int number) {
        stack2.push(number);
    }

    public int pop() {
        if (stack1.empty() == true) {
			this.stack2ToStack1();
		}
        return stack1.pop();
    }

    public int top() {
        if (stack1.empty() == true) {
			this.stack2ToStack1();
		}
        return stack1.peek();
    }
}

===============Insert Node in a Binary Search Tree===============
85: Insert Node in a Binary Search Tree

"Difficulty Easy Accepted Rate 40%"
         
Given a binary search tree  and a new tree node, insert the node into the tree. You should keep the tree still be a valid binary search tree.

Example
Given binary search tree as follow, after Insert node 6, the tree should be:
2 2
 / \ / \
1 4 --> 1 4
 / / \ 
3 3 6
Challenge
Can you do it without recursion?
Tags
LintCode Copyright
Binary Search Tree
Related Problems
3
(lintcode-copyright),(binary-search-tree)Hard
 Remove Node in Binary Search Tree
 25 %
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        this.val = val
        this.left, this.right = None, None
"""
class Solution:
    """
    @param root: The root of the binary search tree.
    @param node: insert this node into the binary search tree.
    @return: The root of the new binary search tree.
    """
    def insertNode(self, root, node):
        if root is None:
            return node
            
        curt = root
        while curt != node:
            if node.val < curt.val:
                if curt.left is None:
                    curt.left = node
                curt = curt.left
            else:
                if curt.right is None:
                    curt.right = node
                curt = curt.right
        return root

===============Interval Minimum Number===============
205: Interval Minimum Number

"Difficulty Medium Accepted Rate 23%"
         
Given an integer array (index from 0 to n-1, where n is the size of this array), and an query list. Each query has two integers [start, end]. For each query, calculate the minimum number between index start and end in the given array, return the result list.

Example
For array [1,2,7,8,5], and queries [(1,2),(0,4),(2,4)], return [2,1,5]Note
We suggest you finish problem Segment Tree Build, Segment Tree Query and Segment Tree Modify first.
Challenge
O(logN) time for each query
Tags
LintCode Copyright
Binary Tree
Segment Tree
Related Problems
3
(lintcode-copyright),(binary-tree),(segment-tree)Hard
 Interval Sum II
 23 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Interval Sum
 25 %
/**
 * Definition of Interval:
 * public classs Interval {
 *     int start, end;
 *     Interval(int start, int end) {
 *         this.start = start;
 *         this.end = end;
 *     }
 */
class SegmentTreeNode {
    public int start, end, min;
    public SegmentTreeNode left, right;
    public SegmentTreeNode(int start, int end, int min) {
          this.start = start;
          this.end = end;
          this.min = min;
          this.left = this.right = null;
    }
}
public class Solution {
    /**
     *@param A, queries: Given an integer array and an query list
     *@return: The result list
     */
    public SegmentTreeNode build(int start, int end, int[] A) {
        // write your code here
        if(start > end) {  // check core case
            return null;
        }
        
        SegmentTreeNode root = new SegmentTreeNode(start, end, Integer.MAX_VALUE);
        
        if(start != end) {
            int mid = (start + end) / 2;
            root.left = build(start, mid, A);
            root.right = build(mid+1, end, A);
            
            root.min = Math.min(root.left.min, root.right.min);
        } else {
            root.min = A[start];
        }
        return root;
    }
    public int query(SegmentTreeNode root, int start, int end) {
        // write your code here
        if(start == root.start && root.end == end) { // 相等 
            return root.min;
        }
        
        
        int mid = (root.start + root.end)/2;
        int leftmin = Integer.MAX_VALUE, rightmin = Integer.MAX_VALUE;
        // 左子区
        if(start <= mid) {
            if( mid < end) { // 分裂 
                leftmin =  query(root.left, start, mid);
            } else { // 包含 
                leftmin = query(root.left, start, end);
            }
        }
        // 右子区
        if(mid < end) { // 分裂 3
            if(start <= mid) {
                rightmin = query(root.right, mid+1, end);
            } else { //  包含 
                rightmin = query(root.right, start, end);
            } 
        }  
        // else 就是不相交
        return Math.min(leftmin, rightmin);
    }
    
    public ArrayList<Integer> intervalMinNumber(int[] A, 
                                                ArrayList<Interval> queries) {
        // write your code here
        SegmentTreeNode root = build(0, A.length - 1, A);
        ArrayList ans = new ArrayList<Integer>();
        for(Interval in : queries) {
            ans.add(query(root, in.start, in.end));
        }
        return ans;
    }
}

===============Interval Sum II===============
207: Interval Sum II

"Difficulty Hard Accepted Rate 23%"
         
Given an integer array in the construct method, implement two methods query(start, end) and modify(index, value):

Example
Given array A = [1,2,7,8,5].query(0, 2), return 10.
modify(0, 4), change A[0] from 1 to 4.
query(0, 1), return 6.
modify(2, 1), change A[2] from 7 to 1.
query(2, 4), return 14.
Note
We suggest you finish problem Segment Tree Build, Segment Tree Query and Segment Tree Modify first.
Challenge
O(logN) time for query and modify.
Tags
LintCode Copyright
Binary Tree
Segment Tree
Related Problems

(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Interval Sum
 25 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Interval Minimum Number
 23 %
public class Solution {
    /* you may need to use some attributes here */
    
     class SegmentTreeNode {
        public int start, end;
        public int sum;
        public SegmentTreeNode left, right;
        public SegmentTreeNode(int start, int end, int sum) {
              this.start = start;
              this.end = end;
              this.sum = sum;
              this.left = this.right = null;
        }
    }
    SegmentTreeNode root;
    public SegmentTreeNode build(int start, int end, int[] A) {
        // write your code here
        if(start > end) {  // check core case
            return null;
        }
        
        SegmentTreeNode root = new SegmentTreeNode(start, end, 0);
        
        if(start != end) {
            int mid = (start + end) / 2;
            root.left = build(start, mid, A);
            root.right = build(mid+1, end, A);
            
            root.sum = root.left.sum + root.right.sum;
        } else {
            root.sum =  A[start];
            
        }
        return root;
    }
    public int querySegmentTree(SegmentTreeNode root, int start, int end) {
        // write your code here
        if(start == root.start && root.end == end) { // 相等 
            return root.sum;
        }
        
        
        int mid = (root.start + root.end)/2;
        int leftsum = 0, rightsum = 0;
        // 左子区
        if(start <= mid) {
            if( mid < end) { // 分裂 
                leftsum =  querySegmentTree(root.left, start, mid);
            } else { // 包含 
                leftsum = querySegmentTree(root.left, start, end);
            }
        }
        // 右子区
        if(mid < end) { // 分裂 3
            if(start <= mid) {
                rightsum = querySegmentTree(root.right, mid+1, end);
            } else { //  包含 
                rightsum = querySegmentTree(root.right, start, end);
            } 
        }  
        // else 就是不相交
        return leftsum + rightsum;
    }
    public void modifySegmentTree(SegmentTreeNode root, int index, int value) {
        // write your code here
        if(root.start == index && root.end == index) { // 查找到
            root.sum = value;
            return;
        }
        
        // 查询
        int mid = (root.start + root.end) / 2;
        if(root.start <= index && index <=mid) {
            modifySegmentTree(root.left, index, value);
        }
        
        if(mid < index && index <= root.end) {
            modifySegmentTree(root.right, index, value);
        }
        //更新
        root.sum = root.left.sum + root.right.sum;
    }
    /**
     * @param A: An integer array
     */
    public Solution(int[] A) {
        // write your code here
        root = build(0, A.length-1, A);
    }
    
    /**
     * @param start, end: Indices
     * @return: The sum from start to end
     */
    public long query(int start, int end) {
        // write your code here
        return querySegmentTree(root, start ,end);
    }
    
    /**
     * @param index, value: modify A[index] to value.
     */
    public void modify(int index, int value) {
        // write your code here
        modifySegmentTree(root, index, value);
    }
}

===============Interval Sum===============
206: Interval Sum

"Difficulty Medium Accepted Rate 25%"
         
Given an integer array (index from 0 to n-1, where n is the size of this array), and an query list. Each query has two integers [start, end]. For each query, calculate the sum number between index start and end in the given array, return the result list.

Example
For array [1,2,7,8,5], and queries [(0,4),(1,2),(2,4)], return [23,9,20]Note
We suggest you finish problem Segment Tree Build, Segment Tree Query and Segment Tree Modify first.
Challenge
O(logN) time for each query
Tags
LintCode Copyright
Binary Tree
Segment Tree
Related Problems
3
(lintcode-copyright),(binary-tree),(segment-tree)Hard
 Interval Sum II
 23 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Interval Minimum Number
 23 %
/**
 * Definition of Interval:
 * public classs Interval {
 *     int start, end;
 *     Interval(int start, int end) {
 *         this.start = start;
 *         this.end = end;
 *     }
 */
public class Solution {
    /**
     *@param A, queries: Given an integer array and an query list
     *@return: The result list
     */
     class SegmentTreeNode {
        public int start, end;
        public Long sum;
        public SegmentTreeNode left, right;
        public SegmentTreeNode(int start, int end, Long sum) {
              this.start = start;
              this.end = end;
              this.sum = sum;
              this.left = this.right = null;
        }
    }
    public SegmentTreeNode build(int start, int end, int[] A) {
        // write your code here
        if(start > end) {  // check core case
            return null;
        }
        
        SegmentTreeNode root = new SegmentTreeNode(start, end, 0L);
        
        if(start != end) {
            int mid = (start + end) / 2;
            root.left = build(start, mid, A);
            root.right = build(mid+1, end, A);
            
            root.sum = root.left.sum + root.right.sum;
        } else {
            root.sum =  Long.valueOf(A[start]);
            
        }
        return root;
    }
    public Long query(SegmentTreeNode root, int start, int end) {
        // write your code here
        if(start == root.start && root.end == end) { // 相等 
            return root.sum;
        }
        
        
        int mid = (root.start + root.end)/2;
        Long leftsum = 0L, rightsum = 0L;
        // 左子区
        if(start <= mid) {
            if( mid < end) { // 分裂 
                leftsum =  query(root.left, start, mid);
            } else { // 包含 
                leftsum = query(root.left, start, end);
            }
        }
        // 右子区
        if(mid < end) { // 分裂 3
            if(start <= mid) {
                rightsum = query(root.right, mid+1, end);
            } else { //  包含 
                rightsum = query(root.right, start, end);
            } 
        }  
        // else 就是不相交
        return leftsum + rightsum;
    }
    public ArrayList<Long> intervalSum(int[] A, 
                                       ArrayList<Interval> queries) {
        // write your code here
        SegmentTreeNode root = build(0, A.length - 1, A);
        ArrayList ans = new ArrayList<Long>();
        for(Interval in : queries) {
            ans.add(query(root, in.start, in.end));
        }
        return ans;
    }
}


 *     Interval(int start, int end) {
 *         this.start = start;
 *         this.end = end;
 *     }
 */

public class Solution {
    /**
     *@param A, queries: Given an integer array and an query list
     *@return: The result list
     */
    public class SegmentTreeNode {
        public int start, end, min;
        public SegmentTreeNode left, right;
        public SegmentTreeNode(int start, int end, int min) {
              this.start = start;
              this.end = end;
              this.min = min;
              this.left = this.right = null;
        }
    }
    public SegmentTreeNode build(int start, int end, int[] A) {
        // write your code here
        if(start > end) {  // check core case
            return null;
        }
       
        SegmentTreeNode root = new SegmentTreeNode(start, end, Integer.MAX_VALUE);
       
        if(start != end) {
            int mid = (start + end) / 2;
            root.left = build(start, mid, A);
            root.right = build(mid+1, end, A);
           
            root.min = Math.min(root.left.min, root.right.min);
        } else {
            root.min = A[start];
        }
        return root;
    }
    public int query(SegmentTreeNode root, int start, int end) {
        // write your code here
        if(start == root.start && root.end == end) { // equal
            return root.min;
        }
       
       
        int mid = (root.start + root.end)/2;
        int leftmin = Integer.MAX_VALUE, rightmin = Integer.MAX_VALUE;
        // left
        if(start <= mid) {
            if( mid < end) { // split
                leftmin =  query(root.left, start, mid);
            } else { //  contain
                leftmin = query(root.left, start, end);
            }
        }
        // right
        if(mid < end) { // split
            if(start <= mid) {
                rightmin = query(root.right, mid+1, end);
            } else { //  contain
                rightmin = query(root.right, start, end);
            }
        }
        return Math.min(leftmin, rightmin);
    }
   
    public ArrayList<Integer> intervalMinNumber(int[] A,
                                                ArrayList<Interval> queries) {
        // write your code here
        SegmentTreeNode root = build(0, A.length - 1, A);
        ArrayList ans = new ArrayList<Integer>();
        for(Interval in : queries) {
            ans.add(query(root, in.start, in.end));
        }
        return ans;
    }
}

===============k Sum===============
89: k Sum

"Difficulty Hard Accepted Rate 21%"
         
Given n distinct positive integers, integer k (k <= n) and a number target.

Example
Given [1,2,3,4], k = 2, target = 5.
There are 2 solutions: [1,4] and [2,3].
Return 2.

Tags
LintCode Copyright
Dynamic Programming
Related Problems

(lintcode-copyright),(depth-first-search)Medium
 k Sum II
 32 %
public class Solution {
    /**
     * @param A: an integer array.
     * @param k: a positive integer (k <= length(A))
     * @param target: a integer
     * @return an integer
     */
    public int  kSum(int A[], int k, int target) {
        int n = A.length;
        int[][][] f = new int[n + 1][k + 1][target + 1];
        for (int i = 0; i < n + 1; i++) {
            f[i][0][0] = 1;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k && j <= i; j++) {
                for (int t = 1; t <= target; t++) {
                    f[i][j][t] = 0;
                    if (t >= A[i - 1]) {
                        f[i][j][t] = f[i - 1][j - 1][t - A[i - 1]];
                    }
                    f[i][j][t] += f[i - 1][j][t];
                } // for t
            } // for j
        } // for i
        return f[n][k][target];
    }
}Longest Common Prefix++


===============Longest Common Subsequence===============
77: Longest Common Subsequence

"Difficulty Medium Accepted Rate 37%"
         
Given two strings, find the longest common subsequence (LCS).

Example
For "ABCD" and "EDCA", the LCS is "A" (or "D", "C"), return 1.
For "ABCD" and "EACB", the LCS is "AC", return 2.Clarification
What's the definition of Longest Common Subsequence?https://en.wikipedia.org/wiki/Longest_common_subsequence_problem
http://baike.baidu.com/view/2020307.htm

Tags
LintCode Copyright
Longest Common Subsequence
Dynamic Programming
Related Problems

(string),(dynamic-programming)Medium
 Edit Distance
 28 %
 
2
(lintcode-copyright),(longest-common-subsequence),(dynamic-programming)Medium
 Longest Common Substring
 29 %
public class Solution {
    /**
     * @param A, B: Two strings.
     * @return: The length of longest common subsequence of A and B.
     */
    public int longestCommonSubsequence(String A, String B) {
        int n = A.length();
	    int m = B.length();
        int f[][] = new int[n + 1][m + 1];
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);
                if(A.charAt(i - 1) == B.charAt(j - 1))
                    f[i][j] = f[i - 1][j - 1] + 1;
            }
        }
        return f[n][m];
    }
}

===============Longest Common Substring===============
79: Longest Common Substring

"Difficulty Medium Accepted Rate 29%"
         
Given two strings, find the longest common substring.

Example
Given A = "ABCD", B = "CBCE", return 2.Note
The characters in substring should occur continuously in original string. This is different with subsequence.
Challenge
O(n x m) time and memory.
Tags
LintCode Copyright
Longest Common Subsequence
Dynamic Programming
Related Problems

(lintcode-copyright),(longest-common-subsequence),(dynamic-programming)Medium
 Longest Common Subsequence
 37 %
public class Solution {
    /**
     * @param A, B: Two string.
     * @return: the length of the longest common substring.
     */
    public int longestCommonSubstring(String A, String B) {
        // write your code here
        int maxlen = 0;
        int xlen = A.length();
        int ylen = B.length();
        for(int i = 0; i < xlen; ++i)
	    {
		    for(int j = 0; j < ylen; ++j)
		    {
			    int len = 0;
                while (i + len < xlen && j + len < ylen && 
                    A.charAt(i + len) == B.charAt(j + len))
                        len ++;
			    if(len > maxlen)
				    maxlen = len;
		    }
	    }
        return maxlen;
    }
}Longest Increasing Subsequence++
Longest Words++


===============Lowest Common Ancestor===============
88: Lowest Common Ancestor

"Difficulty Medium Accepted Rate 34%"
         
Given the root and two nodes in a Binary Tree. Find the lowest common ancestor(LCA) of the two nodes.

Example
For the following binary tree:
4
 / \
3 7
 / \
5 6LCA(3, 5) = 4
LCA(5, 6) = 7
LCA(6, 7) = 7

Tags
LintCode Copyright
LinkedIn
Binary Tree
Facebook
Related Problems
Version 1: Traditional Method

public class Solution {
    private ArrayList<TreeNode> getPath2Root(TreeNode node) {
        ArrayList<TreeNode> list = new ArrayList<TreeNode>();
        while (node != null) {
            list.add(node);
            node = node.parent;
        }
        return list;
    }
    public TreeNode lowestCommonAncestor(TreeNode node1, TreeNode node2) {
        ArrayList<TreeNode> list1 = getPath2Root(node1);
        ArrayList<TreeNode> list2 = getPath2Root(node2);
        
        int i, j;
        for (i = list1.size() - 1, j = list2.size() - 1; i >= 0 && j >= 0; i--, j--) {
            if (list1.get(i) != list2.get(j)) {
                return list1.get(i).parent;
            }
        }
        return list1.get(i+1);
    }
}

Version 2: Divide & Conquer

public class Solution {
    // 在root为根的二叉树中找A,B的LCA:
    // 如果找到了就返回这个LCA
    // 如果只碰到A，就返回A
    // 如果只碰到B，就返回B
    // 如果都没有，就返回null
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode node1, TreeNode node2) {
        if (root == null || root == node1 || root == node2) {
            return root;
        }
        
        // Divide
        TreeNode left = lowestCommonAncestor(root.left, node1, node2);
        TreeNode right = lowestCommonAncestor(root.right, node1, node2);
        
        // Conquer
        if (left != null && right != null) {
            return root;
        } 
        if (left != null) {
            return left;
        }
        if (right != null) {
            return right;
        }
        return null;
    }
}Majority Number II++


===============Majority Number III===============
48: Majority Number III

"Difficulty Medium Accepted Rate 25%"
         
Given an array of integers and a number k, the majority number is the number that occurs more than 1/k of the size of the array. 

Example
Given [3,1,2,3,2,3,3,4,4,4] and k=3, return 3.Note
There is only one majority number in the array.
Challenge
O(n) time and O(k) extra space
Tags
LintCode Copyright
Hash Table
Linked List
Related Problems

(greedy),(lintcode-copyright)Medium
 Single Number III
 33 %
 
2
(greedy)Medium
 Single Number II
 38 %
 
1
(greedy)Easy
 Single Number
 57 %
 
2
(lintcode-copyright),(hash-table),(linked-list)Medium
 Majority Number III
 25 %
 
2
(greedy),(enumeration),(lintcode-copyright),(zenefits)Medium
 Majority Number II
 28 %
 
1
(greedy),(enumeration),(lintcode-copyright),(zenefits)Easy
 Majority Number
 40 %
public class Solution {
    /**
     * @param nums: A list of integers
     * @param k: As described
     * @return: The majority number
     */
    public int majorityNumber(ArrayList<Integer> nums, int k) {
        // count at most k keys.
        HashMap<Integer, Integer> counters = new HashMap<Integer, Integer>();
        for (Integer i : nums) {
            if (!counters.containsKey(i)) {
                counters.put(i, 1);
            } else {
                counters.put(i, counters.get(i) + 1);
            }
            
            if (counters.size() >= k) {
                removeKey(counters);
            }
        }
        
        // corner case
        if (counters.size() == 0) {
            return Integer.MIN_VALUE;
        }
        
        // recalculate counters
        for (Integer i : counters.keySet()) {
            counters.put(i, 0);
        }
        for (Integer i : nums) {
            if (counters.containsKey(i)) {
                counters.put(i, counters.get(i) + 1);
            }
        }
        
        // find the max key
        int maxCounter = 0, maxKey = 0;
        for (Integer i : counters.keySet()) {
            if (counters.get(i) > maxCounter) {
                maxCounter = counters.get(i);
                maxKey = i;
            }
        }
        
        return maxKey;
    }
    
    private void removeKey(HashMap<Integer, Integer> counters) {
        Set<Integer> keySet = counters.keySet();
        List<Integer> removeList = new ArrayList<>();
        for (Integer key : keySet) {
            counters.put(key, counters.get(key) - 1);
            if (counters.get(key) == 0) {
                removeList.add(key);
            }
        }
        for (Integer key : removeList) {
            counters.remove(key);
        }
    }
}Majority Number++
Maximum Subarray Difference++
Maximum Subarray II++


===============Maximum Subarray III===============
43: Maximum Subarray III

"Difficulty Hard Accepted Rate 23%"
         
Given an array of integers and a number k, find k non-overlapping subarrays which have the largest sum.

Example
Given [-1,4,-2,3,-2,3], k=2, return 8Note
The subarray should contain at least one number
Tags
LintCode Copyright
Dynamic Programming
Subarray
Array
Related Problems

(enumeration),(forward-backward-traversal),(array)Medium
 Best Time to Buy and Sell Stock III 
 26 %
 
2
(greedy),(enumeration),(array)Medium
 Best Time to Buy and Sell Stock II 
 49 %
 
2
(greedy),(enumeration),(array),(facebook),(uber)Medium
 Best Time to Buy and Sell Stock
 41 %
 
2
(greedy),(enumeration),(forward-backward-traversal),(lintcode-copyright),(subarray),(array)Medium
 Maximum Subarray Difference
 23 %
 
3
(lintcode-copyright),(dynamic-programming),(subarray),(array)Hard
 Maximum Subarray III
 23 %
 
2
(greedy),(enumeration),(forward-backward-traversal),(lintcode-copyright),(subarray),(array)Medium
 Maximum Subarray II
 23 %
 
1
(greedy),(enumeration),(lintcode-copyright),(linkedin),(subarray),(array)Easy
 Maximum Subarray
 37 %
public class Solution {
    /**
     * @param nums: A list of integers
     * @param k: An integer denote to find k non-overlapping subarrays
     * @return: An integer denote the sum of max k non-overlapping subarrays
     */ 
    public static int maxSubArray(ArrayList<Integer> nums, int k) {
        // write your code
        int len = nums.size();
        int[][] f = new int[k+1][len];
        for (int i = 1; i < k+1; i++) {
            int sum = 0;
            for (int j = 0; j < i; j++) {
                sum += nums.get(j);
            }
            f[i][i-1] = sum;
        }
        for (int i = 1; i < len; i++) {
        	f[1][i] = Math.max(f[1][i-1]+nums.get(i), nums.get(i));
        }
        
        for (int i = 2; i < k+1; i++) {
            for (int n = i;  n< len; n++) {
                int curMax = f[i][n-1] + nums.get(n);
                for (int j = i-2; j < n; j++) {
                    if ((f[i-1][j] + nums.get(n)) > curMax) {
                        curMax = f[i-1][j] + nums.get(n);
                    }
                }
                f[i][n] = curMax;
            }
        }
        
        int res = Integer.MIN_VALUE;
        for (int i = k-1; i < len; i++){
            if (f[k][i] > res) {
                res = f[k][i];
            }
        }
        return res;
    }
}Maximum Subarray++


===============Median===============
80: Median

"Difficulty Easy Accepted Rate 21%"
         
Given a unsorted array with integers, find the median of it. 

Example
Given [4, 5, 1, 2, 3], return 3
Given [7, 9, 4, 5], return 5Challenge
O(n) time.
Tags
LintCode Copyright
Quick Sort
Array
Related Problems
3
(lintcode-copyright),(heap),(priority-queue),(google)Hard
 Data Stream Median
 24 %
 
3
(sorted-array),(divide-and-conquer),(array),(zenefits),(uber),(google)Hard
 Median of two Sorted Arrays
 21 %
public class Solution {
    /**
     * @param nums: A list of integers.
     * @return: An integer denotes the middle number of the array.
     */
    public int median(int[] nums) {
        return sub(nums, 0, nums.length - 1, (nums.length + 1)/2);
    }
    private int sub(int[] nums, int start, int end, int size) {
        int mid = (start + end) / 2;
        int pivot = nums[mid];
        int i = start - 1, j = end + 1;
        for (int k = start; k < j; k++) {
            if (nums[k] < pivot) {
                i++;
                int tmp = nums[i];
                nums[i] = nums[k];
                nums[k] = tmp;
            } else if (nums[k] > pivot) {
                j--;
                int tmp = nums[j];
                nums[j] = nums[k];
                nums[k] = tmp;
                k--;
            }
        }
        if (i - start + 1 >= size) {
            return sub(nums, start, i, size);
        } else if (j - start >= size) {
            return nums[j-1];
        } else {
            return sub(nums, j, end, size - (j - start));
        }
    }
}Minimum Subarray++


===============Next Permutation===============
52: Next Permutation

"Difficulty Medium Accepted Rate 23%"
         
Given a list of integers, which denote a permutation.

Example
For [1,3,2,3], the next permutation is [1,3,3,2]
For [4,3,2,1], the next permutation is [1,2,3,4]Note
The list may contains duplicate integers.
Tags
LintCode Copyright
Permutation
Related Problems

(permutation),(array)Medium
 Permutation Sequence
 25 %
 
2
(lintcode-copyright),(permutation)Medium
 Previous Permutation
 25 %
 
2
(linkedin),(recursion),(depth-first-search)Medium
 Permutations II
 22 %
public class Solution {
    public void nextPermutation(int[] num) {
        if (num == null) {
            return;
        }
        
        int len = num.length;
        for (int i = len - 2; i >= 0; i--) {
            if (num[i + 1] > num[i]) {
                int j;
                for (j = len - 1; j > i - 1; j--) {
                    if (num[j] > num[i]) {
                        break;
                    }
                }

                swap(num, i, j);
                reverse(num, i + 1, len-1);
                return;
            }
        }

        reverse(num, 0, len-1);
    }

    void swap(int[] num, int i, int j) {
        int tmp = num[i];
        num[i] = num[j];
        num[j] = tmp;
    }

    void reverse(int[] num, int beg, int end) {
        for (int i = beg, j = end; i < j; i ++, j --) {
            swap(num, i, j);
        }
    }
}

// version 2
public class Solution {
    /**
     * @param num: an array of integers
     * @return: return nothing (void), do not return anything, modify num in-place instead
     */
     
    public void reverse(int[] num, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int temp = num[i];
            num[i] = num[j];
            num[j] = temp;
        }
    }
    
    public void nextPermutation(int[] num) {
        // find the last increase index
        int index = -1;
        for (int i = num.length - 2; i >= 0; i--) {
            if (num[i] < num[i + 1]) {
                index = i;
                break;
            }
        }
        if (index == -1) {
            reverse(num, 0, num.length - 1);
            return;
        }
        
        // find the first bigger one
        int biggerIndex = index + 1;
        for (int i = num.length - 1; i > index; i--) {
            if (num[i] > num[index]) {
                biggerIndex = i;
                break;
            }
        }
        
        // swap them to make the permutation bigger
        int temp = num[index];
        num[index] = num[biggerIndex];
        num[biggerIndex] = temp;
        
        // reverse the last part
        reverse(num, index + 1, num.length - 1);
    }
}

===============Number of Airplanes in the Sky===============
391: Number of Airplanes in the Sky

"Difficulty Medium Accepted Rate 21%"
         
Given an interval list which are flying and landing time of the flight. How many airplanes are on the sky at most?

Example
For interval list [[1,10],[2,3],[5,8],[4,7]],return 3Note
If landing and flying happens at the same time, we consider landing should happen at first.
Tags
LintCode Copyright
Array
Interval
Related Problems
1
(linkedin),(sort),(array),(google)Easy
 Merge Intervals
 19 %
/**
 * Definition of Interval:
 * public classs Interval {
 *     int flag, end;
 *     Interval(int flag, int end) {
 *         this.flag = flag;
 *         this.end = end;
 *     }
 */
class Point{
    int time;
    int flag;

    Point(int t, int s){
      this.time = t;
      this.flag = s;
    }
    public static Comparator<Point> PointComparator  = new Comparator<Point>(){
      public int compare(Point p1, Point p2){
        if(p1.time == p2.time) return p1.flag - p2.flag;
        else return p1.time - p2.time;
      }
    };
}
  
class Solution {
    /**
     * @param intervals: An interval array
     * @return: Count of airplanes are in the sky.
     */
  public int countOfAirplanes(List<Interval> airplanes) { 
    List<Point> list = new ArrayList<>(airplanes.size()*2);
    for(Interval i : airplanes){
      list.add(new Point(i.start, 1));
      list.add(new Point(i.end, 0));
    }

    Collections.sort(list,Point.PointComparator );
    int count = 0, ans = 0;
    for(Point p : list){
      if(p.flag == 1) count++;
      else count--;
      ans = Math.max(ans, count);
    }

    return ans;
  }
    
}Product of Array Exclude Itself++


===============Rehashing===============
129: Rehashing

"Difficulty Medium Accepted Rate 25%"
         
The size of the hash table is not determinate at the very beginning. If the total size of keys is too large (e.g. size >= capacity / 10), we should double the size of the hash table and rehash every keys. Say you have a hash table looks like below:

Example
Given [null, 21->9->null, 14->null, null],
return [null, 9->null, null, null, null, 21->null, 14->null, null]Note
For negative integer in hash table, the position can be calculated as follow:C++/Java: if you directly calculate -4 % 3 you will get -1. You can use function: a % b = (a % b + b) % b to make it is a non negative integer.
Python: you can directly use -1 % 3, you will get 2 automatically.

Tags
LintCode Copyright
Hash Table
/**
 * Definition for ListNode
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param hashTable: A list of The first node of linked list
     * @return: A list of The first node of linked list which have twice size
     */
    public ListNode[] rehashing(ListNode[] hashTable) {
        // write your code here
        if (hashTable.length <= 0) {
            return hashTable;
        }
        int newcapacity = 2 * hashTable.length;
        ListNode[] newTable = new ListNode[newcapacity];
        for (int i = 0; i < hashTable.length; i++) {
            while (hashTable[i] != null) {
                int newindex
                 = (hashTable[i].val % newcapacity + newcapacity) % newcapacity;
                if (newTable[newindex] == null) {
                    newTable[newindex] = new ListNode(hashTable[i].val);
                   // newTable[newindex].next = null;
                } else {
                    ListNode dummy = newTable[newindex];
                    while (dummy.next != null) {
                        dummy = dummy.next;
                    }
                    dummy.next = new ListNode(hashTable[i].val);
                }
                hashTable[i] = hashTable[i].next;
            }
        }
        return newTable;
    }
}

===============Remove Node in Binary Search Tree===============
87: Remove Node in Binary Search Tree

"Difficulty Hard Accepted Rate 25%"
         
Given a root of Binary Search Tree with unique value for each node.  Remove the node with given value. If there is no such a node with given value in the binary search tree, do nothing. You should keep the tree still a binary search tree after removal.

Example
Given binary search tree:
5
 / \
3 6
 / \
2 4Remove 3, you can either return:
5
 / \
2 6
 \
4or 
5
 / \
4 6
 /
2
Tags
LintCode Copyright
Binary Search Tree
Related Problems
1
(lintcode-copyright),(binary-search-tree)Easy
 Insert Node in a Binary Search Tree
 40 %
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: The root of the binary search tree.
     * @param value: Remove the node with given value.
     * @return: The root of the binary search tree after removal.
     */
    public TreeNode removeNode(TreeNode root, int value) {
        TreeNode dummy = new TreeNode(0);
        dummy.left = root;
        
        TreeNode parent = findNode(dummy, root, value);
        TreeNode node;
        if (parent.left != null && parent.left.val == value) {
            node = parent.left;
        } else if (parent.right != null && parent.right.val == value) {
            node = parent.right;
        } else {
            return dummy.left;
        }
        
        deleteNode(parent, node);
        
        return dummy.left;
    }
    
    private TreeNode findNode(TreeNode parent, TreeNode node, int value) {
        if (node == null) {
            return parent;
        }
        
        if (node.val == value) {
            return parent;
        }
        if (value < node.val) {
            return findNode(node, node.left, value);
        } else {
            return findNode(node, node.right, value);
        }
    }
    
    private void deleteNode(TreeNode parent, TreeNode node) {
        if (node.right == null) {
            if (parent.left == node) {
                parent.left = node.left;
            } else {
                parent.right = node.left;
            }
        } else {
            TreeNode temp = node.right;
            TreeNode father = node;
            
            while (temp.left != null) {
                father = temp;
                temp = temp.left;
            }
            
            if (father.left == temp) {
                father.left = temp.right;
            } else {
                father.right = temp.right;
            }
            
            if (parent.left == node) {
                parent.left = temp;
            } else {
                parent.right = temp;
            }
            
            temp.left = node.left;
            temp.right = node.right;
        }
    }
}

===============Segment Tree Build===============
201: Segment Tree Build

"Difficulty Medium Accepted Rate 36%"
         
The structure of Segment Tree is a binary tree which each node has two attributes start and end denote an segment / interval.

Example
Given start=0, end=3. The segment tree will be:
 [0,3]
 /\
[0,1] [2, 3]
/ \ / \
 [0, 0][1, 1] [2, 2][3, 3]Given start=1, end=6. The segment tree will be:
 [1,6]
 /\
[1,3] [4,6]
/ \ / \
 [1, 2][3,3] [4, 5] [6,6]
 /\ / \
[1,1] [2,2] [4,4] [5,5]
Clarification
Segment Tree (a.k.a Interval Tree) is an advanced data structure which can support queries like:which of these intervals contain a given point
which of these points are in a given intervalSee wiki:
Segment Tree
Interval Tree
Tags
LintCode Copyright
Binary Tree
Segment Tree
Related Problems

(segment-tree)Medium
 Segment Tree Build II
 35 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Query II
 28 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Modify
 36 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Query
 34 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Build
 36 %
/**
 * Definition of SegmentTreeNode:
 * public class SegmentTreeNode {
 *     public int start, end;
 *     public SegmentTreeNode left, right;
 *     public SegmentTreeNode(int start, int end) {
 *         this.start = start, this.end = end;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     *@param start, end: Denote an segment / interval
     *@return: The root of Segment Tree
     */
    public SegmentTreeNode build(int start, int end) {
        // write your code here
        if(start > end) {  // check core case
            return null;
        }
       
        SegmentTreeNode root = new SegmentTreeNode(start, end);
       
        if(start != end) {
            int mid = (start + end) / 2;
            root.left = build(start, mid);
            root.right = build(mid+1, end);
           
            // root.max = Math.max(root.left.max, root.right.max);
        }
        return root;
    }
}

===============Segment Tree Modify===============
203: Segment Tree Modify

"Difficulty Medium Accepted Rate 36%"
         
For a Maximum Segment Tree, which each node has an extra value max to store the maximum value in this node's interval.

Example
For segment tree:
[1, 4, max=3]
/\
[1, 2, max=2][3, 4, max=3]
 /\ / \
[1, 1, max=2], [2, 2, max=1], [3, 3, max=0], [4, 4, max=3]if call modify(root, 2, 4), we can get:
[1, 4, max=4]
/\
[1, 2, max=4][3, 4, max=3]
 /\ / \
[1, 1, max=2], [2, 2, max=4], [3, 3, max=0], [4, 4, max=3]or call modify(root, 4, 0), we can get:
[1, 4, max=2]
/\
[1, 2, max=2][3, 4, max=0]
 /\ / \
[1, 1, max=2], [2, 2, max=1], [3, 3, max=0], [4, 4, max=0]
Note
We suggest you finish problem Segment Tree Build and Segment Tree Query first.
Challenge
Do it in O(h) time, h is the height of the segment tree.
Tags
LintCode Copyright
Binary Tree
Segment Tree
Related Problems

(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Query II
 28 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Query
 34 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Build
 36 %
/**
 * Definition of SegmentTreeNode:
 * public class SegmentTreeNode {
 *     public int start, end, max;
 *     public SegmentTreeNode left, right;
 *     public SegmentTreeNode(int start, int end, int max) {
 *         this.start = start;
 *         this.end = end;
 *         this.max = max
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     *@param root, index, value: The root of segment tree and 
     *@ change the node&#39;s value with [index, index] to the new given value
     *@return: void
     */
    public void modify(SegmentTreeNode root, int index, int value) {
        // write your code here
        if(root.start == index && root.end == index) { // 查找到
            root.max = value;
            return;
        }
        
        // 查询
        int mid = (root.start + root.end) / 2;
        if(root.start <= index && index <=mid) {
            modify(root.left, index, value);
        }
        
        if(mid < index && index <= root.end) {
            modify(root.right, index, value);
        }
        //更新
        root.max = Math.max(root.left.max, root.right.max);
    }
}

===============Segment Tree Query II===============
247: Segment Tree Query II

"Difficulty Medium Accepted Rate 28%"
         
For an array, we can build a SegmentTree for it, each node stores an extra attribute count to denote the number of elements in the the array which value is between interval start and end. (The array may not fully filled by elements)

Example
For array [0, 2, 3], the corresponding value Segment Tree is:
 [0, 3, count=3]
 / \
[0,1,count=1] [2,3,count=2]
/ \ /\
 [0,0,count=1] [1,1,count=0] [2,2,count=1], [3,3,count=1]query(1, 1), return 0
query(1, 2), return 1
query(2, 3), return 2
query(0, 2), return 2Note
It is much easier to understand this problem if you finished Segment Tree Buildand Segment Tree Query first. 
Tags
LintCode Copyright
Binary Tree
Segment Tree
Related Problems

(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Modify
 36 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Query
 34 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Build
 36 %
public class Solution {
    /**
     *@param root, start, end: The root of segment tree and 
     *                         an segment / interval
     *@return: The count number in the interval [start, end]
     */
    public int query(SegmentTreeNode root, int start, int end) {
        // write your code here
        if(start > end || root==null)
            return 0;
        if(start <= root.start && root.end <= end) { // 相等 
            return root.count;
        }
        
        int mid = (root.start + root.end)/2;
        int leftsum = 0, rightsum = 0;
        // 左子区
        if(start <= mid) {
            if( mid < end) { // 分裂 
                leftsum =  query(root.left, start, mid);
            } else { // 包含 
                leftsum = query(root.left, start, end);
            }
        }
        // 右子区
        if(mid < end) { // 分裂 3
            if(start <= mid) {
                rightsum = query(root.right, mid+1, end);
            } else { //  包含 
                rightsum = query(root.right, start, end);
            } 
        }  
        // else 就是不相交
        return leftsum + rightsum;
    }
}

===============Segment Tree Query===============
202: Segment Tree Query

"Difficulty Medium Accepted Rate 34%"
         
For an integer array (index from 0 to n-1, where n is the size of this array), in the corresponding SegmentTree, each node stores an extra attribute max to denote the maximum number in the interval of the array (index from start to end).

Example
For array [1, 4, 2, 3], the corresponding Segment Tree is:
[0, 3, max=4]
 / \
[0,1,max=4][2,3,max=3]
/ \/ \
 [0,0,max=1] [1,1,max=4] [2,2,max=2], [3,3,max=3]query(root, 1, 1), return 4
query(root, 1, 2), return 4
query(root, 2, 3), return 3
query(root, 0, 2), return 4Note
It is much easier to understand this problem if you finished Segment Tree Build first. 
Tags
LintCode Copyright
Binary Tree
Segment Tree
Related Problems

(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Query II
 28 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Modify
 36 %
 
2
(lintcode-copyright),(binary-tree),(segment-tree)Medium
 Segment Tree Build
 36 %
/**
 * Definition of SegmentTreeNode:
 * public class SegmentTreeNode {
 *     public int start, end, max;
 *     public SegmentTreeNode left, right;
 *     public SegmentTreeNode(int start, int end, int max) {
 *         this.start = start;
 *         this.end = end;
 *         this.max = max
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     *@param root, start, end: The root of segment tree and 
     *                         an segment / interval
     *@return: The maximum number in the interval [start, end]
     */
    public int query(SegmentTreeNode root, int start, int end) {
        // write your code here
        if(start == root.start && root.end == end) { // 相等 
            return root.max;
        }
        
        
        int mid = (root.start + root.end)/2;
        int leftmax = Integer.MIN_VALUE, rightmax = Integer.MIN_VALUE;
        // 左子区
        if(start <= mid) {
            if( mid < end) { // 分裂 
                leftmax =  query(root.left, start, mid);
            } else { // 包含 
                leftmax = query(root.left, start, end);
            }
            // leftmax = query(root.left, start, Math.min(mid,end));
        }
        // 右子区
        if(mid < end) { // 分裂 3
            if(start <= mid) {
                rightmax = query(root.right, mid+1, end);
            } else { //  包含 
                rightmax = query(root.right, start, end);
            }
            //rightmax = query(root.right, Math.max(mid+1,start), end);
        }  
        // else 就是不相交
        return Math.max(leftmax, rightmax);
    }
}Single Number III++


===============Sliding Window Maximum===============
362: Sliding Window Maximum

"Difficulty Super Accepted Rate 25%"
         
Given an array of n integer with duplicate number, and a moving window(size k), move the window at each iteration from the start of the array, find the maximum number inside the window at each moving. 

Example
For array [1, 2, 7, 7, 8],moving window size k = 3. return [7, 7, 8]
At first the window is at the start of the array like this 
[|1, 2, 7| ,7, 8] , return the maximum 7;
then the window move one step forward.
[1, |2, 7 ,7|, 8], return the maximum 7;
then the window move one step forward again.
[1, 2, |7, 7, 8|], return the maximum 8;Challenge
o(n) time and O(k) memory
Tags
LintCode Copyright
Deque
Zenefits
Related Problems
public class Solution {
    
    /**
     * @param nums: A list of integers.
     * @return: The maximum number inside the window at each moving.
     */
    public ArrayList<Integer> maxSlidingWindow(int[] nums, int k) {
        // write your code here
    	ArrayList<Integer> ans = new ArrayList<Integer>();
        Deque<Integer> deque = new ArrayDeque<Integer>();
        int i = 0;

        
        for(int now : nums) {
            i++;
            
    		while((!deque.isEmpty() && now > deque.peekLast())) {
    			deque.pollLast();
    		} 
    		deque.offer(now);
    		if(i > k  && deque.peekFirst() == nums[i - k - 1])
    		         deque.pollFirst();
    		if(i >= k) {
    			ans.add(deque.peekFirst());
    		}
            
        }
        return ans;

    }
}Sort Letters by Case++
The Smallest Difference++


===============Topological Sorting===============
127: Topological Sorting

"Difficulty Medium Accepted Rate 25%"
         
Given an directed graph, a topological order of the graph nodes is defined as follow:

Example
For graph as follow: The topological order can be:
[0, 1, 2, 3, 4, 5]
[0, 2, 3, 1, 5, 4]
...
Note
You can assume that there is at least one topological order in the graph.
Challenge
Can you do it in both BFS and DFS?
Tags
LintCode Copyright
Geeks for Geeks
Depth First Search
Breadth First Search
/**
 * Definition for Directed graph.
 * class DirectedGraphNode {
 *     int label;
 *     ArrayList<DirectedGraphNode> neighbors;
 *     DirectedGraphNode(int x) { label = x; neighbors = new ArrayList<DirectedGraphNode>(); }
 * };
 */
public class Solution {
    /**
     * @param graph: A list of Directed graph node
     * @return: Any topological order for the given graph.
     */    
    public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
        // write your code here
        ArrayList<DirectedGraphNode> result = new ArrayList<DirectedGraphNode>();
        HashMap<DirectedGraphNode, Integer> map = new HashMap();
        for (DirectedGraphNode node : graph) {
            for (DirectedGraphNode neighbor : node.neighbors) {
                if (map.containsKey(neighbor)) {
                    map.put(neighbor, map.get(neighbor) + 1);
                } else {
                    map.put(neighbor, 1); 
                }
            }
        }
        Queue<DirectedGraphNode> q = new LinkedList<DirectedGraphNode>();
        for (DirectedGraphNode node : graph) {
            if (!map.containsKey(node)) {
                q.offer(node);
                result.add(node);
            }
        }
        while (!q.isEmpty()) {
            DirectedGraphNode node = q.poll();
            for (DirectedGraphNode n : node.neighbors) {
                map.put(n, map.get(n) - 1);
                if (map.get(n) == 0) {
                    result.add(n);
                    q.offer(n);
                }
            }
        }
        return result;
    }
}

===============Ugly Number===============
4: Ugly Number

"Difficulty Medium Accepted Rate 20%"
         
Ugly number is a number that only have factors 3, 5 and 7. 

Example
If K=4, return 9.Challenge
O(K log K) or O(K) time.
Tags
LintCode Copyright
Priority Queue
Related Problems
1
(hash-table),(mathematics)Easy
 Happy Number
 28 %
 
2
(linked-list),(divide-and-conquer),(heap),(priority-queue),(uber),(google),(twitter),(linkedin),(airbnb),(facebook)Medium
 Merge k Sorted Lists 
 26 %
class Solution {
    public long kthPrimeNumber(int n) {        
        Queue<Long> Q = new PriorityQueue<Long>();
        HashMap<Long, Boolean> inQ = new HashMap<Long, Boolean>();
        Long[] primes = new Long[3];
        primes[0] = Long.valueOf(3);
        primes[1] = Long.valueOf(5);
        primes[2] = Long.valueOf(7);
        for (int i = 0; i < 3; i++) {
            Q.add(primes[i]);
            inQ.put(primes[i], true);
        }
        Long number = Long.valueOf(0);
        for (int i = 0; i < n; i++) {
            number = Q.poll();
            for (int j = 0; j < 3; j++) {
                if (!inQ.containsKey(primes[j] * number)) {
                    Q.add(number * primes[j]);
                    inQ.put(number * primes[j], true);
                }
            }
        }
        return number;
    }
}

===============Word Search II===============
132: Word Search II

"Difficulty Hard Accepted Rate 19%"
         


Example
Given matrix:
doafagaidcan
and dictionary:
{"dog", "dad", "dgdg", "can", "again"}return {"dog", "dad", "can", "again"}
dog:
doafagaidcandad:doafagaidcancan:doafagaidcanagain:doafagaidcanChallenge
Using trie to implement your algorithm.
Tags
LintCode Copyright
Airbnb
Trie
public class Solution {
    /**
     * @param board: A list of lists of character
     * @param words: A list of string
     * @return: A list of string
     */
         
    class TrieNode {
		String s;
		 boolean isString;
		 HashMap<Character, TrieNode> subtree;
		 public TrieNode() {
			// TODO Auto-generated constructor stub
			 isString = false;
			 subtree = new HashMap<Character, TrieNode>();
			 s = "";
		 }
	};


	class TrieTree{
		TrieNode root ;
		public TrieTree(TrieNode TrieNode) {
			root = TrieNode;
		}
		public void insert(String s) {
			TrieNode now = root;
			for (int i = 0; i < s.length(); i++) {
				if (!now.subtree.containsKey(s.charAt(i))) {
					now.subtree.put(s.charAt(i), new TrieNode());
				}
				now  =  now.subtree.get(s.charAt(i));
			}
			now.s = s;
			now.isString  = true;
		}
		public boolean find(String s){
			TrieNode now = root;
			for (int i = 0; i < s.length(); i++) {
				if (!now.subtree.containsKey(s.charAt(i))) {
					return false;
				}
				now  =  now.subtree.get(s.charAt(i));
			}
			return now.isString ;
		}
	};

	public int []dx = {1, 0, -1, 0};
	public int []dy = {0, 1, 0, -1};
	
	
	
	public void search(char[][] board, int x, int y, TrieNode root, ArrayList<String> ans, String res) {
		
		
		
		
		if(root.isString == true)
		{
			if(!ans.contains(root.s)){
				ans.add(root.s);
			}
		}
		if(x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y]==0 || root == null)
			return ;
		if(root.subtree.containsKey(board[x][y])){
			for(int i = 0; i < 4; i++){
				char now = board[x][y];
				board[x][y] = 0;
				search(board, x+dx[i], y+dy[i], root.subtree.get(now), ans, res);
				board[x][y] = now;
			}
		}
		
	}
	
	public ArrayList<String> wordSearchII(char[][] board, ArrayList<String> words) {
		ArrayList<String> ans = new ArrayList<String>();
		
		TrieTree tree = new TrieTree(new TrieNode());
		for(String word : words){
			tree.insert(word);
		}
		String res = ""; 
		for(int i = 0; i < board.length; i++){
			for(int j = 0; j < board[i].length; j++){
				search(board, i, j, tree.root, ans, res);
			}
		}
		return ans;
        // write your code here
        
    }
	
}++++++++++++Tag: Binary++++++++++++
Add Binary++


===============Gray Code===============
411: Gray Code

"Difficulty Medium Accepted Rate 34%"
         
The gray code is a binary numeral system where two successive values differ in only one bit.

Example
Given n = 2, return [0,1,3,2]. Its gray code sequence is:
00 - 0
01 - 1
11 - 3
10 - 2
Note
For a given n, a gray code sequence is not uniquely defined.
[0,2,3,1] is also a valid gray code sequence according to the above definition.
Challenge
O(2n) time.
Tags
Binary
Recursion
public class Solution {
    public ArrayList<Integer> grayCode(int n) {
        ArrayList<Integer> result = new ArrayList<Integer>();
        if (n <= 1) {
            for (int i = 0; i <= n; i++){
                result.add(i);
            }
            return result;
        }
        result = grayCode(n - 1);
        ArrayList<Integer> r1 = reverse(result);
        int x = 1 << (n-1);
        for (int i = 0; i < r1.size(); i++) {
            r1.set(i, r1.get(i) + x);
        }
        result.addAll(r1);
        return result;
    }
    
    public ArrayList<Integer> reverse (ArrayList<Integer> r) {
        ArrayList<Integer> rev = new ArrayList<Integer>();
        for (int i = r.size() - 1; i >= 0; i--) {
            rev.add(r.get(i));
        }
        return rev;
    }
}++++++++++++Tag: Bit Manipulation++++++++++++
Binary Representation++
Count 1 in Binary++
Flip Bits++
Update Bits++
++++++++++++Tag: Catalan Number++++++++++++


===============Unique Binary Search Trees===============
163: Unique Binary Search Trees

"Difficulty Medium Accepted Rate 32%"
         
Given n, how many structurally unique BSTs (binary search trees) that store values 1...n?

Example
Given n = 3, there are a total of 5 unique BST's.
1 33 21
 \ // / \\
32 1 1 32
 // \\
2 123
Tags
Catalan Number
Dynamic Programming
Related Problems

(string),(backtracking),(recursion),(zenefits),(google)Medium
 Generate Parentheses
 30 %
 
1
(binary-search),(array)Easy
 First Position of Target
 30 %
public class Solution {
/*
The case for 3 elements example
Count[3] = Count[0]*Count[2]  (1 as root)
              + Count[1]*Count[1]  (2 as root)
              + Count[2]*Count[0]  (3 as root)

Therefore, we can get the equation:
Count[i] = ∑ Count[0...k] * [ k+1....i]     0<=k<i-1  

*/
    public int numTrees(int n) {
        int[] count = new int[n+2];
        count[0] = 1;
        count[1] = 1;
        
        for(int i=2;  i<= n; i++){
            for(int j=0; j<i; j++){
                count[i] += count[j] * count[i - j - 1];
            }
        }
        return count[n];
    }
}++++++++++++Tag: Backtracking++++++++++++


===============Combination Sum II===============
153: Combination Sum II

"Difficulty Medium Accepted Rate 26%"
         
Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

Example
Given candidate set [10,1,6,7,2,1,5] and target 8,
A solution set is: 
[
[1,7],
[1,2,5],
[2,6],
[1,1,6]
]
NoteAll numbers (including target) will be positive integers.
Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).
The solution set must not contain duplicate combinations.

Tags
Backtracking
Array
Depth First Search
Related Problems

(backtracking),(array)Medium
 Combination Sum 
 27 %
public class Solution {

    private ArrayList<ArrayList<Integer>> results;

    public ArrayList<ArrayList<Integer>> combinationSum2(int[] candidates,
            int target) {
        if (candidates.length < 1) {
            return results;
        }

        ArrayList<Integer> path = new ArrayList<Integer>();
        java.util.Arrays.sort(candidates);
        results = new ArrayList<ArrayList<Integer>> ();
        combinationSumHelper(path, candidates, target, 0);

        return results;
    }

    private void combinationSumHelper(ArrayList<Integer> path, int[] candidates, int sum, int pos) {
        if (sum == 0) {
            results.add(new ArrayList<Integer>(path));
        }

        if (pos >= candidates.length || sum < 0) {
            return;
        }

        int prev = -1;
        for (int i = pos; i < candidates.length; i++) {
            if (candidates[i] != prev) {
                path.add(candidates[i]);
                combinationSumHelper(path, candidates, sum - candidates[i], i + 1);
                prev = candidates[i];
                path.remove(path.size()-1);
            }
        }
    }

}

===============Combination Sum===============
135: Combination Sum

"Difficulty Medium Accepted Rate 27%"
         
given candidate set 2,3,6,7 and target 7, A solution set is: [7] [2, 2, 3] 

Example
given candidate set 2,3,6,7 and target 7, A solution set is: [7] [2, 2, 3] Note
All numbers (including target) will be positive integers.Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).The solution set must not contain duplicate combinations.
Tags
Backtracking
Array
Related Problems

(backtracking),(array),(depth-first-search)Medium
 Combination Sum II
 26 %
public class Solution {
    public  ArrayList<ArrayList<Integer>> combinationSum(int[] candidates, int target) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        if (candidates == null) {
            return result;
        }

        ArrayList<Integer> path = new ArrayList<Integer>();
        Arrays.sort(candidates);
        helper(candidates, target, path, 0, result);

        return result;
    }

     void helper(int[] candidates, int target, ArrayList<Integer> path, int index,
        ArrayList<ArrayList<Integer>> result) {
        if (target == 0) {
            result.add(new ArrayList<Integer>(path));
            return;
        }

        int prev = -1;
        for (int i = index; i < candidates.length; i++) {
            if (candidates[i] > target) {
                break;
            }

            if (prev != -1 && prev == candidates[i]) {
                continue;
            }

            path.add(candidates[i]);
            helper(candidates, target - candidates[i], path, i, result);
            path.remove(path.size() - 1);

            prev = candidates[i];
        }
    }
}

===============Combinations===============
152: Combinations

"Difficulty Medium Accepted Rate 30%"
         
For example,If n = 4 and k = 2, a solution is:[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4]]

Example
For example,If n = 4 and k = 2, a solution is:[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4]]

Tags
Backtracking
Array
Related Problems

(recursion)Medium
 N-Queens II
 39 %
 
2
(recursion),(depth-first-search)Medium
 N-Queens
 20 %
public class Solution {
    public ArrayList<ArrayList<Integer>> combine(int n, int k) {
        ArrayList<ArrayList<Integer>> rst = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> solution = new ArrayList<Integer>();
        
        helper(rst, solution, n, k, 1);
        return rst;
    }
    
    private void helper(
        ArrayList<ArrayList<Integer>> rst, 
        ArrayList<Integer> solution, 
        int n, 
        int k, 
        int start) {

        if (solution.size() == k){
            rst.add(new ArrayList(solution));
            return;
        }
        
        for(int i = start; i<= n; i++){
            solution.add(i);
            
            // the new start should be after the next number after i
            helper(rst, solution, n, k, i+1); 
            solution.remove(solution.size() - 1);
        }
    }
}Generate Parentheses++
Letter Combinations of a Phone Number++


===============Palindrome Partitioning===============
136: Palindrome Partitioning

"Difficulty Medium Accepted Rate 22%"
         
Given a string s, partition s such that every substring of the partition is a palindrome.

Example
Given s = "aab", return:
[
["aa","b"],
["a","a","b"]
]
Tags
Backtracking
Depth First Search
Related Problems

(dynamic-programming)Medium
 Palindrome Partitioning II
 21 %
public class Solution {
    public ArrayList<ArrayList<String>> partition(String s) {
        ArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();
        if (s == null) {
            return result;
        }

        ArrayList<String> path = new ArrayList<String>();
        helper(s, path, 0, result);

        return result;
    }

    private boolean isPalindrome(String s) {
        int beg = 0;
        int end = s.length() - 1;
        while (beg < end) {
            if (s.charAt(beg) != s.charAt(end)) {
                return false;
            }

            beg++;
            end--;
        }

        return true;
    }

    private void helper(String s, ArrayList<String> path, int pos,
            ArrayList<ArrayList<String>> result) {
        if (pos == s.length()) {
            result.add(new ArrayList<String>(path));
            return;
        }

        for (int i = pos + 1; i <= s.length(); i++) {
            String prefix = s.substring(pos, i);
            if (!isPalindrome(prefix)) {
                continue;
            }

            path.add(prefix);
            helper(s, path, i, result);
            path.remove(path.size() - 1);
        }
    }
}





------------------------------------------------
 
public class Solution {
    public ArrayList<ArrayList<String>> partition(String s) {
        ArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();
        if (s == null) {
            return result;
        }

        ArrayList<String> path = new ArrayList<String>();
        helper(s, path, 0, result);

        return result;
    }

    private boolean isPalindrome(String s) {
        int beg = 0;
        int end = s.length() - 1;
        while (beg < end) {
            if (s.charAt(beg) != s.charAt(end)) {
                return false;
            }

            beg++;
            end--;
        }

        return true;
    }

    private void helper(String s, ArrayList<String> path, int pos,
            ArrayList<ArrayList<String>> result) {
        if (pos == s.length()) {
            result.add(new ArrayList<String>(path));
            return;
        }

        for (int i = pos; i < s.length(); i++) {
            String prefix = s.substring(pos, i + 1);
            if (!isPalindrome(prefix)) {
                continue;
            }

            path.add(prefix);
            helper(s, path, i + 1, result);
            path.remove(path.size() - 1);
        }
    }
}Regular Expression Matching++
Restore IP Addresses++
Wildcard Matching++


===============Word Ladder II===============
121: Word Ladder II

"Difficulty Hard Accepted Rate 16%"
         
Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:


ExampleGiven:
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]
Return[
["hit","hot","dot","dog","cog"],
["hit","hot","lot","log","cog"]
]
Note
All words have the same length.All words contain only lowercase alphabetic characters.
Tags
Backtracking
Depth First Search
Breadth First Search
Related Problems

(linkedin),(breadth-first-search)Medium
 Word Ladder
 21 %
public class Solution {
    public List<List<String>> findLadders(String start, String end,
            Set<String> dict) {
        List<List<String>> ladders = new ArrayList<List<String>>();
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        Map<String, Integer> distance = new HashMap<String, Integer>();

        dict.add(start);
        dict.add(end);
 
        bfs(map, distance, start, end, dict);
        
        List<String> path = new ArrayList<String>();
        
        dfs(ladders, path, end, start, distance, map);

        return ladders;
    }

    void dfs(List<List<String>> ladders, List<String> path, String crt,
            String start, Map<String, Integer> distance,
            Map<String, List<String>> map) {
        path.add(crt);
        if (crt.equals(start)) {
            Collections.reverse(path);
            ladders.add(new ArrayList<String>(path));
            Collections.reverse(path);
        } else {
            for (String next : map.get(crt)) {
                if (distance.containsKey(next) && distance.get(crt) == distance.get(next) + 1) { 
                    dfs(ladders, path, next, start, distance, map);
                }
            }           
        }
        path.remove(path.size() - 1);
    }

    void bfs(Map<String, List<String>> map, Map<String, Integer> distance,
            String start, String end, Set<String> dict) {
        Queue<String> q = new LinkedList<String>();
        q.offer(start);
        distance.put(start, 0);
        for (String s : dict) {
            map.put(s, new ArrayList<String>());
        }
        
        while (!q.isEmpty()) {
            String crt = q.poll();

            List<String> nextList = expand(crt, dict);
            for (String next : nextList) {
                map.get(next).add(crt);
                if (!distance.containsKey(next)) {
                    distance.put(next, distance.get(crt) + 1);
                    q.offer(next);
                }
            }
        }
    }

    List<String> expand(String crt, Set<String> dict) {
        List<String> expansion = new ArrayList<String>();

        for (int i = 0; i < crt.length(); i++) {
            for (char ch = &#39;a&#39;; ch <= &#39;z&#39;; ch++) {
                if (ch != crt.charAt(i)) {
                    String expanded = crt.substring(0, i) + ch
                            + crt.substring(i + 1);
                    if (dict.contains(expanded)) {
                        expansion.add(expanded);
                    }
                }
            }
        }

        return expansion;
    }
}

Python Version:
class Solution:
    # @param start, a string
    # @param end, a string
    # @param dict, a set of string
    # @return a list of lists of string
    
    def getEntry(self, word, index):
        return word[:index] + word[index + 1:]
        
    def buildIndexes(self, length, dict):
        indexes = []
        for i in range(length):
            index = {}
            for word in dict:
                entry = self.getEntry(word, i)
                words = index.get(entry, [])
                words.append(word)
                index[entry] = words
            indexes.append(index)
        return indexes

    def BFS(self, start, end):
        self.distance = {}
        self.distance[start] = 0
        queue = [start]
        while len(queue) != 0:
            head = queue[0]
            del queue[0]
            for word in self.getNextWord(head):
                if word not in self.distance:
                    self.distance[word] = self.distance[head] + 1
                    queue.append(word)
    
    def DFS(self, curt, target, path):
        if curt == target:
            self.results.append(list(path))
            return
        
        for word in self.getNextWord(curt):
            if self.distance.get(word, -2) + 1 == self.distance[curt]:
                path.append(word)
                self.DFS(word, target, path)
                del path[len(path) - 1]
                
    def getNextWord(self, word):
        for i in range(len(word)):
            entry = self.getEntry(word, i)
            if entry in self.indexes[i]:
                for nextWord in self.indexes[i][entry]:
                    if nextWord != word:
                        yield nextWord
                    
    def findLadders(self, start, end, dict):
        if start is None or end is None or len(start) != len(end):
            return []
        if start not in dict or end not in dict:
            return []
            
        self.dict = dict
        self.indexes = self.buildIndexes(len(start), dict)
        self.BFS(end, start)
        
        self.results = []
        if start in self.distance:
            self.DFS(start, end, [start])
        return self.results

===============Word Search===============
123: Word Search

"Difficulty Medium Accepted Rate 24%"
         
word = "ABCCED", -> returns true,word = "SEE", -> returns true,word = "ABCB", -> returns false.

Example
Given board =
[
"ABCE",
"SFCS",
"ADEE"
]word = "ABCCED", -> returns true,word = "SEE", -> returns true,word = "ABCB", -> returns false.

Tags
Backtracking
Facebook
public class Solution {
    // recursion
    public boolean exist(char[][] board, String word) {
        if(board == null || board.length == 0)
            return false;
        if(word.length() == 0)
            return true;
        
        for(int i = 0; i< board.length; i++){
            for(int j=0; j< board[0].length; j++){
                if(board[i][j] == word.charAt(0)){
                    
                    boolean rst = find(board, i, j, word, 0);
                    if(rst)
                        return true;
                }
            }
        }
        return false;
    }
    
    private boolean find(char[][] board, int i, int j, String word, int start){
        if(start == word.length())
            return true;
        
        if (i < 0 || i>= board.length || 
     j < 0 || j >= board[0].length || board[i][j] != word.charAt(start)){
            return false;
	 }
        
        board[i][j] = &#39;#&#39;; // should remember to mark it
        boolean rst = find(board, i-1, j, word, start+1) 
|| find(board, i, j-1, word, start+1) 
|| find(board, i+1, j, word, start+1) 
|| find(board, i, j+1, word, start+1));
        board[i][j] = word.charAt(start);
        return rst;
    }
}++++++++++++Tag: LinkedIn++++++++++++
Binary Search Tree Iterator++


===============Binary Tree Level Order Traversal===============
69: Binary Tree Level Order Traversal

"Difficulty Medium Accepted Rate 31%"
         
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

Example
Given binary tree {3,9,20,#,#,15,7},3
 / \
920
/\
 15 7 
return its level order traversal as:[
[3],
[9,20],
[15,7]
]Challenge
Challenge 1: Using only 1 queue to implement it.
Challenge 2: Use DFS algorithm to do it.
Tags
Queue
Binary Tree
Breadth First Search
Binary Tree Traversal
Uber
LinkedIn
Facebook
// version 1: BFS
public class Solution {
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        ArrayList result = new ArrayList();

        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            ArrayList<Integer> level = new ArrayList<Integer>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode head = queue.poll();
                level.add(head.val);
                if (head.left != null) {
                    queue.offer(head.left);
                }
                if (head.right != null) {
                    queue.offer(head.right);
                }
            }
            result.add(level);
        }

        return result;
    }
}


// version 2:  DFS
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Level order a list of lists of integer
     */
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        ArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();
        
        if (root == null) {
            return results;
        }
        
        int maxLevel = 0;
        while (true) {
            ArrayList<Integer> level = new ArrayList<Integer>();
            dfs(root, level, 0, maxLevel);
            if (level.size() == 0) {
                break;
            }
            
            results.add(level);
            maxLevel++;
        }
        
        return results;
    }
    
    private void dfs(TreeNode root,
                     ArrayList<Integer> level,
                     int curtLevel,
                     int maxLevel) {
        if (root == null || curtLevel > maxLevel) {
            return;
        }
        
        if (curtLevel == maxLevel) {
            level.add(root.val);
            return;
        }
        
        dfs(root.left, level, curtLevel + 1, maxLevel);
        dfs(root.right, level, curtLevel + 1, maxLevel);
    }
}


// version 3: BFS. two queues
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Level order a list of lists of integer
     */
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        if (root == null) {
            return result;
        }
        
        ArrayList<TreeNode> Q1 = new ArrayList<TreeNode>();
        ArrayList<TreeNode> Q2 = new ArrayList<TreeNode>();

        Q1.add(root);
        while (Q1.size() != 0) {
            ArrayList<Integer> level = new ArrayList<Integer>();
            Q2.clear();
            for (int i = 0; i < Q1.size(); i++) {
                TreeNode node = Q1.get(i);
                level.add(node.val);
                if (node.left != null) {
                    Q2.add(node.left);
                }
                if (node.right != null) {
                    Q2.add(node.right);
                }
            }
            
            // swap q1 and q2
            ArrayList<TreeNode> temp = Q1;
            Q1 = Q2;
            Q2 = temp;
            
            // add to result
            result.add(level);
        }
        
        return result;
    }
}

// version 4: BFS, queue with dummy node
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Level order a list of lists of integer
     */
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        if (root == null) {
            return result;
        }
        
        Queue<TreeNode> Q = new LinkedList<TreeNode>();
        Q.offer(root);
        Q.offer(null); // dummy node
        
        ArrayList<Integer> level = new ArrayList<Integer>();
        while (!Q.isEmpty()) {
            TreeNode node = Q.poll();
            if (node == null) {
                if (level.size() == 0) {
                    break;
                }
                result.add(level);
                level = new ArrayList<Integer>();
                Q.offer(null); // add a new dummy node
                continue;
            }
            
            level.add(node.val);
            if (node.left != null) {
                Q.offer(node.left);
            }
            if (node.right != null) {
                Q.offer(node.right);
            }
        }
        
        return result;
    }
}

===============Binary Tree Zigzag Level Order Traversal===============
71: Binary Tree Zigzag Level Order Traversal

"Difficulty Medium Accepted Rate 27%"
         


Example
Given binary tree {3,9,20,#,#,15,7},3
 / \
920
/\
 15 7 
return its zigzag level order traversal as:[
[3],
[20,9],
[15,7]
]

Tags
LinkedIn
Queue
Binary Tree
Binary Tree Traversal
Breadth First Search
public class Solution {
    public ArrayList<ArrayList<Integer>> zigzagLevelOrder(TreeNode root) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();

        if (root == null) {
            return result;
        }

        Stack<TreeNode> currLevel = new Stack<TreeNode>();
        Stack<TreeNode> nextLevel = new Stack<TreeNode>();
        Stack<TreeNode> tmp;
        
        currLevel.push(root);
        boolean normalOrder = true;

        while (!currLevel.isEmpty()) {
            ArrayList<Integer> currLevelResult = new ArrayList<Integer>();

            while (!currLevel.isEmpty()) {
                TreeNode node = currLevel.pop();
                currLevelResult.add(node.val);

                if (normalOrder) {
                    if (node.left != null) {
                        nextLevel.push(node.left);
                    }
                    if (node.right != null) {
                        nextLevel.push(node.right);
                    }
                } else {
                    if (node.right != null) {
                        nextLevel.push(node.right);
                    }
                    if (node.left != null) {
                        nextLevel.push(node.left);
                    }
                }
            }

            result.add(currLevelResult);
            tmp = currLevel;
            currLevel = nextLevel;
            nextLevel = tmp;
            normalOrder = !normalOrder;
        }

        return result;

    }
}

===============Evaluate Reverse Polish Notation===============
424: Evaluate Reverse Polish Notation

"Difficulty Medium Accepted Rate 25%"
         
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Example
["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9
["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6
Tags
LinkedIn
Stack
Related Problems
3
(lintcode-copyright),(stack)Hard
 Convert Expression to Reverse Polish Notation
 24 %
public class Solution {
    public int evalRPN(String[] tokens) {
        Stack<Integer> s = new Stack<Integer>();
        String operators = "+-*/";
        for(String token : tokens){
            if(!operators.contains(token)){
                s.push(Integer.valueOf(token));
                continue;
            }

            int a = s.pop();
            int b = s.pop();
            if(token.equals("+")) {
                s.push(b + a);
            } else if(token.equals("-")) {
                s.push(b - a);
            } else if(token.equals("*")) {
                s.push(b * a);
            } else {
                s.push(b / a);
            }
        }
        return s.pop();
    }
}

===============House Robber===============
392: House Robber

"Difficulty Medium Accepted Rate 31%"
         
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Example
Given [3, 8, 4], return 8.Challenge
O(n) time and O(1) memory.
Tags
LinkedIn
Dynamic Programming
Airbnb
Related Problems
0
(enumeration),(mathematics),(non-recursion)Naive
 Fibonacci
 26 %
 
1
(dynamic-programming)Easy
 Climbing Stairs
 34 %
public class Solution {
    /**
     * @param A: An array of non-negative integers.
     * return: The maximum amount of money you can rob tonight
     */
    //方法一：
    public long houseRobber(int[] A) {
        // write your code here
        int n = A.length;
        long []res = new long[A.length];
        long ans = 0;
        if(n==0)
            return 0;
        if(n >= 1) 
            res[0] = A[0];
        if(n >= 2)
            res[1] = Math.max(A[0], A[1]);
        if(n >= 3)
            res[2] = Math.max(A[0]+A[2], A[1]);
        if(n > 2){
            for(int i = 3; i < n; i++) {
                res[i] = Math.max(res[i-3], res[i-2])+ A[i];
            }
        }
        for(int i =0 ; i < n; i++){
            ans = Math.max(ans,res[i]);
        }
        return ans;
    }
    
   // 方法二：
    //---------------------------------------------------
    public long houseRobber2(int[] A) {
        // write your code here
        int n = A.length;
        long []res = new long[3];
        long ans = 0;
        if(n==0)
            return 0;
        if(n >= 1) {
            res[0] = A[0];
            ans = Math.max(ans, res[0]);
        }
        if(n >= 2) {
            res[1] = Math.max(A[0], A[1]);
            ans = Math.max(ans, res[1]);
        }
        if(n >= 3) {
            res[2] = Math.max(A[0]+A[2], A[1]);
            ans = Math.max(ans, res[2]);
        }
        if(n > 2){
            for(int i = 3; i < n; i++) {
                res[i%3] = Math.max(res[(i-3)%3], res[(i-2)%3])+ A[i];
                ans = Math.max(ans, res[i%3]);
            }
        } 
        return ans;
    }   
}Insert Interval++
Lowest Common Ancestor++


===============Max Points on a Line===============
186: Max Points on a Line

"Difficulty Medium Accepted Rate 13%"
         
Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.

Example
Given 4 points: (1,2), (3,6), (0,0), (1,3).
The maximum number is 3.

Tags
LinkedIn
Hash Table
Mathematics
public class Solution {
    public  int maxPoints(Point[] points) {
        if (points == null || points.length == 0) {
            return 0;
        }  

        HashMap<Double, Integer> map=new HashMap<Double, Integer>();
        int max = 1;

        for(int i = 0 ; i < points.length; i++) {
            // shared point changed, map should be cleared and server the new point
            map.clear();

            // maybe all points contained in the list are same points,and same points&#39; k is 
            // represented by Integer.MIN_VALUE
            map.put((double)Integer.MIN_VALUE, 1);

            int dup = 0;
            for(int j = i + 1; j < points.length; j++) {
                if (points[j].x == points[i].x && points[j].y == points[i].y) {
                    dup++;
                    continue;
                }

                // look 0.0+(double)(points[j].y-points[i].y)/(double)(points[j].x-points[i].x)
                // because (double)0/-1 is -0.0, so we should use 0.0+-0.0=0.0 to solve 0.0 !=-0.0
                // problem

                // if the line through two points are parallel to y coordinator, then K(slop) is 
                // Integer.MAX_VALUE
                double key=points[j].x - points[i].x == 0 ? 
                    Integer.MAX_VALUE :
                    0.0 + (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x);

                if (map.containsKey(key)) {
                    map.put(key, map.get(key) + 1);
                } else {
                    map.put(key, 2);
                }
            }

            for (int temp: map.values()) {
                // duplicate may exist
                if (temp + dup > max) {
                    max = temp + dup;
                }
            }

        }
        return max;
    }
}


// version 2:
/**
 * Definition for a point.
 * class Point {
 *     int x;
 *     int y;
 *     Point() { x = 0; y = 0; }
 *     Point(int a, int b) { x = a; y = b; }
 * }
 */
class Line {
    public double a, b, c;
    public Line(double a, double b, double c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
    
    public Line(int x1, int y1, int x2, int y2) {
        if (x1 == x2) {
            if (x1 == 0) {
                a = 1;
                b = 0;
                c = 0;
            } else {
                a = 1.0 / x1;
                b = 0;
                c = 1;
            }
        } else if (y1 == y2) {
            if (y1 == 0) {
                a = 0;
                b = 1;
                c = 0;
            } else {
                a = 0;
                b = 1.0 / y1;
                c = 1;
            }
        } else {
            if (x1 * y2 == x2 * y1) {
                a = 1;
                b = - 1.0 * (y1 - y2) / (x1 - x2);
                c = 0;
           } else {
                a = 1.0 * (y1 - y2) / (x2 * y1 - x1 * y2);
                b = 1.0 * (x1 - x2) / (x1 * y2 - x2 * y1);
                c = 1;
            }
        }
    }
    
    public String toString() {
        return Double.toString(a) + " " + Double.toString(b) + " " + Double.toString(c);
    }
}

public class Solution {
    
    public int maxPoints(Point[] points) {
        if (points.length < 2) {
            return points.length;
        }
        
        HashMap<String, Integer> hash = new HashMap<String, Integer>();
        for (int i = 0; i < points.length; i++) {
            for (int j = i + 1; j < points.length; j++) {
                Line line = new Line(points[i].x, points[i].y,
                                     points[j].x, points[j].y);
                String key = line.toString();
                if (hash.containsKey(key)) {
                    hash.put(key, hash.get(key) + 1);
                } else {
                    hash.put(key, 1);
                }
            }
        }
        
        int max = 0;
        String maxKey = "";
        for (String key: hash.keySet()) {
            if (hash.get(key) > max) {
                max = hash.get(key);
                maxKey = key;
                
            }
        }
        String[] params = maxKey.split(" ");
        double a = Double.parseDouble(params[0]);
        double b = Double.parseDouble(params[1]);
        double c = Double.parseDouble(params[2]);
        
        int count = 0;
        for (int i = 0; i < points.length; i++) {
            if (Math.abs(a * points[i].x + b * points[i].y - c) < 1e-6) {
                count++;
            }
        }
        return count;
    }
}

===============Maximum Product Subarray===============
191: Maximum Product Subarray

"Difficulty Medium Accepted Rate 27%"
         
Find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example
For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6.

Tags
LinkedIn
Dynamic Programming
Subarray
Related Problems

(greedy),(enumeration),(array),(facebook),(uber)Medium
 Best Time to Buy and Sell Stock
 41 %
 
2
(greedy),(enumeration),(forward-backward-traversal),(lintcode-copyright),(subarray),(array)Medium
 Maximum Subarray Difference
 23 %
 
1
(greedy),(lintcode-copyright),(subarray),(array)Easy
 Minimum Subarray
 37 %
 
2
(greedy),(enumeration),(forward-backward-traversal),(lintcode-copyright),(subarray),(array)Medium
 Maximum Subarray II
 23 %
// LeetCode version:
public class Solution {
    /**
     * @param nums: an array of integers
     * @return: an integer
     */
    public int maxProduct(List<Integer> nums) {
        int[] max = new int[nums.size()];
        int[] min = new int[nums.size()];
        
        min[0] = max[0] = nums.get(0);
        int result = nums.get(0);
        for (int i = 1; i < nums.size(); i++) {
            min[i] = max[i] = nums.get(i);
            if (nums.get(i) > 0) {
                max[i] = Math.max(max[i], max[i - 1] * nums.get(i));
                min[i] = Math.min(min[i], min[i - 1] * nums.get(i));
            } else if (nums.get(i) < 0) {
                max[i] = Math.max(max[i], min[i - 1] * nums.get(i));
                min[i] = Math.min(min[i], max[i - 1] * nums.get(i));
            }
            
            result = Math.max(result, max[i]);
        }
        
        return result;
    }
}

// LintCode Version:
public class Solution {
    /**
     * @param nums: an array of integers
     * @return: an integer
     */
    public int maxProduct(int[] nums) {
        int[] max = new int[nums.length];
        int[] min = new int[nums.length];
        
        min[0] = max[0] = nums[0];
        int result = nums[0];
        for (int i = 1; i < nums.length; i++) {
            min[i] = max[i] = nums[i];
            if (nums[i] > 0) {
                max[i] = Math.max(max[i], max[i - 1] * nums[i]);
                min[i] = Math.min(min[i], min[i - 1] * nums[i]);
            } else if (nums[i] < 0) {
                max[i] = Math.max(max[i], min[i - 1] * nums[i]);
                min[i] = Math.min(min[i], max[i - 1] * nums[i]);
            }
            
            result = Math.max(result, max[i]);
        }
        
        return result;
    }
}Maximum Subarray++


===============Merge Intervals===============
156: Merge Intervals

"Difficulty Easy Accepted Rate 19%"
         
Given a collection of intervals, merge all overlapping intervals.

Example
Given intervals => merged intervals:
[ [
[1, 3], [1, 6],
[2, 6],=> [8, 10],
[8, 10],[15, 18]
[15, 18]]
]
Challenge
O(n log n) time and O(1) extra space.
Tags
LinkedIn
Sort
Array
Google
Related Problems

(lintcode-copyright),(array),(interval)Medium
 Number of Airplanes in the Sky
 21 %
 
1
(basic-implementation),(linkedin),(google)Easy
 Insert Interval
 21 %
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public ArrayList<Interval> merge(ArrayList<Interval> intervals) {
        if (intervals == null || intervals.size() <= 1) {
            return intervals;
        }
        
        Collections.sort(intervals, new IntervalComparator());       
  
        ArrayList<Interval> result = new ArrayList<Interval>();
        Interval last = intervals.get(0);
        for (int i = 1; i < intervals.size(); i++) {
            Interval curt = intervals.get(i);
            if (curt.start <= last.end ){
                last.end = Math.max(last.end, curt.end);
            }else{
                result.add(last);
                last = curt;
            }
        }
        
        result.add(last);
        return result;
    }
    
    
    private class IntervalComparator implements Comparator<Interval> {
        public int compare(Interval a, Interval b) {
            return a.start - b.start;
        }
    }

}

===============Merge k Sorted Lists===============
104: Merge k Sorted Lists

"Difficulty Medium Accepted Rate 26%"
         
Merge k sorted linked lists and return it as one sorted list.

Example
Given lists:
[
2->4->null,
null,
-1->null
],return -1->2->4->null.

Tags
Linked List
Divide and Conquer
Heap
Priority Queue
Uber
Google
Twitter
LinkedIn
Airbnb
Facebook
Related Problems
1
(sorted-array),(array)Easy
 Merge Sorted Array II
 35 %
 
2
(lintcode-copyright),(priority-queue)Medium
 Ugly Number
 20 %
// version 1: Divide & Conquer
/**
 * Definition for ListNode.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int val) {
 *         this.val = val;
 *         this.next = null;
 *     }
 * }
 */ 
public class Solution {
    /**
     * @param lists: a list of ListNode
     * @return: The head of one sorted list.
     */
    public ListNode mergeKLists(List<ListNode> lists) {
        if (lists.size() == 0) {
            return null;
        }
        return mergeHelper(lists, 0, lists.size() - 1);
    }
    
    private ListNode mergeHelper(List<ListNode> lists, int start, int end) {
        if (start == end) {
            return lists.get(start);
        }
        
        int mid = start + (end - start) / 2;
        ListNode left = mergeHelper(lists, start, mid);
        ListNode right = mergeHelper(lists, mid + 1, end);
        return mergeTwoLists(left, right);
    }
    
    private ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                tail.next = list1;
                tail = list1;
                list1 = list1.next;
            } else {
                tail.next = list2;
                tail = list2;
                list2 = list2.next;
            }
        }
        if (list1 != null) {
            tail.next = list1;
        } else {
            tail.next = list2;
        }
        
        return dummy.next;
    }
}

// version 2: Heap
public class Solution {
    private Comparator<ListNode> ListNodeComparator = new Comparator<ListNode>() {
        public int compare(ListNode left, ListNode right) {
            if (left == null) {
                return 1;
            } else if (right == null) {
                return -1;
            }
            return left.val - right.val;
        }
    };
    
    public ListNode mergeKLists(ArrayList<ListNode> lists) {
        if (lists == null || lists.size() == 0) {
            return null;
        }
        
        Queue<ListNode> heap = new PriorityQueue<ListNode>(lists.size(), ListNodeComparator);
        for (int i = 0; i < lists.size(); i++) {
            if (lists.get(i) != null) {
                heap.add(lists.get(i));
            }
        }
        
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        while (!heap.isEmpty()) {
            ListNode head = heap.poll();
            tail.next = head;
            tail = head;
            if (head.next != null) {
                heap.add(head.next);
            }
        }
        return dummy.next;
    }
}

// Version 3: merge two by two
/**
 * Definition for ListNode.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int val) {
 *         this.val = val;
 *         this.next = null;
 *     }
 * }
 */ 
public class Solution {
    /**
     * @param lists: a list of ListNode
     * @return: The head of one sorted list.
     */
    public ListNode mergeKLists(List<ListNode> lists) {  
        if (lists == null || lists.size() == 0) {
            return null;
        }
        
        while (lists.size() > 1) {
            List<ListNode> new_lists = new ArrayList<ListNode>();
            for (int i = 0; i + 1 < lists.size(); i += 2) {
                ListNode merged_list = merge(lists.get(i), lists.get(i+1));
                new_lists.add(merged_list);
            }
            if (lists.size() % 2 == 1) {
                new_lists.add(lists.get(lists.size() - 1));
            }
            lists = new_lists;
        }
        
        return lists.get(0);
    }
    
    private ListNode merge(ListNode a, ListNode b) {
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        while (a != null && b != null) {
            if (a.val < b.val) {
                tail.next = a;
                a = a.next;
            } else {
                tail.next = b;
                b = b.next;
            }
            tail = tail.next;
        }
        
        if (a != null) {
            tail.next = a;
        } else {
            tail.next = b;
        }
        
        return dummy.next;
    }
}

===============Merge Two Sorted Lists===============
165: Merge Two Sorted Lists

"Difficulty Easy Accepted Rate 37%"
         
Merge two sorted (ascending) linked lists and return it as a new sorted list. The new sorted list should be made by splicing together the nodes of the two lists and sorted in ascending order.

Example
Given 1->3->8->11->15->null, 2->null , return 1->2->3->8->11->15->null.

Tags
LinkedIn
Linked List
Related Problems
1
(sorted-array),(array)Easy
 Merge Sorted Array II
 35 %
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode lastNode = dummy;
        
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                lastNode.next = l1;
                l1 = l1.next;
            } else {
                lastNode.next = l2;
                l2 = l2.next;
            }
            lastNode = lastNode.next;
        }
        
        if (l1 != null) {
            lastNode.next = l1;
        } else {
            lastNode.next = l2;
        }
        
        return dummy.next;
    }
}

===============Minimum Window Substring===============
32: Minimum Window Substring

"Difficulty Medium Accepted Rate 20%"
         
Given a string source and a string target, find the minimum window in source which will contain all the characters in target.

Example
For source = "ADOBECODEBANC", target = "ABC", the minimum window is "BANC"Note
If there is no such window in source that covers all characters in target, return the emtpy string "".
If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in source.
Challenge
Can you do it in time complexity O(n) ?
Clarification
Should the characters in minimum window has the same order in target?Not necessary.

Tags
LinkedIn
Hash Table
Facebook
public class Solution {
    //方法一:
    int initTargetHash(int []targethash, String Target) {
        int targetnum =0 ;
        for (char ch : Target.toCharArray()) {
            targetnum++;
            targethash[ch]++;
        }
        return targetnum;
    }
    boolean valid(int []sourcehash, int []targethash) {
        
        for(int i = 0; i < 256; i++) {
            if(targethash[i] > sourcehash[i])    
                return false;
        }
        return true;
    }
    public String minWindow(String Source, String Target) {
        // queueing the position that matches the char in T
        int ans = Integer.MAX_VALUE;
        String minStr = "";
        
        int[] sourcehash = new int[256];
        int[] targethash = new int[256];
        
        initTargetHash(targethash, Target);
        int j = 0, i = 0;
        for(i = 0; i < Source.length(); i++) {
            
            while( !valid(sourcehash, targethash) && j < Source.length()  ) {
                sourcehash[Source.charAt(j)]++;
                if(j < Source.length() )
                    j++;
                else 
                    break;
            }
            if(valid(sourcehash, targethash) ){
                if(ans > j - i ) {
                    ans = Math.min(ans, j - i );
                    minStr = Source.substring(i, j );
                }
            }
            sourcehash[Source.charAt(i)]--;
        }
        return minStr;
    }
    方法二:
    public class Solution {
    int initTargetHash(int []targethash, String Target) {
        int targetnum =0 ;
        for (char ch : Target.toCharArray()) {
            targetnum++;
            targethash[ch]++;
        }
        return targetnum;
    }
    public String minWindow(String Source, String Target) {
        // queueing the position that matches the char in T
        int ans = Integer.MAX_VALUE;
        String minStr = "";
        
        int[] targethash = new int[256];
        
        int targetnum = initTargetHash(targethash, Target);
        int sourcenum = 0;
        int j = 0, i = 0;
        for(i = 0; i < Source.length(); i++) {
            if(targethash[Source.charAt(i)] > 0)
                sourcenum++;
            
            targethash[Source.charAt(i)]--;
            while(sourcenum>=targetnum) {
                if(ans > i - j + 1) {
                    ans = Math.min(ans, i - j + 1);
                    minStr = Source.substring(j, i + 1);
                }
                targethash[Source.charAt(j)]++;
                if(targethash[Source.charAt(j)] > 0)
                    sourcenum--;
                j ++;
            }
        }
        return minStr;
    }
    
}

===============Permutations II===============
16: Permutations II

"Difficulty Medium Accepted Rate 22%"
         
Given a list of numbers with duplicate number in it. Find all unique permutations.

Example
For numbers [1,2,2] the unique permutations are:
[
[1,2,2],
[2,1,2],
[2,2,1]
]
Challenge
Using recursion to do it is acceptable. If you can do it without recursion, that would be great!
Tags
LinkedIn
Recursion
Depth First Search
Related Problems

(permutation),(array)Medium
 Next Permutation II
 32 %
 
2
(permutation),(array)Medium
 Permutation Sequence
 25 %
 
2
(lintcode-copyright),(permutation)Medium
 Next Permutation
 23 %
 
2
(linkedin),(recursion)Medium
 Permutations
 24 %
public class Solution {
    public ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        if(num == null || num.length == 0)
            return result;
        ArrayList<Integer> list = new ArrayList<Integer>();
        int[] visited = new int[num.length];
        
        Arrays.sort(num);
        helper(result, list, visited, num);
        return result;
    }
    
    public void helper(ArrayList<ArrayList<Integer>> result, ArrayList<Integer> list, int[] visited, int[] num) {
        if(list.size() == num.length) {
            result.add(new ArrayList<Integer>(list));
            return;
        }
        
        for(int i = 0; i < num.length; i++) {
            if (visited[i] == 1 || (i != 0 && num[i] == num[i - 1] && visited[i - 1] == 0)){
                continue;
        /*
            上面的判断其实并不影响最终结果，目的是为了让dfs能更快
            上面这一连串判断条件，重点在于要能理解!visited.contains(i-1)
            要理解这个，首先要明白i作为数组内序号，i是唯一的
            给出一个排好序的数组，[1,2,2]
            第一层递归            第二层递归            第三层递归
            [1]                    [1,2]                [1,2,2]
            序号:[0]                 [0,1]            [0,1,2]
            这种都是OK的，但当第二层递归i扫到的是第二个"2"，情况就不一样了
            [1]                    [1,2]                [1,2,2]            
            序号:[0]                [0,2]                [0,2,1]
            所以这边判断的时候!visited.contains(0)就变成了true，不会再继续递归下去，跳出循环
            步主要就是为了去除连续重复存在的，很神奇反正 = =||
        */
            }
            visited[i] = 1;
            list.add(num[i]);
            helper(result, list, visited, num);
            list.remove(list.size() - 1);
            visited[i] = 0;
        }
    }    
}

===============Permutations===============
15: Permutations

"Difficulty Medium Accepted Rate 24%"
         
Given a list of numbers, return all possible permutations.

Example
For nums = [1,2,3], the permutations are:
[
[1,2,3],
[1,3,2],
[2,1,3],
[2,3,1],
[3,1,2],
[3,2,1]
]
Challenge
Do it without recursion.
Tags
LinkedIn
Recursion
Related Problems

(recursion)Medium
 Print Numbers by Recursion
 23 %
 
2
(permutation),(array)Medium
 Permutation Sequence
 25 %
 
2
(linkedin),(recursion),(depth-first-search)Medium
 Permutations II
 22 %
public class Solution {
    public ArrayList<ArrayList<Integer>> permute(int[] num) {
         ArrayList<ArrayList<Integer>> rst = new ArrayList<ArrayList<Integer>>();
         if (num == null || num.length == 0) {
             return rst; 
         }

         ArrayList<Integer> list = new ArrayList<Integer>();
         helper(rst, list, num);
         return rst;
    }
    
    public void helper(ArrayList<ArrayList<Integer>> rst, ArrayList<Integer> list, int[] num){
        if(list.size() == num.length) {
            rst.add(new ArrayList<Integer>(list));
            return;
        }
        
        for(int i = 0; i<num.length; i++){
            if(list.contains(num[i])){
                continue;
            }
            list.add(num[i]);
            helper(rst, list, num);
            list.remove(list.size() - 1);
        }
        
    }
}

// Non-Recursion

class Solution {
    /**
     * @param nums: A list of integers.
     * @return: A list of permutations.
     */
    public ArrayList<ArrayList<Integer>> permute(ArrayList<Integer> nums) {
        ArrayList<ArrayList<Integer>> permutations
             = new ArrayList<ArrayList<Integer>>();
        if (nums == null || nums.size() == 0) {
            return permutations;
        }
        
        int n = nums.size();
        ArrayList<Integer> stack = new ArrayList<Integer>();
        
        stack.add(-1);
        while (stack.size() != 0) {
            Integer last = stack.get(stack.size() - 1);
            stack.remove(stack.size() - 1);
            
            // increase the last number
            int next = -1;
            for (int i = last + 1; i < n; i++) {
                if (!stack.contains(i)) {
                    next = i;
                    break;
                }
            }
            if (next == -1) {
                continue;
            }
            
            // generate the next permutation
            stack.add(next);
            for (int i = 0; i < n; i++) {
                if (!stack.contains(i)) {
                    stack.add(i);
                }
            }
            
            // copy to permutations set
            ArrayList<Integer> permutation = new ArrayList<Integer>();
            for (int i = 0; i < n; i++) {
                permutation.add(nums.get(stack.get(i)));
            }
            permutations.add(permutation);
        }
        
        return permutations;
    }
}Search in Rotated Sorted Array++
Valid Number++


===============Word Ladder===============
120: Word Ladder

"Difficulty Medium Accepted Rate 21%"
         
Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:


ExampleGiven:
start = "hit"
end = "cog"
dict = ["hot","dot","dog","lot","log"]
As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.
Note
Return 0 if there is no such transformation sequence.All words have the same length.All words contain only lowercase alphabetic characters.
Tags
LinkedIn
Breadth First Search
Related Problems
3
(backtracking),(depth-first-search),(breadth-first-search)Hard
 Word Ladder II
 16 %
public class Solution {
    public int ladderLength(String start, String end, Set<String> dict) {
        if (dict == null || dict.size() == 0) {
            return 0;
        }

        HashSet<String> hash = new HashSet<String>();
        Queue<String> queue = new LinkedList<String>();
        queue.offer(start);
        hash.add(start);
        
        int length = 1;
        while(!queue.isEmpty()) {
            length++;
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                String word = queue.poll();
                for (String nextWord: getNextWords(word, dict)) {
                    if (hash.contains(nextWord)) {
                        continue;
                    }
                    if (nextWord.equals(end)) {
                        return length;
                    }
                    
                    hash.add(nextWord);
                    queue.offer(nextWord);
                }
            }
        }
        return 0;
    }

    // replace character of a string at given index to a given character
    // return a new string
    private String replace(String s, int index, char c) {
        char[] chars = s.toCharArray();
        chars[index] = c;
        return new String(chars);
    }
    
    // get connections with given word.
    // for example, given word = &#39;hot&#39;, dict = {&#39;hot&#39;, &#39;hit&#39;, &#39;hog&#39;}
    // it will return [&#39;hit&#39;, &#39;hog&#39;]
    private ArrayList<String> getNextWords(String word, Set<String> dict) {
        ArrayList<String> nextWords = new ArrayList<String>();
        for (char c = &#39;a&#39;; c <= &#39;z&#39;; c++) {
            for (int i = 0; i < word.length(); i++) {
                if (c == word.charAt(i)) {
                    continue;
                }
                String nextWord = replace(word, i, c);
                if (dict.contains(nextWord)) {
                    nextWords.add(nextWord);
                }
            }
        }
        return nextWords;
    }
}++++++++++++Tag: Divide and Conquer++++++++++++
Balanced Binary Tree++


===============Binary Tree Maximum Path Sum===============
94: Binary Tree Maximum Path Sum

"Difficulty Medium Accepted Rate 23%"
         
Given a binary tree, find the maximum path sum.

Example
Given the below binary tree:
1
 / \
2 3return 6.

Tags
Divide and Conquer
Dynamic Programming
Recursion
Related Problems
1
(dynamic-programming)Easy
 Minimum Path Sum 
 33 %
public class Solution {
    private class ResultType {
        // singlePath: 从root往下走到任意点的最大路径，这条路径可以不包含任何点
        // maxPath: 从树中任意到任意点的最大路径，这条路径至少包含一个点
        int singlePath, maxPath; 
        ResultType(int singlePath, int maxPath) {
            this.singlePath = singlePath;
            this.maxPath = maxPath;
        }
    }

    private ResultType helper(TreeNode root) {
        if (root == null) {
            return new ResultType(0, Integer.MIN_VALUE);
        }
        // Divide
        ResultType left = helper(root.left);
        ResultType right = helper(root.right);

        // Conquer
        int singlePath = Math.max(left.singlePath, right.singlePath) + root.val;
        singlePath = Math.max(singlePath, 0);

        int maxPath = Math.max(left.maxPath, right.maxPath);
        maxPath = Math.max(maxPath, left.singlePath + right.singlePath + root.val);

        return new ResultType(singlePath, maxPath);
    }

    public int maxPathSum(TreeNode root) {
        ResultType result = helper(root);
        return result.maxPath;
    }
}

===============Fast Power===============
140: Fast Power

"Difficulty Medium Accepted Rate 20%"
         
Calculate the an % b where a, b and n are all 32bit integers.

Example
For 231 % 3 = 2
For 1001000 % 1000 = 0Challenge
O(logn)
Tags
Divide and Conquer
Related Problems

(binary-search),(linkedin),(divide-and-conquer),(mathematics),(facebook)Medium
 Pow(x, n) 
 36 %
class Solution {
    /*
     * @param a, b, n: 32bit integers
     * @return: An integer
     */
    public int fastPower(int a, int b, int n) {
        if (n == 1) {
            return a % b;
        }
        if (n == 0) {
            return 1 % b;
        }
        
        long product = fastPower(a, b, n / 2);
        product = (product * product) % b;
        if (n % 2 == 1) {
            product = (product * a) % b;
        }
        return (int) product;
    }
};Find Minimum in Rotated Sorted Array II++


===============Maximum Depth of Binary Tree===============
97: Maximum Depth of Binary Tree

"Difficulty Easy Accepted Rate 54%"
         
Given a binary tree, find its maximum depth.

Example
Given a binary tree as follow:
1
 / \ 
2 3
 / \
4 5The maximum depth is 3.

Tags
Divide and Conquer
Recursion
Binary Tree
Uber
Related Problems
1
(binary-tree),(depth-first-search)Easy
 Minimum Depth of Binary Tree
 31 %
public class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
}

// version 2: Traverse

/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: An integer.
     */
    private int depth;
    
    public int maxDepth(TreeNode root) {
        depth = 0;
        helper(root, 1);
        
        return depth;
    }
    
    private void helper(TreeNode node, int curtDepth) {
        if (node == null) {
            return;
        }
        
        if (curtDepth > depth) {
            depth = curtDepth;
        }
        
        helper(node.left, curtDepth + 1);
        helper(node.right, curtDepth + 1);
    }
}Median of two Sorted Arrays++
Merge k Sorted Lists++


===============Validate Binary Search Tree===============
95: Validate Binary Search Tree

"Difficulty Medium Accepted Rate 21%"
         
Given a binary tree, determine if it is a valid binary search tree (BST).

Example
An example:
2
 / \
1 4
 / \
3 5The above binary tree is serialized as {2,1,4,#,#,3,5} (in level order).

Tags
Divide and Conquer
Recursion
Binary Search Tree
Binary Tree
Related Problems

(binary-search),(divide-and-conquer),(recursion)Medium
 Balanced Binary Tree 
 39 %
// version 1 Traverse
public class Solution {
    private int lastVal = Integer.MIN_VALUE;
    private boolean firstNode = true;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        if (!isValidBST(root.left)) {
            return false;
        }
        if (!firstNode && lastVal >= root.val) {
            return false;
        }
        firstNode = false;
        lastVal = root.val;
        if (!isValidBST(root.right)) {
            return false;
        }
        return true;
    }
}


// version 2  Divide and Conquer
class ResultType {
    boolean is_bst;
    int maxValue, minValue;
    
    ResultType(boolean is_bst, int maxValue, int minValue) {
        this.is_bst = is_bst;
        this.maxValue = maxValue;
        this.minValue = minValue;
    }
}

public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: True if the binary tree is BST, or false
     */
    public boolean isValidBST(TreeNode root) {
        ResultType r = validateHelper(root);
        return r.is_bst;
    }
    
    private ResultType validateHelper(TreeNode root) {
        if (root == null) {
            return new ResultType(true, Integer.MIN_VALUE, Integer.MAX_VALUE);
        }
        
        ResultType left = validateHelper(root.left);
        ResultType right = validateHelper(root.right);
        
        if (!left.is_bst || !right.is_bst) {
            // if is_bst is false then minValue and maxValue are useless
            return new ResultType(false, 0, 0);
        }
        
        if (root.left != null && left.maxValue >= root.val || 
              root.right != null && right.minValue <= root.val) {
            return new ResultType(false, 0, 0);
        }
        
        return new ResultType(true,
                              Math.max(root.val, right.maxValue),
                              Math.min(root.val, left.minValue));
    }
}++++++++++++Tag: Permutation++++++++++++
Next Permutation++


===============Permutation Sequence===============
388: Permutation Sequence

"Difficulty Medium Accepted Rate 25%"
         
Given n and k, return the k-th permutation sequence.

Example
For n = 3, all permutations are listed as follows:
"123"
"132"
"213"
"231"
"312"
"321"If k = 4, the fourth permutation is "231"Note
n will be between 1 and 9 inclusive.
Challenge
O(n*k) in time complexity is easy, can you do it in O(n^2) or less?
Tags
Permutation
Array
Related Problems

(lintcode-copyright),(permutation)Medium
 Next Permutation
 23 %
 
2
(lintcode-copyright),(permutation)Medium
 Previous Permutation
 25 %
 
2
(linkedin),(recursion),(depth-first-search)Medium
 Permutations II
 22 %
 
2
(linkedin),(recursion)Medium
 Permutations
 24 %
public class Solution {

    public String getPermutation(int n, int k) {
        StringBuilder sb = new StringBuilder();
        boolean[] used = new boolean[n];

        k = k - 1;
        int factor = 1;
        for (int i = 1; i < n; i++) {
            factor *= i;
        }

        for (int i = 0; i < n; i++) {
            int index = k / factor;
            k = k % factor;
            for (int j = 0; j < n; j++) {
                if (used[j] == false) {
                    if (index == 0) {
                        used[j] = true;
                        sb.append((char) (&#39;0&#39; + j + 1));
                        break;
                    } else {
                        index--;
                    }
                }
            }
            if (i < n - 1) {
                factor = factor / (n - 1 - i);
            }
        }

        return sb.toString();
    }
}Previous Permutation++
++++++++++++Tag: Longest Common Subsequence++++++++++++


===============Interleaving String===============
29: Interleaving String

"Difficulty Medium Accepted Rate 25%"
         
Given three strings: s1, s2, s3, determine whether s3 is formed by the interleaving of s1 and s2.

Example
For s1 = "aabcc", s2 = "dbbca"When s3 = "aadbbcbcac", return true.
When s3 = "aadbbbaccc", return false.
Challenge
O(n2) time or better
Tags
Longest Common Subsequence
Dynamic Programming
Related Problems

(string),(dynamic-programming)Medium
 Distinct Subsequences 
 30 %
public class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) {
            return false;
        }
        
        boolean [][] interleaved = new boolean[s1.length() + 1][s2.length() + 1];
        interleaved[0][0] = true;
        
        for (int i = 1; i <= s1.length(); i++) {
            if(s3.charAt(i - 1) == s1.charAt(i - 1) && interleaved[i - 1][0])
                interleaved[i][0] = true;
        }
        
        for (int j = 1; j <= s2.length(); j++) {
            if(s3.charAt(j - 1) == s2.charAt(j - 1) && interleaved[0][j - 1])
                interleaved[0][j] = true;
        }
        
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                if(((s3.charAt(i + j - 1) == s1.charAt(i - 1) && interleaved[i - 1][j]))
                    || ((s3.charAt(i + j - 1)) == s2.charAt(j - 1) && interleaved[i][j - 1]))
                interleaved[i][j] = true;
            }
        }
        
        return interleaved[s1.length()][s2.length()];
    }
}Longest Common Subsequence++
Longest Common Substring++
++++++++++++Tag: Dynamic Programming++++++++++++
Backpack II++
Backpack++


===============Best Time to Buy and Sell Stock IV===============
393: Best Time to Buy and Sell Stock IV

"Difficulty Hard Accepted Rate 22%"
         
Say you have an array for which the ith element is the price of a given stock on day i.

Example
Given prices = [4,4,6,1,1,4,2,5], and k = 2, return 6.Note
You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).
Challenge
O(nk) time.
Tags
Dynamic Programming
Related Problems

(enumeration),(forward-backward-traversal),(array)Medium
 Best Time to Buy and Sell Stock III 
 26 %
 
2
(greedy),(enumeration),(array)Medium
 Best Time to Buy and Sell Stock II 
 49 %
 
2
(greedy),(enumeration),(array),(facebook),(uber)Medium
 Best Time to Buy and Sell Stock
 41 %
class Solution {
    /**
     * @param k: An integer
     * @param prices: Given an integer array
     * @return: Maximum profit
     */
    public int maxProfit(int k, int[] prices) {
        // write your code here
        if (k == 0) {
            return 0;
        }
        if (k >= prices.length / 2) {
            int profit = 0;
            for (int i = 1; i < prices.length; i++) {
                if (prices[i] > prices[i - 1]) {
                    profit += prices[i] - prices[i - 1];
                }
            }
            return profit;
        }
        int n = prices.length;
        int[][] mustsell = new int[n + 1][n + 1];   // mustSell[i][j] 表示前i天，至多进行j次交易，第i天必须sell的最大获益
        int[][] globalbest = new int[n + 1][n + 1];  // globalbest[i][j] 表示前i天，至多进行j次交易，第i天可以不sell的最大获益
        
        mustsell[0][0] = globalbest[0][0] = 0;
        for (int i = 1; i <= k; i++) {
            mustsell[0][i] = globalbest[0][i] = 0;
        }
        
        for (int i = 1; i < n; i++) {
            int gainorlose = prices[i] - prices[i - 1];
            mustsell[i][0] = 0;
            for (int j = 1; j <= k; j++) {
                mustsell[i][j] = Math.max(globalbest[(i - 1)][j - 1] + gainorlose,
                                            mustsell[(i - 1)][j] + gainorlose);
                globalbest[i][j] = Math.max(globalbest[(i - 1)][j], mustsell[i ][j]);
            }
        }
        return globalbest[(n - 1)][k];
    }
};Binary Tree Maximum Path Sum++


===============Climbing Stairs===============
111: Climbing Stairs

"Difficulty Easy Accepted Rate 34%"
         
Given an example n=3 , 1+1+1=2+1=1+2=3

Example
Given an example n=3 , 1+1+1=2+1=1+2=3
return 3

Tags
Dynamic Programming
Related Problems
0
(enumeration),(mathematics),(non-recursion)Naive
 Fibonacci
 26 %
 
2
(linkedin),(dynamic-programming),(airbnb)Medium
 House Robber
 31 %
public class Solution {
    public int climbStairs(int n) {
        if (n <= 1) {
            return n;
        }
        int last = 1, lastlast = 1;
        int now = 0;
        for (int i = 2; i <= n; i++) {
            now = last + lastlast;
            lastlast = last;
            last = now;
        }
        return now;
    }
}

===============Coins in a Line II===============
395: Coins in a Line II

"Difficulty Medium Accepted Rate 29%"
         
There are n coins with different value in a line. Two players take turns to take one or two coins from left side until there are no more coins left. The player who take the coins with the most value wins.

Example
Given values array A = [1,2,2], return true.
Given A = [1,2,4], return false.

Tags
Dynamic Programming
Array
Game Theory
Related Problems

(greedy),(dynamic-programming),(array),(game-theory)Medium
 Coins in a Line
 41 %

import java.util.*;

public class Solution {
    /**
     * @param values: an array of integers
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int[] values) {
        // write your code here
        int []dp = new int[values.length + 1];
        boolean []flag =new boolean[values.length + 1];
        int sum = 0;
        for(int now : values) 
            sum += now;
        
        return sum < 2*MemorySearch(values.length, dp, flag, values);
    }
    int MemorySearch(int n, int []dp, boolean []flag, int []values) { 
        if(flag[n] == true)
            return dp[n];
        flag[n] = true;
        if(n == 0)  {
            dp[n] = 0;  
        } else if(n == 1) {
            dp[n] = values[values.length-1];
        } else if(n == 2) {
            dp[n] = values[values.length-1] + values[values.length-2]; 
        } else if(n == 3){
            dp[n] = values[values.length-2] + values[values.length-3]; 
        } else {
            dp[n] = Math.max(
                Math.min(MemorySearch(n-2, dp, flag,values) , MemorySearch(n-3, dp, flag, values)) + values[values.length-n],
                Math.min(MemorySearch(n-3, dp, flag, values), MemorySearch(n-4, dp, flag, values)) + values[values.length-n] + values[values.length - n + 1]
                );
        }
    
        return dp[n];
    }
    
}Coins in a Line++
Distinct Subsequences++
Edit Distance++
House Robber++
Interleaving String++
Jump Game++
k Sum++
Longest Common Subsequence++
Longest Common Substring++
Longest Increasing Continuous Subsequence++
Longest Increasing Subsequence++


===============Maximal Square===============
436: Maximal Square

"Difficulty Medium Accepted Rate 24%"
         
Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all 1's and return its area.

Example
For example, given the following matrix: 
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0Return 4. 

Tags
Dynamic Programming
Airbnb
Facebook
public class Solution {
    /**
     * @param matrix: a matrix of 0 and 1
     * @return: an integer
     */
    public int maxSquare(int[][] matrix) {
        // write your code here
        int ans = 0;
        int n = matrix.length;
        int m;
        if(n > 0)
            m = matrix[0].length;
        else 
            return ans;
        int [][]res = new int [n][m];
        for(int i = 0; i < n; i++){
            res[i][0] = matrix[i][0];
            ans = Math.max(res[i][0] , ans);
            for(int j = 1; j < m; j++) {
                if(i > 0) {
                    if(matrix[i][j] > 0) {
                        res[i][j] = Math.min(res[i - 1][j],Math.min(res[i][j-1], res[i-1][j-1])) + 1;
                    } else {
                        res[i][j] = 0;
                    }
                    
                }
                else {
                    res[i][j] = matrix[i][j];
                }
                ans = Math.max(res[i][j], ans);
            }
        }
        return ans*ans;
    }
    
    public int maxSquare(int[][] matrix) {
        // write your code here
        int ans = 0;
        int n = matrix.length;
        int m;
        if(n > 0)
            m = matrix[0].length;
        else 
            return ans;
        int [][]res = new int [2][m];
        for(int i = 0; i < n; i++){
            res[i%2][0] = matrix[i][0];
            ans = Math.max(res[i%2][0] , ans);
            for(int j = 1; j < m; j++) {
                if(i > 0) {
                    if(matrix[i][j] > 0) {
                        res[i%2][j] = Math.min(res[(i - 1)%2][j],Math.min(res[i%2][j-1], res[(i-1)%2][j-1])) + 1;
                    } else {
                        res[i%2][j] = 0;
                    }
                    
                }
                else {
                    res[i%2][j] = matrix[i%2][j];
                }
                ans = Math.max(res[i%2][j], ans);
            }
        }
        return ans*ans;
    }
}Maximum Product Subarray++
Maximum Subarray III++
Minimum Adjustment Cost++


===============Minimum Path Sum===============
110: Minimum Path Sum

"Difficulty Easy Accepted Rate 33%"
         
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Example
Note
You can only move either down or right at any point in time.
Tags
Dynamic Programming
Related Problems

(divide-and-conquer),(dynamic-programming),(recursion)Medium
 Binary Tree Maximum Path Sum 
 23 %
public class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }

        int M = grid.length;
        int N = grid[0].length;
        int[][] sum = new int[M][N];

        sum[0][0] = grid[0][0];

        for (int i = 1; i < M; i++) {
            sum[i][0] = sum[i - 1][0] + grid[i][0];
        }

        for (int i = 1; i < N; i++) {
            sum[0][i] = sum[0][i - 1] + grid[0][i];
        }

        for (int i = 1; i < M; i++) {
            for (int j = 1; j < N; j++) {
                sum[i][j] = Math.min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j];
            }
        }

        return sum[M - 1][N - 1];
    }
}

===============Palindrome Partitioning II===============
108: Palindrome Partitioning II

"Difficulty Medium Accepted Rate 21%"
         
Given a string s, cut s into some substrings such that every substring is a palindrome. 

Example
Given s = "aab",
Return 1 since the palindrome partitioning ["aa", "b"] could be produced using 1 cut.

Tags
Dynamic Programming
Related Problems

(backtracking),(depth-first-search)Medium
 Palindrome Partitioning
 22 %
 
2
(string)Medium
 Longest Palindromic Substring
 23 %
public class Solution {
    private boolean isPalindrome(String s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
        }
        return true;
    }

    private boolean[][] getIsPalindrome(String s) {
        boolean[][] isPalindrome = new boolean[s.length()][s.length()];

        for (int i = 0; i < s.length(); i++) {
            isPalindrome[i][i] = true;
        }
        for (int i = 0; i < s.length() - 1; i++) {
            isPalindrome[i][i + 1] = (s.charAt(i) == s.charAt(i + 1));
        }

        for (int length = 2; length < s.length(); length++) {
            for (int start = 0; start + length < s.length(); start++) {
                isPalindrome[start][start + length]
                    = isPalindrome[start + 1][start + length - 1] && s.charAt(start) == s.charAt(start + length);
            }
        }

        return isPalindrome;
    }

    public int minCut(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        // preparation
        boolean[][] isPalindrome = getIsPalindrome(s);
        
        // initialize
        int[] f = new int[s.length() + 1];
        for (int i = 0; i <= s.length(); i++) {
            f[i] = i - 1;
        }
        
        // main
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (isPalindrome[j][i - 1]) {
                    f[i] = Math.min(f[i], f[j] + 1);
                }
            }
        }

        return f[s.length()];
    }
}Regular Expression Matching++
Scramble String++


===============Triangle===============
109: Triangle

"Difficulty Easy Accepted Rate 25%"
         
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

Example
For example, given the following triangle
[
 [2],
[3,4],
 [6,5,7],
[4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).Note
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
Tags
Dynamic Programming
// version 0: top-down
public class Solution {
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    public int minimumTotal(int[][] triangle) {
        if (triangle == null || triangle.length == 0) {
            return -1;
        }
        if (triangle[0] == null || triangle[0].length == 0) {
            return -1;
        }
        
        // state: f[x][y] = minimum path value from 0,0 to x,y
        int n = triangle.length;
        int[][] f = new int[n][n];
        
        // initialize 
        f[0][0] = triangle[0][0];
        for (int i = 1; i < n; i++) {
            f[i][0] = f[i - 1][0] + triangle[i][0];
            f[i][i] = f[i - 1][i - 1] + triangle[i][i];
        }
        
        // top down
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < i; j++) {
                f[i][j] = Math.min(f[i - 1][j], f[i - 1][j - 1]) + triangle[i][j];
            }
        }
        
        // answer
        int best = f[n - 1][0];
        for (int i = 1; i < n; i++) {
            best = Math.min(best, f[n - 1][i]);
        }
        return best;
    }
}



//Version 1: Bottom-Up
public class Solution {
    /**
     * @param triangle: a list of lists of integers.
     * @return: An integer, minimum path sum.
     */
    public int minimumTotal(int[][] triangle) {
        if (triangle == null || triangle.length == 0) {
            return -1;
        }
        if (triangle[0] == null || triangle[0].length == 0) {
            return -1;
        }
        
        // state: f[x][y] = minimum path value from x,y to bottom
        int n = triangle.length;
        int[][] f = new int[n][n];
        
        // initialize 
        for (int i = 0; i < n; i++) {
            f[n - 1][i] = triangle[n - 1][i];
        }
        
        // bottom up
        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                f[i][j] = Math.min(f[i + 1][j], f[i + 1][j + 1]) + triangle[i][j];
            }
        }
        
        // answer
        return f[0][0];
    }
}


//Version 2 : Memorize Search
public class Solution {
    private int n;
    private int[][] minSum;
    private int[][] triangle;

    private int search(int x, int y) {
        if (x >= n) {
            return 0;
        }

        if (minSum[x][y] != Integer.MAX_VALUE) {
            return minSum[x][y];
        }

        minSum[x][y] = Math.min(search(x + 1, y), search(x + 1, y + 1))
            + triangle[x][y];
        return minSum[x][y];
    }

    public int minimumTotal(int[][] triangle) {
        if (triangle == null || triangle.length == 0) {
            return -1;
        }
        if (triangle[0] == null || triangle[0].length == 0) {
            return -1;
        }
        
        this.n = triangle.length;
        this.triangle = triangle;
        this.minSum = new int[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                minSum[i][j] = Integer.MAX_VALUE;
            }
        }

        return search(0, 0);
    }
}

===============Unique Binary Search Trees II===============
164: Unique Binary Search Trees II

"Difficulty Medium Accepted Rate 30%"
         
Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.

Example
Given n = 3, your program should return all 5 unique BST's shown below.
 1 3 321
\ / // \\
 3 2 11 32
/ / \ \
 2 1 2 3

Tags
Dynamic Programming
Depth First Search
Related Problems

(string),(backtracking),(recursion),(zenefits),(google)Medium
 Generate Parentheses
 30 %
public class Solution {
    public ArrayList<TreeNode> generateTrees(int n) {
        return generate(1, n);
    }
    
    private ArrayList<TreeNode> generate(int start, int end){
        ArrayList<TreeNode> rst = new ArrayList<TreeNode>();   
    
        if(start > end){
            rst.add(null);
            return rst;
        }
     
            for(int i=start; i<=end; i++){
                ArrayList<TreeNode> left = generate(start, i-1);
                ArrayList<TreeNode> right = generate(i+1, end);
                for(TreeNode l: left){
                    for(TreeNode r: right){
// should new a root here because it need to 
// be different for each tree
                        TreeNode root = new TreeNode(i);  
                        root.left = l;
                        root.right = r;
                        rst.add(root);
                    }
                }
            }
        return rst;
    }
}Unique Binary Search Trees++


===============Unique Paths II===============
115: Unique Paths II

"Difficulty Easy Accepted Rate 27%"
         
Follow up for "Unique Paths":

Example
For example,There is one obstacle in the middle of a 3x3 grid as illustrated below.
[
[0,0,0],
[0,1,0],
[0,0,0]
]The total number of unique paths is 2.Note
m and n will be at most 100.
Tags
Dynamic Programming
Array
public class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0) {
            return 0;
        }
        
        int n = obstacleGrid.length;
        int m = obstacleGrid[0].length;
        int[][] paths = new int[n][m];
        
        for (int i = 0; i < n; i++) {
            if (obstacleGrid[i][0] != 1) {
                paths[i][0] = 1;
            } else {
                break;
            }
        }
        
        for (int i = 0; i < m; i++) {
            if (obstacleGrid[0][i] != 1) {
                paths[0][i] = 1; 
            } else {
                break;
            }
        }
        
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                if (obstacleGrid[i][j] != 1) {
                    paths[i][j] = paths[i - 1][j] + paths[i][j - 1];
                } else {
                    paths[i][j] = 0;
                }
            }
        }
        
        return paths[n - 1][m - 1];
    }
}

===============Unique Paths===============
114: Unique Paths

"Difficulty Easy Accepted Rate 35%"
         
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

Example
1,11,21,31,41,51,61,72,13,13,7
Above is a 3 x 7 grid. How many possible unique paths are there?
Note
m and n will be at most 100.
Tags
Dynamic Programming
Array
public class Solution {
    public int uniquePaths(int m, int n) {
        if (m == 0 || n == 0) {
            return 0;
        }
        
        int[][] sum = new int[m][n];
        for (int i = 0; i < m; i++) {
            sum[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            sum[0][i] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                sum[i][j] = sum[i - 1][j] + sum[i][j - 1];
            }
        }
        return sum[m - 1][n - 1];
    }
}Wildcard Matching++
Word Break++
++++++++++++Tag: Subarray++++++++++++
Maximum Product Subarray++
Maximum Subarray Difference++
Maximum Subarray II++
Maximum Subarray III++
Maximum Subarray++
Minimum Subarray++


===============Subarray Sum Closest===============
139: Subarray Sum Closest

"Difficulty Medium Accepted Rate 16%"
         
Given an integer array, find a subarray with sum closest to zero. Return the indexes of the first number and last number.

Example
Given [-3, 1, 1, -3, 5], return [0, 2], [1, 3], [1, 1], [2, 2] or [0, 4].Challenge
O(nlogn) time
Tags
Subarray
Sort
Related Problems

(enumeration),(matrix)Medium
 Submatrix Sum
 20 %
 
2
(two-pointers),(array),(facebook)Medium
 Minimum Size Subarray Sum 
 24 %
 
1
(subarray),(hash-table)Easy
 Subarray Sum
 26 %
public class Solution {
    /**
     * @param nums: A list of integers
     * @return: A list of integers includes the index of the first number 
     *          and the index of the last number
     */
    class Pair {
        int sum;
        int index;
        public Pair(int s, int i) {
            sum = s;
            index = i;
        }
    }
    public ArrayList<Integer> subarraySumClosest(int[] nums) {
        // write your code here
        ArrayList<Integer> res = new ArrayList<Integer> ();
        if (nums == null || nums.length == 0) {
            return res;
        } 
        
        int len = nums.length;
        if(len == 1) {
            res.add(0);
            res.add(0);
            return res;
        }
        Pair[] sums = new Pair[len+1];
        int prev = 0;
        sums[0] = new Pair(0, 0);
        for (int i = 1; i <= len; i++) {
            sums[i] = new Pair(prev + nums[i-1], i);
            prev = sums[i].sum;
        }
        Arrays.sort(sums, new Comparator<Pair>() {
           public int compare(Pair a, Pair b) {
               return a.sum - b.sum;
           } 
        });
        int ans = Integer.MAX_VALUE;
        for (int i = 1; i <= len; i++) {
            
            if (ans > sums[i].sum - sums[i-1].sum) {
                ans = sums[i].sum - sums[i-1].sum;
                res.clear();
                int[] temp = new int[]{sums[i].index - 1, sums[i - 1].index - 1};
                Arrays.sort(temp);
                res.add(temp[0] + 1);
                res.add(temp[1]);
            }
        }
        
        return res;
    }
}

===============Subarray Sum===============
138: Subarray Sum

"Difficulty Easy Accepted Rate 26%"
         
Given an integer array, find a subarray where the sum of numbers is zero. Your code should return the index of the first number and the index of the last number.

Example
Given [-3, 1, 2, -3, 4], return [0, 2] or [1, 3].Note
There is at least one subarray that it's sum equals to zero.
Tags
Subarray
Hash Table
Related Problems

(enumeration),(matrix)Medium
 Submatrix Sum
 20 %
 
2
(two-pointers),(array),(facebook)Medium
 Minimum Size Subarray Sum 
 24 %
 
2
(subarray),(sort)Medium
 Subarray Sum Closest
 16 %
public class Solution {
    /**
     * @param nums: A list of integers
     * @return: A list of integers includes the index of the first number
     *          and the index of the last number
     */
    public ArrayList<Integer> subarraySum(int[] nums) {
        // write your code here
       
        int len = nums.length;
       
        ArrayList<Integer> ans = new ArrayList<Integer>();
        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
       
        map.put(0, -1);
       
        int sum = 0;
        for (int i = 0; i < len; i++) {
            sum += nums[i];
           
            if (map.containsKey(sum)) {
                ans.add(map.get(sum) + 1);
                ans.add(i);
                return ans;
            }
            
            map.put(sum, i);
        }
       
        return ans;
    }
}++++++++++++Tag: Quick Sort++++++++++++


===============Kth Largest Element===============
5: Kth Largest Element

"Difficulty Medium Accepted Rate 20%"
         
Find K-th largest element in an array.

Example
In array [9,3,2,4,8], the 3rd largest element is 4.
In array [1,2,3,4,5], the 1st largest element is 5, 2nd largest element is 4, 3rd largest element is 3 and etc.Note
You can swap elements in the array
Challenge
O(n) time, O(1) extra memory.
Tags
Quick Sort
Sort
Related Problems

(heap),(priority-queue),(matrix)Medium
 Kth Smallest Number in Sorted Matrix
 17 %
class Solution {
    //param k : description of k
    //param numbers : array of numbers
    //return: description of return
    public int kthLargestElement(int k, ArrayList<Integer> numbers) {
        if (numbers == null || numbers.size() == 0) {
            return 0;
        }
        if (k <= 0) {
            return 0;
        }
        return helper(numbers, 0, numbers.size() - 1, k);
    }
    
    public int helper(ArrayList<Integer> numbers, int l, int r, int k) {
        if (l == r) {
            return numbers.get(l);
        }
        int position = partition(numbers, l, r);
        if (position + 1 == k) {
            return numbers.get(position);
        } else if (position + 1 < k) {
            return helper(numbers, position + 1, r, k);
        }  else {
            return helper(numbers, l, position - 1, k);
        }
    }
    
    public int partition(ArrayList<Integer> numbers, int l, int r) {
        if (l == r) {
            return l;
        }
        int num = numbers.get(r);
        int index = l;
        for (int i = l; i < r; i ++) {
            if (numbers.get(i) >= num) {
                int temp = numbers.get(i);
                numbers.set(i, numbers.get(index));
                numbers.set(index, temp);
                index ++;
            }
        }
        
        numbers.set(r, numbers.get(index));
        numbers.set(index, num);
        return index;         
    }
};Median++
++++++++++++Tag: Sort++++++++++++
3Sum Closest++
3Sum++
4Sum++


===============Insertion Sort List===============
173: Insertion Sort List

"Difficulty Easy Accepted Rate 29%"
         
Sort a linked list using insertion sort.

Example
Given 1->3->2->0->null, return 0->1->2->3->null.

Tags
Sort
Linked List
Related Problems

(linked-list)Medium
 Sort List 
 27 %
public class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode dummy = new ListNode(0);

        while (head != null) {
            ListNode node = dummy;
            while (node.next != null && node.next.val < head.val) {
                node = node.next;
            }
            ListNode temp = head.next;
            head.next = node.next;
            node.next = head;
            head = temp;
        }

        return dummy.next;
    }
}Kth Largest Element++


===============Largest Number===============
184: Largest Number

"Difficulty Medium Accepted Rate 17%"
         
Given a list of non negative integers, arrange them such that they form the largest number.

Example
Given [1, 20, 23, 4, 8], the largest formed number is 8423201.Note
The result may be very large, so you need to return a string instead of an integer.
Challenge
Do it in O(nlogn) time complexity.
Tags
Sort
Related Problems

(greedy),(lintcode-copyright)Medium
 Delete Digits
 17 %
class NumbersComparator implements Comparator<String> {
	@Override
	public int compare(String s1, String s2) {
		return (s2 + s1).compareTo(s1 + s2);
	}
}

public class Solution {
    
    public String largestNumber(int[] nums) {
        String[] strs = new String[nums.length];
        for (int i = 0; i < nums.length; i++) {
            strs[i] = Integer.toString(nums[i]);
        }
        Arrays.sort(strs, new NumbersComparator());
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < strs.length; i++) {
            sb.append(strs[i]);
        }
        String result = sb.toString();
        int index = 0;
        while (index < result.length() && result.charAt(index) == &#39;0&#39;) {
            index++;
        }
        if (index == result.length()) {
            return "0";
        }
        return result.substring(index);
    }
}Maximum Gap++
Merge Intervals++
Partition Array++
Sort Colors II++
Sort Colors++
Sort Letters by Case++
Subarray Sum Closest++
The Smallest Difference++
Two Sum++
++++++++++++Tag: Recursion++++++++++++
Balanced Binary Tree++


===============Binary Tree Inorder Traversal===============
67: Binary Tree Inorder Traversal

"Difficulty Easy Accepted Rate 39%"
         
Given a binary tree, return the inorder traversal of its nodes' values.

Example
Given binary tree {1,#,2,3}, 1
\
 2
/
 3 
return [1,3,2].Challenge
Can you do it without recursion?
Tags
Recursion
Binary Tree
Binary Tree Traversal
Related Problems
1
(recursion),(binary-tree),(binary-tree-traversal),(non-recursion)Easy
 Binary Tree Preorder Traversal
 39 %
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: The root of binary tree.
     * @return: Inorder in ArrayList which contains node values.
     */
    public ArrayList<Integer> inorderTraversal(TreeNode root) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        ArrayList<Integer> result = new ArrayList<Integer>();
        TreeNode curt = root;
        while (curt != null || !stack.empty()) {
            while (curt != null) {
                stack.add(curt);
                curt = curt.left;
            }
            curt = stack.peek();
            stack.pop();
            result.add(curt.val);
            curt = curt.right;
        }
        return result;
    }
}Binary Tree Maximum Path Sum++


===============Binary Tree Postorder Traversal===============
68: Binary Tree Postorder Traversal

"Difficulty Easy Accepted Rate 37%"
         
Given a binary tree, return the postorder traversal of its nodes' values.

Example
Given binary tree {1,#,2,3}, 1
\
 2
/
 3 
return [3,2,1].Challenge
Can you do it without recursion?
Tags
Recursion
Binary Tree
Binary Tree Traversal
Related Problems
1
(recursion),(binary-tree),(binary-tree-traversal),(non-recursion)Easy
 Binary Tree Preorder Traversal
 39 %
//Recursive
public ArrayList<Integer> postorderTraversal(TreeNode root) {
    ArrayList<Integer> result = new ArrayList<Integer>();

    if (root == null) {
        return result;
    }

    result.addAll(postorderTraversal(root.left));
    result.addAll(postorderTraversal(root.right));
    result.add(root.val);

    return result;   
}

//Iterative
public ArrayList<Integer> postorderTraversal(TreeNode root) {
    ArrayList<Integer> result = new ArrayList<Integer>();
    Stack<TreeNode> stack = new Stack<TreeNode>();
    TreeNode prev = null; // previously traversed node
    TreeNode curr = root;

    if (root == null) {
        return result;
    }

    stack.push(root);
    while (!stack.empty()) {
        curr = stack.peek();
        if (prev == null || prev.left == curr || prev.right == curr) { // traverse down the tree
            if (curr.left != null) {
                stack.push(curr.left);
            } else if (curr.right != null) {
                stack.push(curr.right);
            }
        } else if (curr.left == prev) { // traverse up the tree from the left
            if (curr.right != null) {
                stack.push(curr.right);
            }
        } else { // traverse up the tree from the right
            result.add(curr.val);
            stack.pop();
        }
        prev = curr;
    }

    return result;
}

===============Binary Tree Preorder Traversal===============
66: Binary Tree Preorder Traversal

"Difficulty Easy Accepted Rate 39%"
         
Given a binary tree, return the preorder traversal of its nodes' values.

Example
Given:
1
 / \
2 3
 / \
4 5return [1,2,4,5,3].Challenge
Can you do it without recursion?
Tags
Recursion
Binary Tree
Binary Tree Traversal
Non Recursion
Related Problems
1
(recursion),(binary-tree),(binary-tree-traversal)Easy
 Binary Tree Postorder Traversal
 37 %
 
1
(recursion),(binary-tree),(binary-tree-traversal)Easy
 Binary Tree Inorder Traversal
 39 %
Version 0: Non-Recursion (Recommend)
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        List<Integer> preorder = new ArrayList<Integer>();
        
        if (root == null) {
            return preorder;
        }
        
        stack.push(root);
        while (!stack.empty()) {
            TreeNode node = stack.pop();
            preorder.add(node.val);
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
        }
        
        return preorder;
    }
}

//Version 1: Traverse
public class Solution {
    public ArrayList<Integer> preorderTraversal(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<Integer>();
        traverse(root, result);
        return result;
    }
    // 把root为跟的preorder加入result里面
    private void traverse(TreeNode root, ArrayList<Integer> result) {
        if (root == null) {
            return;
        }

        result.add(root.val);
        traverse(root.left, result);
        traverse(root.right, result);
    }
}

//Version 2: Divide & Conquer
public class Solution {
    public ArrayList<Integer> preorderTraversal(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<Integer>();
        // null or leaf
        if (root == null) {
            return result;
        }

        // Divide
        ArrayList<Integer> left = preorderTraversal(root.left);
        ArrayList<Integer> right = preorderTraversal(root.right);

        // Conquer
        result.add(root.val);
        result.addAll(left);
        result.addAll(right);
        return result;
    }
}Generate Parentheses++
Gray Code++
Letter Combinations of a Phone Number++
Maximum Depth of Binary Tree++


===============N-Queens II===============
34: N-Queens II

"Difficulty Medium Accepted Rate 39%"
         
Follow up for N-Queens problem.

Example
For n=4, there are 2 distinct solutions.

Tags
Recursion
Related Problems

(backtracking),(array)Medium
 Combinations 
 30 %
 
2
(recursion),(depth-first-search)Medium
 N-Queens
 20 %
public class Solution {
    public static int sum;
    public int totalNQueens(int n) {
        sum = 0;
        int[] usedColumns = new int[n];
        placeQueen(usedColumns, 0);
        return sum;
    }
    public void placeQueen(int[] usedColumns, int row) {
        int n = usedColumns.length;
        
        if (row == n) {
            sum ++;
            return;
        }
        
        for (int i = 0; i < n; i++) {
            if (isValid(usedColumns, row, i)) {
                usedColumns[row] = i;
                placeQueen(usedColumns, row + 1);
            }
        }
    }
    public boolean isValid(int[] usedColumns, int row, int col) {
        for (int i = 0; i < row; i++) {
            if (usedColumns[i] == col) {
                return false;
            }
            if ((row - i) == Math.abs(col-usedColumns[i])) {
                return false;
            }
        }
        return true;
    }
}

===============N-Queens===============
33: N-Queens

"Difficulty Medium Accepted Rate 20%"
         
The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.

Example
There exist two distinct solutions to the 4-queens puzzle:
[
// Solution 1
[".Q..",
 "...Q",
 "Q...",
 "..Q."
],
// Solution 2
["..Q.",
 "Q...",
 "...Q",
 ".Q.."
]
]
Challenge
Can you do it without recursion?
Tags
Recursion
Depth First Search
Related Problems

(backtracking),(array)Medium
 Combinations 
 30 %
 
2
(recursion)Medium
 N-Queens II
 39 %
public class Solution {
    private String[] drawChessboard(ArrayList<Integer> cols) {
        String[] chessboard = new String[cols.size()];
        for (int i = 0; i < cols.size(); i++) {
            chessboard[i] = "";
            for (int j = 0; j < cols.size(); j++) {
                if (j == cols.get(i)) {
                    chessboard[i] += "Q";
                } else {
                    chessboard[i] += ".";
                }
            }
        }
        
        return chessboard;
    }
    
    private boolean isValid(ArrayList<Integer> cols, int col) {
        int row = cols.size();
        for (int i = 0; i < row; i++) {
            // same column
            if (cols.get(i)== col)  {
                return false;
            }
            // left-top to right-bottom
            if (i - cols.get(i) == row - col) {
                return false;
            }
            // right-top to left-bottom
            if (i + cols.get(i) == row + col) {
                return false;
            }
        }
        return true;
    }
    
    private void search(int n, ArrayList<Integer> cols, ArrayList<String[]> result) {
        if (cols.size() == n) {
            result.add(drawChessboard(cols));
            return;
        }
        
        for (int col = 0; col < n; col++) {
            if (!isValid(cols, col)) {
                continue;
            }
            cols.add(col);
            search(n, cols, result);
            cols.remove(cols.size() - 1);
        }
    }
    
    public ArrayList<String[]> solveNQueens(int n) {
        ArrayList<String[]> result = new ArrayList<String[]>();
        if (n <= 0) {
            return result;
        }
        search(n, new ArrayList<Integer>(), result);
        return result;
    }
}Permutations II++
Permutations++
Restore IP Addresses++


===============Subsets II===============
18: Subsets II

"Difficulty Medium Accepted Rate 22%"
         
Given a list of numbers that may has duplicate numbers, return all possible subsets

Example
If S = [1,2,2], a solution is:
[
[2],
[1],
[1,2,2],
[2,2],
[1,2],
[]
]
NoteEach element in a subset must be in non-descending order.
The ordering between two subsets is free.
The solution set must not contain duplicate subsets.Challenge
Can you do it in both recursively and iteratively?
Tags
Recursion
Related Problems

(recursion),(facebook),(uber)Medium
 Subsets
 22 %
public class Solution {
    public ArrayList<ArrayList<Integer>> subsets(int[] num) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> list = new ArrayList<Integer>();
        if(num == null || num.length ==0) {
            return result;
        }
        Arrays.sort(num);
        subsetsHelper(result, list, num, 0);

        return result;
    }

    private void subsetsHelper(ArrayList<ArrayList<Integer>> result,
        ArrayList<Integer> list, int[] num, int pos) {

        result.add(new ArrayList<Integer>(list));
        
        for (int i = pos; i < num.length; i++) {
            if ( i != pos && num[i] == num[i - 1]) {
                continue;
            }    
            list.add(num[i]);
            subsetsHelper(result, list, num, i + 1);
            list.remove(list.size() - 1);
        }
    }
}

===============Subsets===============
17: Subsets

"Difficulty Medium Accepted Rate 22%"
         
Given a set of distinct integers, return all possible subsets.

Example
If S = [1,2,3], a solution is:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]
NoteElements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.Challenge
Can you do it in both recursively and iteratively?
Tags
Recursion
Facebook
Uber
Related Problems

(string),(backtracking),(recursion)Medium
 Restore IP Addresses
 19 %
 
2
(recursion)Medium
 Subsets II
 22 %
public class Solution {
    public ArrayList<ArrayList<Integer>> subsets(int[] num) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        if(num == null || num.length == 0) {
            return result;
        }
        ArrayList<Integer> list = new ArrayList<Integer>();
        Arrays.sort(num);  
        subsetsHelper(result, list, num, 0);

        return result;
    }


    private void subsetsHelper(ArrayList<ArrayList<Integer>> result,
        ArrayList<Integer> list, int[] num, int pos) {

        result.add(new ArrayList<Integer>(list));

        for (int i = pos; i < num.length; i++) {

            list.add(num[i]);
            subsetsHelper(result, list, num, i + 1);
            list.remove(list.size() - 1);
        }
    }
}


// Non Recursion
class Solution {
    /**
     * @param S: A set of numbers.
     * @return: A list of lists. All valid subsets.
     */
    public ArrayList<ArrayList<Integer>> subsets(int[] nums) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        int n = nums.length;
        Arrays.sort(nums);
        
        // 1 << n is 2^n
        // each subset equals to an binary integer between 0 .. 2^n - 1
        // 0 -> 000 -> []
        // 1 -> 001 -> [1]
        // 2 -> 010 -> [2]
        // ..
        // 7 -> 111 -> [1,2,3]
        for (int i = 0; i < (1 << n); i++) {
            ArrayList<Integer> subset = new ArrayList<Integer>();
            for (int j = 0; j < n; j++) {
                // check whether the jth digit in i&#39;s binary representation is 1
                if ((i & (1 << j)) != 0) {
                    subset.add(nums[j]);
                }
            }
            result.add(subset);
        }
        
        return result;
    }
}

===============Subtree===============
245: Subtree

"Difficulty Easy Accepted Rate 21%"
         
You have two every large binary trees: T1, with millions of nodes, and T2, with hundreds of nodes. Create an algorithm to decide if T2 is a subtree of T1. 

Example
T2 is a subtree of T1 in the following case:
 13
/ \/ 
T1 = 2 3T2 =4
/
 4T2 isn't a subtree of T1 in the following case:
 1 3
/ \ \
T1 = 2 3 T2 =4
/
 4
Note
A tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the two trees would be identical.
Tags
Recursion
Binary Tree
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param T1, T2: The roots of binary tree.
     * @return: True if T2 is a subtree of T1, or false.
     */
    public boolean isSubtree(TreeNode T1, TreeNode T2) {
        if (T2 == null) {
            return true;
        }
        if (T1 == null) {
            return false;
        }
        
        if (isEqual(T1, T2)) {
            return true;
        }
        if (isSubtree(T1.left, T2) || isSubtree(T1.right, T2)) {
            return true;
        }
        return false;
    }
    
    private boolean isEqual(TreeNode T1, TreeNode T2) {
        if (T1 == null || T2 == null) {
            return T1 == T2;
        }
        if (T1.val != T2.val) {
            return false;
        }
        return isEqual(T1.left, T2.left) && isEqual(T1.right, T2.right);
    }
}Validate Binary Search Tree++
++++++++++++Tag: Hedvig++++++++++++
++++++++++++Tag: Hash Table++++++++++++
4Sum++
Anagrams++


===============Copy List with Random Pointer===============
105: Copy List with Random Pointer

"Difficulty Medium Accepted Rate 26%"
         
Could you solve it with O(1) space?

Example
Challenge
Could you solve it with O(1) space?
Tags
Hash Table
Linked List
Uber
Related Problems
//HashMap version
public class Solution {
    public RandomListNode copyRandomList(RandomListNode head) {
        if (head == null) {
            return null;
        }

        HashMap<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();
        RandomListNode dummy = new RandomListNode(0);
        RandomListNode pre = dummy, newNode;
        while (head != null) {
            if (map.containsKey(head)) {
                newNode = map.get(head);
            } else {
                newNode = new RandomListNode(head.label);
                map.put(head, newNode);
            }
            pre.next = newNode;

            if (head.random != null) {
                if (map.containsKey(head.random)) {
                    newNode.random = map.get(head.random);
                } else {
                    newNode.random = new RandomListNode(head.random.label);
                    map.put(head.random, newNode.random);
                }
            }

            pre = newNode;
            head = head.next;
        }

        return dummy.next;
    }
}

/*第一遍扫的时候巧妙运用next指针， 开始数组是1->2->3->4  。 然后扫描过程中 先建立copy节点 1->1`->2->2`->3->3`->4->4`, 然后第二遍copy的时候去建立边的copy， 拆分节点, 一边扫描一边拆成两个链表，这里用到两个dummy node。第一个链表变回  1->2->3 , 然后第二变成 1`->2`->3`  */
//No HashMap version
public class Solution {
    private void copyNext(RandomListNode head) {
        while (head != null) {
            RandomListNode newNode = new RandomListNode(head.label);
            newNode.random = head.random;
            newNode.next = head.next;
            head.next = newNode;
            head = head.next.next;
        }
    }

    private void copyRandom(RandomListNode head) {
        while (head != null) {
            if (head.next.random != null) {
                head.next.random = head.random.next;
            }
            head = head.next.next;
        }
    }

    private RandomListNode splitList(RandomListNode head) {
        RandomListNode newHead = head.next;
        while (head != null) {
            RandomListNode temp = head.next;
            head.next = temp.next;
            head = head.next;
            if (temp.next != null) {
                temp.next = temp.next.next;
            }
        }
        return newHead;
    }

    public RandomListNode copyRandomList(RandomListNode head) {
        if (head == null) {
            return null;
        }
        copyNext(head);
        copyRandom(head);
        return splitList(head);
    }
}

===============Happy Number===============
488: Happy Number

"Difficulty Easy Accepted Rate 28%"
         
Write an algorithm to determine if a number is happy.

Example
19 is a happy number
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
Tags
Hash Table
Mathematics
Related Problems

(lintcode-copyright),(priority-queue)Medium
 Ugly Number
 20 %
public class Solution {
    private int getNextHappy(int n) {
        int sum = 0;
        while (n != 0) {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    
    public boolean isHappy(int n) {
        HashSet<Integer> hash = new HashSet<Integer>();
        while (n != 1) {
            if (hash.contains(n)) {
                return false;
            }
            hash.add(n);
            n = getNextHappy(n);
        }
        return true;
    }
}Longest Substring Without Repeating Characters++
Majority Number III++
Max Points on a Line++
Minimum Window Substring++
Rehashing++
Subarray Sum++
Two Sum++
++++++++++++Tag: Linked List++++++++++++
Add Two Numbers++
Convert Sorted List to Balanced BST++
Copy List with Random Pointer++
Delete Node in the Middle of Singly Linked List++
Insertion Sort List++


===============Intersection of Two Linked Lists===============
380: Intersection of Two Linked Lists

"Difficulty Medium Accepted Rate 37%"
         
Write a program to find the node at which the intersection of two singly linked lists begins.

Example
The following two linked lists:
A:a1 → a2
 ↘
 c1 → c2 → c3
 ↗
B: b1 → b2 → b3begin to intersect at node c1.NoteIf the two linked lists have no intersection at all, return null.
The linked lists must retain their original structure after the function returns.
You may assume there are no cycles anywhere in the entire linked structure.Challenge
Your code should preferably run in O(n) time and use only O(1) memory.
Tags
Linked List
Related Problems
3
(two-pointers),(linked-list)Hard
 Linked List Cycle II 
 36 %
 
2
(two-pointers),(linked-list)Medium
 Linked List Cycle 
 46 %
public class Solution {
    /**
     * @param headA: the first list
     * @param headB: the second list
     * @return: a ListNode 
     */
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        
        // get the tail of list A.
        ListNode node = headA;
        while (node.next != null) {
            node = node.next;
        }
        node.next = headB;
        ListNode result = listCycleII(headA);
        node.next = null;
        return result;
    }
    
    private ListNode listCycleII(ListNode head) {
        ListNode slow = head, fast = head.next;
        
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return null;
            }
            
            slow = slow.next;
            fast = fast.next.next;
        }
        
        slow = head;
        fast = fast.next;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        
        return slow;
    }
}Linked List Cycle II++
Linked List Cycle++


===============LRU Cache===============
134: LRU Cache

"Difficulty Hard Accepted Rate 18%"
         


Example
Tags
Linked List
Zenefits
Uber
Google
Related Problems
public class LRUCache {
    private class Node{
        Node prev;
        Node next;
        int key;
        int value;

        public Node(int key, int value) {
            this.key = key;
            this.value = value;
            this.prev = null;
            this.next = null;
        }
    }

    private int capacity;
    private HashMap<Integer, Node> hs = new HashMap<Integer, Node>();
    private Node head = new Node(-1, -1);
    private Node tail = new Node(-1, -1);

    public LRUCache(int capacity) {
        this.capacity = capacity;
        tail.prev = head;
        head.next = tail;
    }

    public int get(int key) {
        if( !hs.containsKey(key)) {
            return -1;
        }

        // remove current
        Node current = hs.get(key);
        current.prev.next = current.next;
        current.next.prev = current.prev;

        // move current to tail
        move_to_tail(current);

        return hs.get(key).value;
    }

    public void set(int key, int value) {
        if( get(key) != -1) {
            hs.get(key).value = value;
            return;
        }

        if (hs.size() == capacity) {
            hs.remove(head.next.key);
            head.next = head.next.next;
            head.next.prev = head;
        }

        Node insert = new Node(key, value);
        hs.put(key, insert);
        move_to_tail(insert);
    }

    private void move_to_tail(Node current) {
        current.prev = tail.prev;
        tail.prev = current;
        current.prev.next = current;
        current.next = tail;
    }
}Majority Number III++
Merge k Sorted Lists++
Merge Two Sorted Lists++
Nth to Last Node in List++


===============Palindrome Linked List===============
223: Palindrome Linked List

"Difficulty Medium Accepted Rate 26%"
         
Implement a function to check if a linked list is a palindrome.

Example
Given 1->2->1, return trueChallenge
Could you do it in O(n) time and O(1) space?
Tags
Linked List
Related Problems
1
(string),(two-pointers),(facebook),(zenefits),(uber)Easy
 Valid Palindrome
 21 %
 
1
(linked-list),(facebook),(uber)Easy
 Reverse Linked List
 40 %
// This code would destroy the original structure of the linked list.
// If you do not want to destroy the structure, you can reserve the second part back.
public class Solution {
    /**
     * @param head a ListNode
     * @return a boolean
     */
    public boolean isPalindrome(ListNode head) {
        if (head == null) {
            return true;
        }
        
        ListNode middle = findMiddle(head);
        middle.next = reverse(middle.next);
        
        ListNode p1 = head, p2 = middle.next;
        while (p1 != null && p2 != null && p1.val == p2.val) {
            p1 = p1.next;
            p2 = p2.next;
        }
        
        return p2 == null;
    }
    
    private ListNode findMiddle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode slow = head, fast = head.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        return slow;
    }
    
    private ListNode reverse(ListNode head) {
        ListNode prev = null;
        
        while (head != null) {
            ListNode temp = head.next;
            head.next = prev;
            prev = head;
            head = temp;
        }
        
        return prev;
    }
}Partition List++


===============Remove Duplicates from Sorted List II===============
113: Remove Duplicates from Sorted List II

"Difficulty Medium Accepted Rate 27%"
         
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.


Example
Given 1->2->3->3->4->4->5, return 1->2->5.
Given 1->1->1->2->3, return 2->3.
Tags
Linked List
Related Problems
0
(linked-list)Naive
 Remove Linked List Elements
 22 %

public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null || head.next == null)
            return head;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        head = dummy;

        while (head.next != null && head.next.next != null) {
            if (head.next.val == head.next.next.val) {
                int val = head.next.val;
                while (head.next != null && head.next.val == val) {
                    head.next = head.next.next;
                }            
            } else {
                head = head.next;
            }
        }
        
        return dummy.next;
    }
}

===============Remove Duplicates from Sorted List===============
112: Remove Duplicates from Sorted List

"Difficulty Easy Accepted Rate 38%"
         
Given a sorted linked list, delete all duplicates such that each element appear only once.


Example
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.
Tags
Linked List
Related Problems
0
(linked-list)Naive
 Remove Linked List Elements
 22 %
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) {
            return null;
        }

        ListNode node = head;
        while (node.next != null) {
            if (node.val == node.next.val) {
                node.next = node.next.next;
            } else {
                node = node.next;
            }
        }
        return head;
    }
}

===============Remove Linked List Elements===============
452: Remove Linked List Elements

"Difficulty Naive Accepted Rate 22%"
         
Remove all elements from a linked list of integers that have value val.

Example
Given 1->2->3->3->4->5->3, val = 3, you should return the list as 1->2->4->5

Tags
Linked List
Related Problems

(linked-list)Medium
 Remove Duplicates from Sorted List II
 27 %
 
1
(linked-list)Easy
 Remove Duplicates from Sorted List
 38 %
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    /**
     * @param head a ListNode
     * @param val an integer
     * @return a ListNode
     */
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        head = dummy;
        
        while (head.next != null) {
            if (head.next.val == val) {
                head.next = head.next.next;
            } else {
                head = head.next;
            }
        }
        
        return dummy.next;
    }
}Remove Nth Node From End of List++


===============Reorder List===============
99: Reorder List

"Difficulty Medium Accepted Rate 22%"
         
For example,Given 1->2->3->4->null, reorder it to 1->4->2->3->null.

Example
For example,Given 1->2->3->4->null, reorder it to 1->4->2->3->null.

Tags
Linked List
public class Solution {
    private ListNode reverse(ListNode head) {
        ListNode newHead = null;
        while (head != null) {
            ListNode temp = head.next;
            head.next = newHead;
            newHead = head;
            head = temp;
        }
        return newHead;
    }

    private void merge(ListNode head1, ListNode head2) {
        int index = 0;
        ListNode dummy = new ListNode(0);
        while (head1 != null && head2 != null) {
            if (index % 2 == 0) {
                dummy.next = head1;
                head1 = head1.next;
            } else {
                dummy.next = head2;
                head2 = head2.next;
            }
            dummy = dummy.next;
            index ++;
        }
        if (head1 != null) {
            dummy.next = head1;
        } else {
            dummy.next = head2;
        }
    }

    private ListNode findMiddle(ListNode head) {
        ListNode slow = head, fast = head.next;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }

    public void reorderList(ListNode head) {
        if (head == null || head.next == null) {
            return;
        }

        ListNode mid = findMiddle(head);
        ListNode tail = reverse(mid.next);
        mid.next = null;

        merge(head, tail);
    }
}

===============Reverse Linked List II===============
36: Reverse Linked List II

"Difficulty Medium Accepted Rate 28%"
         
Reverse a linked list from position m to n.

Example
Given 1->2->3->4->5->NULL, m = 2 and n = 4, return 1->4->3->2->5->NULL.Note
Given m, n satisfy the following condition: 1 ≤ m ≤ n ≤ length of list.
Challenge
Reverse it in-place and in one-pass
Tags
Linked List
Related Problems
3
(linked-list),(facebook)Hard
 Reverse Nodes in k-Group
 27 %
 
1
(string)Easy
 Reverse Words in a String
 23 %
 
1
(linked-list),(facebook),(uber)Easy
 Reverse Linked List
 40 %
/**
 * Definition for ListNode
 * public class ListNode {
 *     int val;
 *     ListNode next;
 * }
 */
public class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if (m >= n || head == null) {
            return head;
        }
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        head = dummy;
        
        for (int i = 1; i < m; i++) {
            if (head == null) {
                return null;
            }
            head = head.next;
        }
        
        ListNode premNode = head;
        ListNode mNode = head.next;
        ListNode nNode = mNode, postnNode = mNode.next;
        for (int i = m; i < n; i++) {
            if (postnNode == null) {
                return null;
            }
            ListNode temp = postnNode.next;
            postnNode.next = nNode;
            nNode = postnNode;
            postnNode = temp;
        }
        mNode.next = postnNode;
        premNode.next = nNode;
        
        return dummy.next;
    }
}

===============Reverse Linked List===============
35: Reverse Linked List

"Difficulty Easy Accepted Rate 40%"
         
Reverse a linked list.

Example
For linked list 1->2->3, the reversed linked list is 3->2->1Challenge
Reverse it in-place and in one-pass
Tags
Linked List
Facebook
Uber
Related Problems

(linked-list)Medium
 Palindrome Linked List
 26 %
 
3
(linked-list),(facebook)Hard
 Reverse Nodes in k-Group
 27 %
 
1
(string)Easy
 Reverse Words in a String
 23 %
 
2
(linked-list)Medium
 Reverse Linked List II
 28 %
/**
 * Definition for ListNode.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int val) {
 *         this.val = val;
 *         this.next = null;
 *     }
 * }
 */ 
public class Solution {
    /**
     * @param head: The head of linked list.
     * @return: The new head of reversed linked list.
     */
    public ListNode reverse(ListNode head) {
        ListNode prev = null;
        while (head != null) {
            ListNode temp = head.next;
            head.next = prev;
            prev = head;
            head = temp;
        }
        return prev;
    }
}

===============Reverse Nodes in k-Group===============
450: Reverse Nodes in k-Group

"Difficulty Hard Accepted Rate 27%"
         
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

Example
Given this linked list: 1->2->3->4->5
For k = 2, you should return: 2->1->4->3->5
For k = 3, you should return: 3->2->1->4->5

Tags
Linked List
Facebook
Related Problems
1
(linked-list)Easy
 Swap Nodes in Pairs
 29 %
 
2
(basic-implementation),(linked-list)Medium
 Rotate List
 25 %
 
2
(linked-list)Medium
 Reverse Linked List II
 28 %
 
1
(linked-list),(facebook),(uber)Easy
 Reverse Linked List
 40 %
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    /**
     * @param head a ListNode
     * @param k an integer
     * @return a ListNode
     */
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || k <= 1) {
            return head;
        }
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        
        head = dummy;
        while (head.next != null) {
            head = reverseNextK(head, k);
        }
        
        return dummy.next;
    }
    
    // reverse head->n1->..->nk->next..
    // to head->nk->..->n1->next..
    // return n1
    private ListNode reverseNextK(ListNode head, int k) {
        // check there is enought nodes to reverse
        ListNode next = head; // next is not null
        for (int i = 0; i < k; i++) {
            if (next.next == null) {
                return next;
            }
            next = next.next;
        }
        
        // reverse
        ListNode n1 = head.next;
        ListNode prev = head, curt = n1;
        for (int i = 0; i < k; i++) {
            ListNode temp = curt.next;
            curt.next = prev;
            prev = curt;
            curt = temp;
        }
        
        n1.next = curt;
        head.next = prev;
        return n1;
    }
}Rotate List++


===============Sort List===============
98: Sort List

"Difficulty Medium Accepted Rate 27%"
         
Sort a linked list in O(n log n) time using constant space complexity.

Example
Given 1-3->2->null, sort it to 1->2->3->null.

Tags
Linked List
Related Problems
1
(sort),(linked-list)Easy
 Insertion Sort List
 29 %
// version 1: Merge Sort
public class Solution {            
    private ListNode findMiddle(ListNode head) {
        ListNode slow = head, fast = head.next;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }    

    private ListNode merge(ListNode head1, ListNode head2) {
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        while (head1 != null && head2 != null) {
            if (head1.val < head2.val) {
                tail.next = head1;
                head1 = head1.next;
            } else {
                tail.next = head2;
                head2 = head2.next;
            }
            tail = tail.next;
        }
        if (head1 != null) {
            tail.next = head1;
        } else {
            tail.next = head2;
        }

        return dummy.next;
    }

    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode mid = findMiddle(head);

        ListNode right = sortList(mid.next);
        mid.next = null;
        ListNode left = sortList(head);

        return merge(left, right);
    }
}

// version 2: Quick Sort 1
public class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        
        ListNode mid = findMedian(head); // O(n)
        
        ListNode leftDummy = new ListNode(0), leftTail = leftDummy;
        ListNode rightDummy = new ListNode(0), rightTail = rightDummy;
        ListNode middleDummy = new ListNode(0), middleTail = middleDummy;
        while (head != null) {
            if (head.val < mid.val) {
                leftTail.next = head;
                leftTail = head;
            } else if (head.val > mid.val) {
                rightTail.next = head;
                rightTail = head;
            } else {
                middleTail.next = head;
                middleTail = head;
            }
            head = head.next;
        }
        
        leftTail.next = null;
        middleTail.next = null;
        rightTail.next = null;
        
        ListNode left = sortList(leftDummy.next);
        ListNode right = sortList(rightDummy.next);
        
        return concat(left, middleDummy.next, right);
    }
    
    private ListNode findMedian(ListNode head) {
        ListNode slow = head, fast = head.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
    
    private ListNode concat(ListNode left, ListNode middle, ListNode right) {
        ListNode dummy = new ListNode(0), tail = dummy;
        
        tail.next = left; tail = getTail(tail);
        tail.next = middle; tail = getTail(tail);
        tail.next = right; tail = getTail(tail);
        return dummy.next;
    }
    
    private ListNode getTail(ListNode head) {
        if (head == null) {
           return null;
        } 
       
        while (head.next != null) {
            head = head.next;
        }
        return head;
    }
}

// version 3: Quick Sort 2
/**
 * Definition for ListNode.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int val) {
 *         this.val = val;
 *         this.next = null;
 *     }
 * }
 */ 
class Pair {
    public ListNode first, second; 
    public Pair(ListNode first, ListNode second) {
        this.first = first;
        this.second = second;
    }
}

public class Solution {
    /**
     * @param head: The head of linked list.
     * @return: You should return the head of the sorted linked list,
                    using constant space complexity.
     */
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        
        ListNode mid = findMedian(head); // O(n)
        Pair pair = partition(head, mid.val); // O(n)
        
        ListNode left = sortList(pair.first);
        ListNode right = sortList(pair.second);
        
        getTail(left).next = right; // O(n)
        
        return left;
    }
    
    // 1->2->3 return 2
    // 1->2 return 1
    private ListNode findMedian(ListNode head) {
        ListNode slow = head, fast = head.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
    
    // < value in the left, > value in the right
    private Pair partition(ListNode head, int value) {
        ListNode leftDummy = new ListNode(0), leftTail = leftDummy;
        ListNode rightDummy = new ListNode(0), rightTail = rightDummy;
        ListNode equalDummy = new ListNode(0), equalTail = equalDummy;
        while (head != null) {
            if (head.val < value) {
                leftTail.next = head;
                leftTail = head;
            } else if (head.val > value) {
                rightTail.next = head;
                rightTail = head;
            } else {
                equalTail.next = head;
                equalTail = head;
            }
            head = head.next;
        }
        
        leftTail.next = null;
        rightTail.next = null;
        equalTail.next = null;
        
        if (leftDummy.next == null && rightDummy.next == null) {
            ListNode mid = findMedian(equalDummy.next);
            leftDummy.next = equalDummy.next;
            rightDummy.next = mid.next;
            mid.next = null;
        } else if (leftDummy.next == null) {
            leftTail.next = equalDummy.next;
        } else {
            rightTail.next = equalDummy.next;
        }
        
        return new Pair(leftDummy.next, rightDummy.next);
    }
    
    private ListNode getTail(ListNode head) {
        if (head == null) {
           return null;
        } 
       
        while (head.next != null) {
            head = head.next;
        }
        return head;
    }
}

===============Swap Nodes in Pairs===============
451: Swap Nodes in Pairs

"Difficulty Easy Accepted Rate 29%"
         
Given a linked list, swap every two adjacent nodes and return its head.

Example
Given 1->2->3->4, you should return the list as 2->1->4->3.Challenge
Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.
Tags
Linked List
Related Problems
3
(linked-list),(facebook)Hard
 Reverse Nodes in k-Group
 27 %
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    /**
     * @param head a ListNode
     * @return a ListNode
     */
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        
        head = dummy;
        while (head.next != null && head.next.next != null) {
            ListNode n1 = head.next, n2 = head.next.next;
            // head->n1->n2->...
            // => head->n2->n1->...
            head.next = n2;
            n1.next = n2.next;
            n2.next = n1;
            
            // move to next pair
            head = n1;
        }
        
        return dummy.next;
    }
}++++++++++++Tag: Array++++++++++++
3Sum Closest++
3Sum++
4Sum++
Best Time to Buy and Sell Stock II++
Best Time to Buy and Sell Stock III++
Best Time to Buy and Sell Stock++
Candy++
Coins in a Line II++
Coins in a Line++
Combination Sum II++
Combination Sum++
Combinations++
Container With Most Water++
Continuous Subarray Sum++
Find Peak Element++


===============First Missing Positive===============
189: First Missing Positive

"Difficulty Medium Accepted Rate 21%"
         
Given an unsorted integer array, find the first missing positive integer.

Example
Given [1,2,0] return 3,
and [3,4,-1,1] return 2.Challenge
Your algorithm should run in O(n) time and uses constant space.
Tags
Array
Related Problems

(greedy)Medium
 Find the Missing Number
 29 %
public class Solution {

    public int firstMissingPositive(int[] A) {
        if (A == null) {
            return 1;
        }

        for (int i = 0; i < A.length; i++) {
            while (A[i] > 0 && A[i] <= A.length && A[i] != (i+1)) {
                int tmp = A[A[i]-1];
                if (tmp == A[i]) {
                    break;
                }
                A[A[i]-1] = A[i];
                A[i] = tmp;
            }
        }

        for (int i = 0; i < A.length; i ++) {
                if (A[i] != i + 1) {
                    return i + 1;
                }
        }

        return A.length + 1;
    }
}First Position of Target++
Jump Game II++
Jump Game++


===============Largest Rectangle in Histogram===============
122: Largest Rectangle in Histogram

"Difficulty Hard Accepted Rate 24%"
         
Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.

Example
Given height = [2,1,5,6,2,3],return 10.

Tags
Array
Stack
Related Problems
public class Solution {
    public int largestRectangleArea(int[] height) {
        if (height == null || height.length == 0) {
            return 0;
        }
        
        Stack<Integer> stack = new Stack<Integer>();
        int max = 0;
        for (int i = 0; i <= height.length; i++) {
            int curt = (i == height.length) ? -1 : height[i];
            while (!stack.isEmpty() && curt <= height[stack.peek()]) {
                int h = height[stack.pop()];
                int w = stack.isEmpty() ? i : i - stack.peek() - 1;
                max = Math.max(max, h * w);
            }
            stack.push(i);
        }
        
        return max;
    }
}

===============Longest Consecutive Sequence===============
124: Longest Consecutive Sequence

"Difficulty Medium Accepted Rate 31%"
         
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.


Example
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
Clarification
Your algorithm should run in O(n) complexity.

Tags
Array
public class Solution {
    // Sort & search: space O(1), time O(n logn)
    // HashMap: space O(n), time O(n)
    public int longestConsecutive(int[] num) {
        HashMap<Integer, Integer> hs = new HashMap<Integer, Integer>();
        for(int i: num){
            hs.put(i, 0);
        }
        int maxl = 1;
        for(int i: num){
            if (hs.get(i) == 1) continue;

            int tmp = i;
            int current_max = 1;
            while(hs.containsKey(tmp+1)){
                current_max ++;
                tmp ++;
                hs.put(tmp, 1);
            }

            tmp = i;
            while(hs.containsKey(tmp-1)){
                current_max ++;
                tmp --;
                hs.put(tmp, 1);
            }

            maxl = Math.max(current_max, maxl);
        }

        return maxl;
    }
}Longest Increasing Continuous Subsequence++
Maximum Subarray Difference++
Maximum Subarray II++
Maximum Subarray III++
Maximum Subarray++
Median of two Sorted Arrays++
Median++
Merge Intervals++
Merge Sorted Array II++
Merge Sorted Array++
Minimum Size Subarray Sum++
Minimum Subarray++
Next Permutation II++
Number of Airplanes in the Sky++
Partition Array by Odd and Even++
Partition Array++
Permutation Sequence++


===============Plus One===============
407: Plus One

"Difficulty Easy Accepted Rate 30%"
         
Given a non-negative number represented as an array of digits, plus one to the number.

Example
Given [1,2,3] which represents 123, return [1,2,4].
Given [9,9,9] which represents 999, return [1,0,0,0].

Tags
Array
Google
Related Problems

(high-precision)Medium
 Divide Two Integers 
 14 %
 
1
(string),(binary),(facebook)Easy
 Add Binary
 22 %
public class Solution {
    // The complexity is O(1)
    // f(n) = 9/10 + 1/10 * O(n-1)
    //  ==>  O(n) =  10 / 9 = 1.1111 = O(1)
    
    public int[] plusOne(int[] digits) {
        int carries = 1;
        for(int i = digits.length-1; i>=0 && carries > 0; i--){  // fast break when carries equals zero
            int sum = digits[i] + carries;
            digits[i] = sum % 10;
            carries = sum / 10;
        }
        if(carries == 0)
            return digits;
            
        int[] rst = new int[digits.length+1];
        rst[0] = 1;
        for(int i=1; i< rst.length; i++){
            rst[i] = digits[i-1];
        }
        return rst;
    }
}Recover Rotated Sorted Array++
Remove Duplicates from Sorted Array II++
Remove Duplicates from Sorted Array++
Remove Element++
Search for a Range++
Search in Rotated Sorted Array II++
Search in Rotated Sorted Array++
Search Insert Position++
Sort Colors++


===============Spiral Matrix II===============
381: Spiral Matrix II

"Difficulty Medium Accepted Rate 34%"
         
Given an integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order.

Example
Given n = 3,
You should return the following matrix:
[
[ 1, 2, 3 ],
[ 8, 9, 4 ],
[ 7, 6, 5 ]
]
Note

Tags
Array
Related Problems

(array),(matrix)Medium
 Spiral Matrix
 23 %
public class Solution {
    public int[][] generateMatrix(int n) {
        if (n < 0) {
            return null;
        }

        int[][] result = new int[n][n];

        int xStart = 0;
        int yStart = 0;
        int num = 1;

        while (n > 0) {
            if (n == 1) {
                result[yStart][xStart] = num++;
                break;
            }

            for (int i = 0; i < n - 1; i++) {
                result[yStart][xStart + i] = num++;
            }

            for (int i = 0; i < n - 1; i++) {
                result[yStart + i][xStart + n - 1] = num++;
            }

            for (int i = 0; i < n - 1; i++) {
                result[yStart + n - 1][xStart + n - 1 - i] = num++;
            }

            for (int i = 0; i < n - 1; i++) {
                result[yStart + n - 1 - i][xStart] = num++;
            }

            xStart++;
            yStart++;
            n = n - 2;
        }

        return result;
    }
}

===============Spiral Matrix===============
374: Spiral Matrix

"Difficulty Medium Accepted Rate 23%"
         
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

Example
Given the following matrix:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]You should return [1,2,3,6,9,8,7,4,5].

Tags
Array
Matrix
Related Problems

(array)Medium
 Spiral Matrix II
 34 %
 
1
(lintcode-copyright),(matrix)Easy
 Matrix Zigzag Traversal
 23 %
// version 1
public class Solution {
    public ArrayList<Integer> spiralOrder(int[][] matrix) {
        ArrayList<Integer> rst = new ArrayList<Integer>();
        if(matrix == null || matrix.length == 0) 
            return rst;
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        int count = 0;
        while(count * 2 < rows && count * 2 < cols){
            for(int i = count; i < cols-count; i++)
                rst.add(matrix[count][i]);
            
            
            for(int i = count+1; i< rows-count; i++)
                rst.add(matrix[i][cols-count-1]);
            
            if(rows - 2 * count == 1 || cols - 2 * count == 1)  // if only one row /col remains
                break;
                
            for(int i = cols-count-2; i>=count; i--)
                rst.add(matrix[rows-count-1][i]);
                
            for(int i = rows-count-2; i>= count+1; i--)
                rst.add(matrix[i][count]);
            
            count++;
        }
        return rst;
    }
}

// version 2: easier to understand but more code
class Direction {
    public static int DOWN = 0;
    public static int RIGHT = 1;
    public static int LEFT = 2;
    public static int UP = 3;
    
    private static int[] dx = new int[]{1, 0, 0, -1};
    private static int[] dy = new int[]{0, 1, -1, 0};

    public static int turnRight(int direction) {
        if (direction == DOWN) {
            return LEFT;
        } else if (direction == RIGHT) {
            return DOWN;
        } else if (direction == LEFT) {
            return UP;
        } else if (direction == UP) {
            return RIGHT;
        }
        return -1;
    }
    
    public static int[] move(int[] cursor, int direction) {
        int[] nextCursor = new int[2];
        nextCursor[0] = cursor[0] + dx[direction];
        nextCursor[1] = cursor[1] + dy[direction];
        return nextCursor;
    }
}

public class Solution {
    /**
     * @param matrix a matrix of m x n elements
     * @return an integer list
     */
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> order = new ArrayList<Integer>();
        
        // check corner case
        if (matrix == null || matrix.length == 0) {
            return order;
        }
        int n = matrix.length;
        
        if (matrix[0] == null || matrix[0].length == 0) {
            return order;
        }
        int m = matrix[0].length;
        
        int direction = Direction.RIGHT;
        int[] cursor = new int[]{0, 0};
        
        for (int i = 0; i < n * m; i++) {
            order.add(matrix[cursor[0]][cursor[1]]);
            // mark the visited position as -1
            matrix[cursor[0]][cursor[1]] = -1;
            int[] nextCursor = Direction.move(cursor, direction);
            // if outside of matrix or marked before, turn right
            if (nextCursor[0] < 0 || nextCursor[0] >= n ||
                  nextCursor[1] < 0 || nextCursor[1] >= m ||
                  matrix[nextCursor[0]][nextCursor[1]] == -1) {
                direction = Direction.turnRight(direction);
                nextCursor = Direction.move(cursor, direction);
            }
            cursor = nextCursor;
        }
        
        return order;
    }
}The Smallest Difference++
Trapping Rain Water++
Two Sum++
Unique Characters++
Unique Paths II++
Unique Paths++
++++++++++++Tag: Stack++++++++++++
Convert Expression to Reverse Polish Notation++
Evaluate Reverse Polish Notation++
Expression Evaluation++
Expression Tree Build++
Implement Queue by Two Stacks++
Largest Rectangle in Histogram++


===============Min Stack===============
12: Min Stack

"Difficulty Medium Accepted Rate 30%"
         
Implement a stack with min() function, which will return the smallest number in the stack.

Example
push(1)
pop() // return 1
push(2)
push(3)
min() // return 2
push(1)
min() // return 1
Note
min operation will never be called if there is no number in the stack.
Tags
Stack
Zenefits
Uber
Google
Related Problems

(lintcode-copyright),(stack),(queue)Medium
 Implement Queue by Two Stacks
 38 %
// version 1:
public class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;
    
    public MinStack() {
        stack = new Stack<Integer>();
        minStack = new Stack<Integer>();
    }

    public void push(int number) {
        stack.push(number);
        if (minStack.isEmpty()) {
            minStack.push(number);
        } else {
            minStack.push(Math.min(number, minStack.peek()));
        }
    }

    public int pop() {
        minStack.pop();
        return stack.pop();
    }

    public int min() {
        return minStack.peek();
    }
}

// version 2, save more space. but space complexity doesn&#39;t change.
public class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    public MinStack() {
        stack = new Stack<Integer>();
        minStack = new Stack<Integer>();
    }

    public void push(int number) {
        stack.push(number);
        if (minStack.empty() == true)
            minStack.push(number);
        else
        if (Integer.parseInt(minStack.peek().toString()) >= number)
            minStack.push(number);
    }

    public int pop() {
        if (stack.peek().equals(minStack.peek()) ) 
            minStack.pop();
        return stack.pop();
    }

    public int min() {
        return minStack.peek();
    }
}Simplify Path++


===============Valid Parentheses===============
423: Valid Parentheses

"Difficulty Easy Accepted Rate 26%"
         
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

Example
The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

Tags
Stack
Google
Related Problems

(string),(backtracking),(recursion),(zenefits),(google)Medium
 Generate Parentheses
 30 %
public class Solution {
	public boolean isValid(String s) {
		Stack<Character> stack = new Stack<Character>();
		for (Character c : s.toCharArray()) {
			if ("({[".contains(String.valueOf(c))) {
				stack.push(c);
			} else {
				if (!stack.isEmpty() && is_valid(stack.peek(), c)) {
					stack.pop();
				} else {
					return false;
				}
			}
		}
		return stack.isEmpty();
	}

	private boolean is_valid(char c1, char c2) {
		return (c1 == &#39;(&#39; && c2 == &#39;)&#39;) || (c1 == &#39;{&#39; && c2 == &#39;}&#39;)
				|| (c1 == &#39;[&#39; && c2 == &#39;]&#39;);
	}
}++++++++++++Tag: Queue++++++++++++


===============Binary Tree Level Order Traversal II===============
70: Binary Tree Level Order Traversal II

"Difficulty Medium Accepted Rate 40%"
         


Example
Given binary tree {3,9,20,#,#,15,7},3
 / \
920
/\
 15 7 
return its bottom-up level order traversal as:[
[15,7],
[9,20],
[3]
]

Tags
Queue
Binary Tree
Binary Tree Traversal
Breadth First Search
public class Solution {
    public ArrayList<ArrayList<Integer>> levelOrderBottom(TreeNode root) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();

        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        int currLevelNodeNum = 1;
        int nextLevelNodeNum = 0;

        while (currLevelNodeNum != 0) {
            ArrayList<Integer> currLevelResult = new ArrayList<Integer>();
            nextLevelNodeNum = 0;

            while (currLevelNodeNum != 0) {
                TreeNode node = queue.poll();

                currLevelNodeNum--;
                currLevelResult.add(node.val);

                if (node.left != null) {
                    queue.offer(node.left);
                    nextLevelNodeNum++;
                }

                if (node.right != null) {
                    queue.offer(node.right);
                    nextLevelNodeNum++;
                }
            }

            result.add(0, currLevelResult);
            currLevelNodeNum = nextLevelNodeNum;
        }
        return result;
    }
}Binary Tree Level Order Traversal++
Binary Tree Zigzag Level Order Traversal++
Implement Queue by Two Stacks++
++++++++++++Tag: Airbnb++++++++++++
House Robber++
Maximal Square++
Merge k Sorted Lists++
Two Sum++
Word Search II++
++++++++++++Tag: Heap++++++++++++
Building Outline++
Data Stream Median++
Heapify++


===============Kth Smallest Number in Sorted Matrix===============
401: Kth Smallest Number in Sorted Matrix

"Difficulty Medium Accepted Rate 17%"
         
Find the kth smallest number in at row and column sorted matrix.

Example
Given k = 4 and a matrix:
[
[1 ,5 ,7],
[3 ,7 ,8],
[4 ,8 ,9],
]return 5Challenge
O(k log n), n is the maximal number in width and height.
Tags
Heap
Priority Queue
Matrix
Related Problems

(quick-sort),(sort)Medium
 Kth Largest Element
 20 %
public class Solution {
    /**
     * @param matrix: a matrix of integers
     * @param k: an integer
     * @return: the kth smallest number in the matrix
     */
     
    public class Point {
        public int x, y, val;
        public Point(int x, int y, int val) {
            this.x = x;
            this.y = y;
            this.val = val;
        }
    } 
    
    Comparator<Point> comp = new Comparator<Point>() {
        public int compare(Point left, Point right) {
            return left.val - right.val;
        }
    };
    
    public int kthSmallest(int[][] matrix, int k) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        if (k > matrix.length * matrix[0].length) {
            return 0;
        }
        return horizontal(matrix, k);
    }
    
    private int horizontal(int[][] matrix, int k) {
        Queue<Point> heap = new PriorityQueue<Point>(k, comp);
        for (int i = 0; i < Math.min(matrix.length, k); i++) {
            heap.offer(new Point(i, 0, matrix[i][0]));
        }
        for (int i = 0; i < k - 1; i++) {
            Point curr = heap.poll();
            if (curr.y + 1 < matrix[0].length) {
                heap.offer(new Point(curr.x, curr.y + 1, matrix[curr.x][curr.y + 1]));
            }
        }
        return heap.peek().val;
    }
    
    private int vertical(int[][] matrix, int k) {
        Queue<Point> heap = new PriorityQueue<Point>(k, comp);
        for (int i = 0; i < Math.min(matrix[0].length, k); i++) {
            heap.offer(new Point(0, i, matrix[0][i]));
        }
        for (int i = 0; i < k - 1; i++) {
            Point curr = heap.poll();
            if (curr.x + 1 < matrix.length) {
                heap.offer(new Point(curr.x + 1, curr.y, matrix[curr.x + 1][curr.y]));
            }
        }
        return heap.peek().val;
    }
}Merge k Sorted Lists++
++++++++++++Tag: Binary Search Tree++++++++++++
Binary Search Tree Iterator++
Insert Node in a Binary Search Tree++
Remove Node in Binary Search Tree++


===============Search Range in Binary Search Tree===============
11: Search Range in Binary Search Tree

"Difficulty Medium Accepted Rate 36%"
         
Given two values k1 and k2 (where k1 < k2) and a root pointer to a Binary Search Tree. Find all the keys of tree in range k1 to k2. i.e. print all x such that k1<=x<=k2 and x is a key of given BST. Return all the keys in ascending order.

Example
If k1 = 10 and k2 = 22, then your function should return [12, 20, 22].
20
 /\
8 22
 / \
4 12
Tags
Binary Search Tree
Binary Tree
Related Problems
1
(binary-search),(array)Easy
 First Position of Target
 30 %
 
2
(binary-tree),(microsoft),(yahoo)Medium
 Binary Tree Serialization
 17 %
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    private ArrayList<Integer> results;
    /**
     * @param root: The root of the binary search tree.
     * @param k1 and k2: range k1 to k2.
     * @return: Return all keys that k1<=key<=k2 in increasing order.
     */
    public ArrayList<Integer> searchRange(TreeNode root, int k1, int k2) {
        results = new ArrayList<Integer>();
        helper(root, k1, k2);
        return results;
    }
    
    private void helper(TreeNode root, int k1, int k2) {
        if (root == null) {
            return;
        }
        if (root.val > k1) {
            helper(root.left, k1, k2);
        }
        if (root.val >= k1 && root.val <= k2) {
            results.add(root.val);
        }
        if (root.val < k2) {
            helper(root.right, k1, k2);
        }
    }
}Validate Binary Search Tree++
++++++++++++Tag: Priority Queue++++++++++++
Data Stream Median++
Kth Smallest Number in Sorted Matrix++
Merge k Sorted Lists++
Ugly Number++
++++++++++++Tag: Trie++++++++++++


===============Add and Search Word===============
473: Add and Search Word

"Difficulty Medium Accepted Rate 17%"
         
Design a data structure that supports the following two operations: addWord(word) and search(word)

Example
addWord("bad")
addWord("dad")
addWord("mad")
search("pad")// return false
search("bad")// return true
search(".ad")// return true
search("b..")// return true
Note
You may assume that all words are consist of lowercase letters a-z.
Tags
Trie
Related Problems

(trie),(facebook),(uber),(google)Medium
 Implement Trie
 24 %
class TrieNode {
    // Initialize your data structure here.
    public HashMap<Character, TrieNode> children;
    public boolean hasWord;
    
    // Initialize your data structure here.
    public TrieNode() {
        children = new HashMap<Character, TrieNode>();
        hasWord = false;
    }
}


public class WordDictionary {
    private TrieNode root;
 
    public WordDictionary(){
        root = new TrieNode();
    }
 
    // Adds a word into the data structure.
    public void addWord(String word) {
        // Write your code here
        TrieNode now = root;
        for(int i = 0; i < word.length(); i++) {
            Character c = word.charAt(i);
            if (!now.children.containsKey(c)) {
                now.children.put(c, new TrieNode());
            }
            now = now.children.get(c);
        }
        now.hasWord = true;
    }
    
    boolean find(String word, int index, TrieNode now) {
        if(index == word.length()){
            if(now.children.size()==0) 
                return true; 
            else
                return false;
        }
        
        Character c = word.charAt(index);
        if (now.children.containsKey(c)) {
            if(index == word.length()-1 && now.children.get(c).hasWord){
                return true;
            }
            return find(word, index+1, now.children.get(c)) ;  
        }else if(c == &#39;.&#39;){
            boolean result = false;
            for(Map.Entry<Character, TrieNode> child: now.children.entrySet()){
                if(index == word.length()-1 && child.getValue().hasWord){
                    return true;
                } 
 
                //if any path is true, set result to be true; 
                if(find(word, index+1, child.getValue()) ){
                    result = true;
                }
            }
 
            return result;
        }else{
            return false;
        }
    }
    
    // Returns if the word is in the data structure. A word could
    // contain the dot character &#39;.&#39; to represent any one letter.
    public boolean search(String word) {
        // Write your code here
        return find(word, 0, root);
    }
}

// Your WordDictionary object will be instantiated and called as such:
// WordDictionary wordDictionary = new WordDictionary();
// wordDictionary.addWord("word");
// wordDictionary.search("pattern");

===============Implement Trie===============
442: Implement Trie

"Difficulty Medium Accepted Rate 24%"
         
Implement a trie with insert, search, and startsWith methods.

Example
insert("lintcode")
search("code") // return false
startsWith("lint") // return true
startsWith("linterror") // return false
insert("linterror")
search("lintcode) // return true
startsWith("linterror") // return true
Note
You may assume that all inputs are consist of lowercase letters a-z.
Tags
Trie
Facebook
Uber
Google
Related Problems

(trie)Medium
 Add and Search Word
 17 %
// Version 1: Array of TrieNode

/**
 * Your Trie object will be instantiated and called as such:
 * Trie trie = new Trie();
 * trie.insert("lintcode");
 * trie.search("lint"); will return false
 * trie.startsWith("lint"); will return true
 */
class TrieNode {
    private TrieNode[] children;
    public boolean hasWord;
    
    // Initialize your data structure here.
    public TrieNode() {
        children = new TrieNode[26];
        hasWord = false;
    }
    
    public void insert(String word, int index) {
        if (index == word.length()) {
            this.hasWord = true;
            return;
        }
        
        int pos = word.charAt(index) - &#39;a&#39;;
        if (children[pos] == null) {
            children[pos] = new TrieNode();
        }
        children[pos].insert(word, index + 1);
    }
    
    public TrieNode find(String word, int index) {
        if (index == word.length()) {
            return this;
        }
        
        int pos = word.charAt(index) - &#39;a&#39;;
        if (children[pos] == null) {
            return null;
        }
        return children[pos].find(word, index + 1);
    }
}

public class Solution {
    private TrieNode root;

    public Solution() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    public void insert(String word) {
        root.insert(word, 0);
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
        TrieNode node = root.find(word, 0);
        return (node != null && node.hasWord);
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
        TrieNode node = root.find(prefix, 0);
        return node != null;
    }
}


// Version 2: HashMap Version
class TrieNode {
    // Initialize your data structure here.
    public HashMap<Character, TrieNode> children;
    public boolean hasWord;
    
    // Initialize your data structure here.
    public TrieNode() {
        children = new HashMap<Character, TrieNode>();
        hasWord = false;
    }
}

public class Solution {
    private TrieNode root;

    public Solution() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    public void insert(String word) {
        TrieNode now = root;
        for(int i = 0; i < word.length(); i++) {
            Character c = word.charAt(i);
            if (!now.children.containsKey(c)) {
                now.children.put(c, new TrieNode());
            }
            now = now.children.get(c);
        }
        now.hasWord = true;
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
        TrieNode now = root;
        for(int i = 0; i < word.length(); i++) {
            Character c = word.charAt(i);
            if (!now.children.containsKey(c)) {
                return false;
            }
            now = now.children.get(c);
        }
        return now.hasWord;
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
        TrieNode now = root;
        for(int i = 0; i < prefix.length(); i++) {
            Character c = prefix.charAt(i);
            if (!now.children.containsKey(c)) {
                return false;
            }
            now = now.children.get(c);
        }
        return true;
    }
}

public class Solution {
    private TrieNode root;

    public Solution() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    public void insert(String word) {
        root.insert(word, 0);
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
        TrieNode node = root.find(word, 0);
        return (node != null && node.hasWord);
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
        TrieNode node = root.find(prefix, 0);
        return node != null;
    }
}Word Search II++
++++++++++++Tag: Amazon++++++++++++
++++++++++++Tag: Mathematics++++++++++++
Fibonacci++
Happy Number++
Max Points on a Line++


===============Trailing Zeros===============
2: Trailing Zeros

"Difficulty Easy Accepted Rate 28%"
         
Write an algorithm which computes the number of trailing zeros in n factorial.

Example
11! = 39916800, so the out should be 2Challenge
O(log N) time
Tags
Mathematics
Related Problems
class Solution {
    /*
     * param n: As desciption
     * return: An integer, denote the number of trailing zeros in n!
     */
    public long trailingZeros(long n) {
        long sum = 0;
        while (n != 0) {
            sum += n / 5;
            n /= 5;
        }
        return sum;
    }
};++++++++++++Tag: Binary Tree++++++++++++
Binary Search Tree Iterator++
Binary Tree Inorder Traversal++
Binary Tree Level Order Traversal II++
Binary Tree Level Order Traversal++


===============Binary Tree Paths===============
480: Binary Tree Paths

"Difficulty Easy Accepted Rate 20%"
         
Given a binary tree, return all root-to-leaf paths.

Example
Given the following binary tree:
 1
 / \
2 3
 \
5All root-to-leaf paths are:
[
"1->2->5",
"1->3"
]
Tags
Binary Tree
Binary Tree Traversal
Facebook
Google
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root the root of the binary tree
     * @return all root-to-leaf paths
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<String>();
        if (root == null) {
            return result;
        }
        helper(root, String.valueOf(root.val), result);
        return result;
    }
    
    private void helper(TreeNode root, String path, List<String> result) {
        if (root == null) {
            return;
        }
        
        if (root.left == null && root.right == null) {
            result.add(path);
            return;
        }
        
        if (root.left != null) {
            helper(root.left, path + "->" + String.valueOf(root.left.val), result);
        }
        
        if (root.right != null) {
            helper(root.right, path + "->" + String.valueOf(root.right.val), result);
        }
    }
}Binary Tree Postorder Traversal++
Binary Tree Preorder Traversal++


===============Binary Tree Serialization===============
7: Binary Tree Serialization

"Difficulty Medium Accepted Rate 17%"
         
Design an algorithm and write code to serialize and deserialize a binary tree. Writing the tree to a file is called 'serialization' and reading back from the file to reconstruct the exact same binary tree is 'deserialization'.

Example
An example of testdata: Binary tree {3,9,20,#,#,15,7},denote the following structure:
3
 / \
920
/\
 15 7Our data serialization use bfs traversal. This is just for when you got wrong answer and want to debug the input.
You can use other method to do serializaiton and deserialization.

Tags
Binary Tree
Microsoft
Yahoo
Related Problems

(binary-search-tree),(binary-tree)Medium
 Search Range in Binary Search Tree
 36 %
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
class Solution {
    /**
     * This method will be invoked first, you should design your own algorithm 
     * to serialize a binary tree which denote by a root node to a string which
     * can be easily deserialized by your own "deserialize" method later.
     */
    public String serialize(TreeNode root) {
        if (root == null) {
            return "{}";
        }

        ArrayList<TreeNode> queue = new ArrayList<TreeNode>();
        queue.add(root);

        for (int i = 0; i < queue.size(); i++) {
            TreeNode node = queue.get(i);
            if (node == null) {
                continue;
            }
            queue.add(node.left);
            queue.add(node.right);
        }

        while (queue.get(queue.size() - 1) == null) {
            queue.remove(queue.size() - 1);
        }

        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append(queue.get(0).val);
        for (int i = 1; i < queue.size(); i++) {
            if (queue.get(i) == null) {
                sb.append(",#");
            } else {
                sb.append(",");
                sb.append(queue.get(i).val);
            }
        }
        sb.append("}");
        return sb.toString();
    }
    
    /**
     * This method will be invoked second, the argument data is what exactly
     * you serialized at method "serialize", that means the data is not given by
     * system, it&#39;s given by your own serialize method. So the format of data is
     * designed by yourself, and deserialize it here as you serialize it in 
     * "serialize" method.
     */
    public TreeNode deserialize(String data) {
        if (data.equals("{}")) {
            return null;
        }
        String[] vals = data.substring(1, data.length() - 1).split(",");
        ArrayList<TreeNode> queue = new ArrayList<TreeNode>();
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        queue.add(root);
        int index = 0;
        boolean isLeftChild = true;
        for (int i = 1; i < vals.length; i++) {
            if (!vals[i].equals("#")) {
                TreeNode node = new TreeNode(Integer.parseInt(vals[i]));
                if (isLeftChild) {
                    queue.get(index).left = node;
                } else {
                    queue.get(index).right = node;
                }
                queue.add(node);
            }
            if (!isLeftChild) {
                index++;
            }
            isLeftChild = !isLeftChild;
        }
        return root;
    }
}Binary Tree Zigzag Level Order Traversal++


===============Construct Binary Tree from Inorder and Postorder Traversal===============
72: Construct Binary Tree from Inorder and Postorder Traversal

"Difficulty Medium Accepted Rate 29%"
         
Given inorder and postorder traversal of a tree, construct the binary tree.

Example
Given inorder [1,2,3] and postorder [1,3,2], return a tree:
2
 / \
1 3
Note
You may assume that duplicates do not exist in the tree.
Tags
Binary Tree
public class Solution {
    private int findPosition(int[] arr, int start, int end, int key) {
        int i;
        for (i = start; i <= end; i++) {
            if (arr[i] == key) {
                return i;
            }
        }
        return -1;
    }

    private TreeNode myBuildTree(int[] inorder, int instart, int inend,
            int[] postorder, int poststart, int postend) {
        if (instart > inend) {
            return null;
        }

        TreeNode root = new TreeNode(postorder[postend]);
        int position = findPosition(inorder, instart, inend, postorder[postend]);

        root.left = myBuildTree(inorder, instart, position - 1,
                postorder, poststart, poststart + position - instart - 1);
        root.right = myBuildTree(inorder, position + 1, inend,
                postorder, poststart + position - instart, postend - 1);
        return root;
    }

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if (inorder.length != postorder.length) {
            return null;
        }
        return myBuildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
    }
}

===============Construct Binary Tree from Preorder and Inorder Traversal===============
73: Construct Binary Tree from Preorder and Inorder Traversal

"Difficulty Medium Accepted Rate 27%"
         
Given preorder and inorder traversal of a tree, construct the binary tree.

Example
Given in-order [1,2,3] and pre-order [2,1,3], return a tree:
2
 / \
1 3
Note
You may assume that duplicates do not exist in the tree.
Tags
Binary Tree
public class Solution {
    private int findPosition(int[] arr, int start, int end, int key) {
        int i;
        for (i = start; i <= end; i++) {
            if (arr[i] == key) {
                return i;
            }
        }
        return -1;
    }

    private TreeNode myBuildTree(int[] inorder, int instart, int inend,
            int[] preorder, int prestart, int preend) {
        if (instart > inend) {
            return null;
        }

        TreeNode root = new TreeNode(preorder[prestart]);
        int position = findPosition(inorder, instart, inend, preorder[prestart]);

        root.left = myBuildTree(inorder, instart, position - 1,
                preorder, prestart + 1, prestart + position - instart);
        root.right = myBuildTree(inorder, position + 1, inend,
                preorder, position - inend + preend + 1, preend);
        return root;
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (inorder.length != preorder.length) {
            return null;
        }
        return myBuildTree(inorder, 0, inorder.length - 1, preorder, 0, preorder.length - 1);
    }
}Count of Smaller Number before itself++
Expression Tree Build++


===============Flatten Binary Tree to Linked List===============
453: Flatten Binary Tree to Linked List

"Difficulty Easy Accepted Rate 27%"
         
Flatten a binary tree to a fake "linked list" in pre-order traversal.

Example
1
 \
 12
/ \\
 2 5=>3
/ \ \\
 3 4 64
 \
5
 \
6
Note
Don't forget to mark the left child of each node to null. Or you will get Time Limit Exceeded or Memory Limit Exceeded.
Challenge
Do it in-place without any extra memory.
Tags
Binary Tree
Depth First Search
Related Problems

(recursion),(linked-list)Medium
 Convert Sorted List to Balanced BST
 26 %
// Version 1: Traverse
public class Solution {
    private TreeNode lastNode = null;

    public void flatten(TreeNode root) {
        if (root == null) {
            return;
        }

        if (lastNode != null) {
            lastNode.left = null;
            lastNode.right = root;
        }

        lastNode = root;
        TreeNode right = root.right;
        flatten(root.left);
        flatten(right);
    }
}

// Version 2: Divide & Conquer
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    public void flatten(TreeNode root) {
        flattenHelper(root);
    }
    
    private TreeNode flattenHelper(TreeNode root) {
        if (root == null) {
            return null;
        }
        
        if (root.left == null && root.right == null) {
            return root;
        }
        
        if (root.left == null) {
            return flattenHelper(root.right);
        }
        
        if (root.right == null) {
            root.right = root.left;
            root.left = null; // important!
            return flattenHelper(root.right);
        }
        
        // Divide
        TreeNode leftLastNode = flattenHelper(root.left);
        TreeNode rightLastNode = flattenHelper(root.right);
        
        // Conquer
        leftLastNode.right = root.right;
        root.right = root.left;
        root.left = null; // important!
        return rightLastNode;
    }
}Interval Minimum Number++
Interval Sum II++
Interval Sum++


===============Invert Binary Tree===============
175: Invert Binary Tree

"Difficulty Easy Accepted Rate 41%"
         
Invert a binary tree.

Example
1 1
 / \ / \
2 3=> 3 2
 / \
4 4
Challenge
Do it in recursion is acceptable, can you do it without recursion?
Tags
Binary Tree
/**
 * Definition of TreeNode:
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left, right;
 *     public TreeNode(int val) {
 *         this.val = val;
 *         this.left = this.right = null;
 *     }
 * }
 */
public class Solution {
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    public void invertBinaryTree(TreeNode root) {
        if (root == null) {
            return;
        }
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
        
        invertBinaryTree(root.left);
        invertBinaryTree(root.right);
    }
}Lowest Common Ancestor++
Maximum Depth of Binary Tree++


===============Minimum Depth of Binary Tree===============
155: Minimum Depth of Binary Tree

"Difficulty Easy Accepted Rate 31%"
         
Given a binary tree, find its minimum depth.

Example
Given a binary tree as follow:
1
 / \ 
2 3
 / \
4 5The minimum depth is 2.

Tags
Binary Tree
Depth First Search
Related Problems
1
(divide-and-conquer),(recursion),(binary-tree),(uber)Easy
 Maximum Depth of Binary Tree
 54 %
public class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return getMin(root);
    }

    public int getMin(TreeNode root){
        if (root == null) {
            return Integer.MAX_VALUE;
        }

        if (root.left == null && root.right == null) {
            return 1;
        }

        return Math.min(getMin(root.left), getMin(root.right)) + 1;
    }
}Search Range in Binary Search Tree++
Segment Tree Build++
Segment Tree Modify++
Segment Tree Query II++
Segment Tree Query++
Subtree++
Validate Binary Search Tree++
++++++++++++Tag: Cartesian Tree++++++++++++
++++++++++++Tag: Geeks for Geeks++++++++++++
Topological Sorting++
++++++++++++Tag: Backpack++++++++++++
Backpack II++
Backpack++
Minimum Adjustment Cost++
++++++++++++Tag: Binary Tree Traversal++++++++++++
Binary Tree Inorder Traversal++
Binary Tree Level Order Traversal II++
Binary Tree Level Order Traversal++
Binary Tree Paths++
Binary Tree Postorder Traversal++
Binary Tree Preorder Traversal++
Binary Tree Zigzag Level Order Traversal++
++++++++++++Tag: Depth First Search++++++++++++
Combination Sum II++
Flatten Binary Tree to Linked List++


===============Graph Valid Tree===============
178: Graph Valid Tree

"Difficulty Medium Accepted Rate 22%"
         
Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

Example
Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.
Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.Note
You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.
Tags
Depth First Search
Breadth First Search
Union Find
Facebook
Zenefits
Google
public class Solution {
    private int[] father;
    /**
     * @param n an integer
     * @param edges a list of undirected edges
     * @return true if it&#39;s a valid tree, or false
     */
    public boolean validTree(int n, int[][] edges) {
        // tree should have n nodes with n-1 edges
        if (n - 1 != edges.length) {
            return false;
        }
        
        // union-find is a data structure that can union two sets and check 
        // whether two element in the same set.
        // search it on google for more information
        father = new int[n];
        for (int i = 0; i < n; i++) {
            father[i] = i;
        }
        
        for (int i = 0; i < edges.length; i++) {
            if (find(edges[i][0]) == find(edges[i][1])) {
                return false;
            }
            union(edges[i][0], edges[i][1]);
        }
        
        return true;
    }
    
    int find(int node) {
        if (father[node] == node) {
            return node;
        }
        father[node] = find(father[node]);
        return father[node];
    }
    
    void union(int node1, int node2) {
        father[find(node1)] = find(node2);
    }
}k Sum II++
Minimum Depth of Binary Tree++
N-Queens++
Palindrome Partitioning++
Permutations II++
Route Between Two Nodes in Graph++
Topological Sorting++
Unique Binary Search Trees II++
Word Ladder II++
++++++++++++Tag: Breadth First Search++++++++++++
Binary Tree Level Order Traversal II++
Binary Tree Level Order Traversal++
Binary Tree Zigzag Level Order Traversal++


===============Clone Graph===============
137: Clone Graph

"Difficulty Medium Accepted Rate 25%"
         
Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.

Example
return a deep copied graph.

Tags
Breadth First Search
Facebook
Related Problems

(cracking-the-coding-interview),(depth-first-search),(breadth-first-search)Medium
 Route Between Two Nodes in Graph
 35 %
/**
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     ArrayList<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
 */
public class Solution {
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        if (node == null) {
            return null;
        }

        ArrayList<UndirectedGraphNode> nodes = new ArrayList<UndirectedGraphNode>();
        HashMap<UndirectedGraphNode, UndirectedGraphNode> map
            = new HashMap<UndirectedGraphNode, UndirectedGraphNode>();

        // clone nodes    
        nodes.add(node);
        map.put(node, new UndirectedGraphNode(node.label));

        int start = 0;
        while (start < nodes.size()) {
            UndirectedGraphNode head = nodes.get(start++);
            for (int i = 0; i < head.neighbors.size(); i++) {
                UndirectedGraphNode neighbor = head.neighbors.get(i);
                if (!map.containsKey(neighbor)) {
                    map.put(neighbor, new UndirectedGraphNode(neighbor.label));
                    nodes.add(neighbor);
                }
            }
        }

        // clone neighbors
        for (int i = 0; i < nodes.size(); i++) {
            UndirectedGraphNode newNode = map.get(nodes.get(i));
            for (int j = 0; j < nodes.get(i).neighbors.size(); j++) {
                newNode.neighbors.add(map.get(nodes.get(i).neighbors.get(j)));
            }
        }

        return map.get(node);
    }
}Graph Valid Tree++
Route Between Two Nodes in Graph++


===============Surrounded Regions===============
477: Surrounded Regions

"Difficulty Medium Accepted Rate 19%"
         
Given a 2D board containing 'X' and 'O', capture all regions surrounded by 'X'.

Example
X X X X
X O O X
X X O X
X O X XAfter capture all regions surrounded by 'X', the board should be:
X X X X
X X X X
X X X X
X O X X
Tags
Breadth First Search
Union Find
Related Problems
1
(facebook),(zenefits),(google)Easy
 Number of Islands
 20 %
version 1:
public class Solution {
    static final int[] directionX = {+1, -1, 0, 0};
    static final int[] directionY = {0, 0, +1, -1};
    
    static final char FREE = &#39;F&#39;;
    static final char TRAVELED = &#39;T&#39;;
    
    public void solve(char[][] board) {
        if (board.length == 0) {
            return;
        }
        
        int row = board.length;
        int col = board[0].length;
        
        for (int i = 0; i < row; i++) {
            bfs(board, i, 0);
            bfs(board, i, col - 1);
        }
        
        for (int j = 1; j < col - 1; j++) {
            bfs(board, 0, j);
            bfs(board, row - 1, j);
        }
        
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                switch(board[i][j]) {
                    case &#39;O&#39;: 
                        board[i][j] = &#39;X&#39;;
                        break;
                    case &#39;F&#39;:
                        board[i][j] = &#39;O&#39;;
                }
            }
        }
    }
    
    public void bfs(char[][] board, int i, int j) {
        if (board[i][j] != &#39;O&#39;) {
            return;
        }
        
        Queue<Node> queue = new LinkedList<Node>();
        queue.offer(new Node(i, j));
        
        while (!queue.isEmpty()) {
            Node crt = queue.poll();
            board[crt.x][crt.y] = FREE;
            
            for (Node node : expand(board, crt)) {
                queue.offer(node);
            }
        }
    }
    
    private List<Node> expand(char[][] board, Node node) {
        List<Node> expansion = new ArrayList<Node>();
        
        for (int i = 0; i < directionX.length; i++) {
            int x = node.x + directionX[i];
            int y = node.y + directionY[i];
            
            // check validity
            if (x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] == &#39;O&#39;) {
                board[x][y] = TRAVELED;
                expansion.add(new Node(x, y));
            }
        }
        
        return expansion;
    }
    
    static class Node {
        int x;
        int y;
        
        Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}


version 2:

public class Solution {
    private static Queue<Integer> queue = null;
    private static char[][] board;
    private static int rows = 0;
    private static int cols = 0;

    public void solve(char[][] board) {
        // Note: The Solution object is instantiated only once and is reused by each test case.
        if (board.length == 0 || board[0].length == 0) return;
        queue = new LinkedList<Integer>();
        board = board;
        rows = board.length;
        cols = board[0].length;

        for (int i = 0; i < rows; i++) { // **important**
            enqueue(i, 0);
            enqueue(i, cols - 1);
        }

        for (int j = 1; j < cols - 1; j++) { // **important**
            enqueue(0, j);
            enqueue(rows - 1, j);
        }

        while (!queue.isEmpty()) {
            int cur = queue.poll();
            int x = cur / cols,
                y = cur % cols;

            if (board[x][y] == &#39;O&#39;) {
                board[x][y] = &#39;D&#39;;
            }

            enqueue(x - 1, y);
            enqueue(x + 1, y);
            enqueue(x, y - 1);
            enqueue(x, y + 1);
        }

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (board[i][j] == &#39;D&#39;) board[i][j] = &#39;O&#39;;
                else if (board[i][j] == &#39;O&#39;) board[i][j] = &#39;X&#39;;
            }
        }

        queue = null;
        board = null;
        rows = 0;
        cols = 0;
    }

    public static void enqueue(int x, int y) {
        if (x >= 0 && x < rows && y >= 0 && y < cols && board[x][y] == &#39;O&#39;){  
            queue.offer(x * cols + y);
        }
    }
}Topological Sorting++
Word Ladder II++
Word Ladder++
++++++++++++Tag: Matrix++++++++++++
Kth Smallest Number in Sorted Matrix++
Matrix Zigzag Traversal++
Rotate Image++


===============Search a 2D Matrix II===============
38: Search a 2D Matrix II

"Difficulty Medium Accepted Rate 31%"
         
Write an efficient algorithm that searches for a value in an m x n matrix, return the occurrence of it.

Example
Consider the following matrix:
[
[1, 3, 5, 7],
[2, 4, 7, 8],
[3, 5, 9, 10]
]Given target = 3, return 2.Challenge
O(m+n) time and O(1) extra space
Tags
Matrix
Sorted Matrix
Google
Related Problems
1
(binary-search),(matrix)Easy
 Search a 2D Matrix 
 27 %
public class Solution {
    /**
     * @param matrix: A list of lists of integers
     * @param: A number you want to search in the matrix
     * @return: An integer indicate the occurrence of target in the given matrix
     */
    public int searchMatrix(int[][] matrix, int target) {
        // check corner case
        if (matrix == null || matrix.length == 0) {
            return 0;
        }
        if (matrix[0] == null || matrix[0].length == 0) {
            return 0;
        }
        
        // from bottom left to top right
        int n = matrix.length;
        int m = matrix[0].length;
        int x = n - 1;
        int y = 0;
        int count = 0;
        
        while (x >= 0 && y < m) {
            if (matrix[x][y] < target) {
                y++;
            } else if (matrix[x][y] > target) {
                x--;
            } else {
                count++;
                x--;
                y++;
            }
        }
        return count;
    }
}Search a 2D Matrix++
Set Matrix Zeroes++
Spiral Matrix++
Submatrix Sum++


===============Valid Sudoku===============
389: Valid Sudoku

"Difficulty Easy Accepted Rate 25%"
         
Determine whether a Sudoku is valid.

Example
The following partially filed sudoku is valid.
Note
A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.
Clarification
What is Sudoku?http://sudoku.com.au/TheRules.aspx
https://zh.wikipedia.org/wiki/%E6%95%B8%E7%8D%A8
https://en.wikipedia.org/wiki/Sudoku
http://baike.baidu.com/subview/961/10842669.htm

Tags
Matrix
Uber
public class Solution {
    public boolean isValidSudoku(char[][] board) {
        boolean[] visited = new boolean[9];
        
        // row
        for(int i = 0; i<9; i++){
            Arrays.fill(visited, false);
            for(int j = 0; j<9; j++){
                if(!process(visited, board[i][j]))
                    return false;
            }
        }
        
        //col
        for(int i = 0; i<9; i++){
            Arrays.fill(visited, false);
            for(int j = 0; j<9; j++){
                if(!process(visited, board[j][i]))
                    return false;
            }
        }
        
        // sub matrix
        for(int i = 0; i<9; i+= 3){
            for(int j = 0; j<9; j+= 3){
                Arrays.fill(visited, false);
                for(int k = 0; k<9; k++){
                    if(!process(visited, board[i + k/3][ j + k%3]))
                    return false;                   
                }
            }
        }
        return true;
        
    }
    
    private boolean process(boolean[] visited, char digit){
        if(digit == &#39;.&#39;){
            return true;
        }
        
        int num = digit - &#39;0&#39;;
        if ( num < 1 || num > 9 || visited[num-1]){
            return false;
        }
        
        visited[num-1] = true;
        return true;
    }
}++++++++++++Tag: Segment Tree++++++++++++
Count of Smaller Number before itself++
Count of Smaller Number++
Interval Minimum Number++
Interval Sum II++
Interval Sum++
Segment Tree Build++
Segment Tree Modify++
Segment Tree Query II++
Segment Tree Query++
++++++++++++Tag: OO Design++++++++++++
Singleton++
++++++++++++Tag: Deque++++++++++++
Sliding Window Maximum++
++++++++++++Tag: Merge Sort++++++++++++
++++++++++++Tag: Probability++++++++++++
++++++++++++Tag: Non Recursion++++++++++++
Binary Search Tree Iterator++
Binary Tree Preorder Traversal++
Fibonacci++
++++++++++++Tag: Interval++++++++++++
Number of Airplanes in the Sky++
++++++++++++Tag: Game Theory++++++++++++
Coins in a Line II++
Coins in a Line++
++++++++++++Tag: High Precision++++++++++++
Add Two Numbers++


===============Divide Two Integers===============
414: Divide Two Integers

"Difficulty Medium Accepted Rate 14%"
         
Divide two integers without using multiplication, division and mod operator.

Example
Given dividend = 100 and divisor = 9, return 11.

Tags
High Precision
Related Problems
1
(array),(google)Easy
 Plus One
 30 %
 
1
(string),(binary),(facebook)Easy
 Add Binary
 22 %
public class Solution {
    /**
     * @param dividend the dividend
     * @param divisor the divisor
     * @return the result
     */
    public int divide(int dividend, int divisor) {
        if (divisor == 0) {
             return dividend >= 0? Integer.MAX_VALUE : Integer.MIN_VALUE;
        }
        
        if (dividend == 0) {
            return 0;
        }
        
        if (dividend == Integer.MIN_VALUE && divisor == -1) {
            return Integer.MAX_VALUE;
        }
        
        boolean isNegative = (dividend < 0 && divisor > 0) || 
                             (dividend > 0 && divisor < 0);
                             
        long a = Math.abs((long)dividend);
        long b = Math.abs((long)divisor);
        int result = 0;
        while(a >= b){
            int shift = 0;
            while(a >= (b << shift)){
                shift++;
            }
            a -= b << (shift - 1);
            result += 1 << (shift - 1);
        }
        return isNegative? -result: result;
    }
}++++++++++++Tag: Data Structure Design++++++++++++
++++++++++++Tag: Integer++++++++++++


===============Reverse Integer===============
413: Reverse Integer

"Difficulty Easy Accepted Rate 26%"
         
Reverse digits of an integer. Returns 0 when the reversed integer overflows (signed 32-bit integer).

Example
Given x = 123, return 321
Given x = -123, return -321

Tags
Integer
Related Problems
public class Solution {
    public int reverse(int x) {
        int rst = 0;
        
        while(x != 0) {
            int next_rst = rst * 10 + x % 10;
            x = x / 10;
            if(next_rst/10 != rst) {
                rst  = 0;
                break;
            }
            rst = next_rst;
        }
        return rst;
    }
}++++++++++++Tag: Union Find++++++++++++
Graph Valid Tree++
Surrounded Regions++
++++++++++++Tag: Sorted Matrix++++++++++++
Search a 2D Matrix II++
++++++++++++Tag: Facebook++++++++++++
3Sum++
Add Binary++
Anagrams++
Best Time to Buy and Sell Stock++
Binary Search Tree Iterator++
Binary Tree Level Order Traversal++
Binary Tree Paths++
Clone Graph++
Count and Say++
First Bad Version++
Graph Valid Tree++
Implement Trie++
Letter Combinations of a Phone Number++
Lowest Common Ancestor++
Maximal Square++
Merge k Sorted Lists++
Merge Sorted Array++
Minimum Size Subarray Sum++
Minimum Window Substring++
Regular Expression Matching++
Remove Duplicates from Sorted Array II++
Remove Duplicates from Sorted Array++
Reverse Linked List++
Reverse Nodes in k-Group++
Search in Rotated Sorted Array++
Sort Colors++
strStr++
Subsets++
Two Sum++
Valid Palindrome++
Word Search++
++++++++++++Tag: Snapchat++++++++++++
++++++++++++Tag: Cryptic Studios++++++++++++
++++++++++++Tag: Dropbox++++++++++++
++++++++++++Tag: Zenefits++++++++++++
Generate Parentheses++
Graph Valid Tree++
LRU Cache++
Majority Number II++
Majority Number++
Median of two Sorted Arrays++
Min Stack++
Number of Islands++
Sliding Window Maximum++
Valid Palindrome++
++++++++++++Tag: Microsoft++++++++++++
Binary Tree Serialization++
++++++++++++Tag: Uber++++++++++++
Anagrams++
Best Time to Buy and Sell Stock++
Binary Tree Level Order Traversal++
Copy List with Random Pointer++
Implement Trie++
Letter Combinations of a Phone Number++
LRU Cache++
Maximum Depth of Binary Tree++
Median of two Sorted Arrays++
Merge k Sorted Lists++
Min Stack++
Reverse Linked List++
Roman to Integer++
Search in Rotated Sorted Array++
String to Integer II++
Subsets++
Valid Palindrome++
Valid Sudoku++
++++++++++++Tag: Google++++++++++++
Binary Search Tree Iterator++
Binary Tree Paths++
Building Outline++
Data Stream Median++
Find Peak Element++
Generate Parentheses++
Graph Valid Tree++
Implement Trie++
Insert Interval++
LRU Cache++
Median of two Sorted Arrays++
Merge Intervals++
Merge k Sorted Lists++
Min Stack++
Number of Islands++
Plus One++
Regular Expression Matching++
Search a 2D Matrix II++
Valid Parentheses++
Wildcard Matching++
++++++++++++Tag: Apple++++++++++++
++++++++++++Tag: Epic Systems++++++++++++
++++++++++++Tag: Twitter++++++++++++
Merge k Sorted Lists++
++++++++++++Tag: Yahoo++++++++++++
Binary Tree Serialization++
++++++++++++Tag: TinyCo++++++++++++
